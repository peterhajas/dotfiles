#!/usr/bin/env python3
"""Convert OpenSCAD file to USDZ with color support."""

import json
import os
import re
import struct
import subprocess
import sys
import tempfile
import zipfile
from pathlib import Path

DEFAULT_COLOR = [0.8, 0.8, 0.8, 1.0]

# Full CSS/X11 named colors (OpenSCAD uses these internally, no way to extract via echo)
NAMED_COLORS = {
    "aliceblue": [0.941, 0.973, 1.000],
    "antiquewhite": [0.980, 0.922, 0.843],
    "aqua": [0.000, 1.000, 1.000],
    "aquamarine": [0.498, 1.000, 0.831],
    "azure": [0.941, 1.000, 1.000],
    "beige": [0.961, 0.961, 0.863],
    "bisque": [1.000, 0.894, 0.769],
    "black": [0.000, 0.000, 0.000],
    "blanchedalmond": [1.000, 0.922, 0.804],
    "blue": [0.000, 0.000, 1.000],
    "blueviolet": [0.541, 0.169, 0.886],
    "brown": [0.647, 0.165, 0.165],
    "burlywood": [0.871, 0.722, 0.529],
    "cadetblue": [0.373, 0.620, 0.627],
    "chartreuse": [0.498, 1.000, 0.000],
    "chocolate": [0.824, 0.412, 0.118],
    "coral": [1.000, 0.498, 0.314],
    "cornflowerblue": [0.392, 0.584, 0.929],
    "cornsilk": [1.000, 0.973, 0.863],
    "crimson": [0.863, 0.078, 0.235],
    "cyan": [0.000, 1.000, 1.000],
    "darkblue": [0.000, 0.000, 0.545],
    "darkcyan": [0.000, 0.545, 0.545],
    "darkgoldenrod": [0.722, 0.525, 0.043],
    "darkgray": [0.663, 0.663, 0.663],
    "darkgreen": [0.000, 0.392, 0.000],
    "darkgrey": [0.663, 0.663, 0.663],
    "darkkhaki": [0.741, 0.718, 0.420],
    "darkmagenta": [0.545, 0.000, 0.545],
    "darkolivegreen": [0.333, 0.420, 0.184],
    "darkorange": [1.000, 0.549, 0.000],
    "darkorchid": [0.600, 0.196, 0.800],
    "darkred": [0.545, 0.000, 0.000],
    "darksalmon": [0.914, 0.588, 0.478],
    "darkseagreen": [0.561, 0.737, 0.561],
    "darkslateblue": [0.282, 0.239, 0.545],
    "darkslategray": [0.184, 0.310, 0.310],
    "darkslategrey": [0.184, 0.310, 0.310],
    "darkturquoise": [0.000, 0.808, 0.820],
    "darkviolet": [0.580, 0.000, 0.827],
    "deeppink": [1.000, 0.078, 0.576],
    "deepskyblue": [0.000, 0.749, 1.000],
    "dimgray": [0.412, 0.412, 0.412],
    "dimgrey": [0.412, 0.412, 0.412],
    "dodgerblue": [0.118, 0.565, 1.000],
    "firebrick": [0.698, 0.133, 0.133],
    "floralwhite": [1.000, 0.980, 0.941],
    "forestgreen": [0.133, 0.545, 0.133],
    "fuchsia": [1.000, 0.000, 1.000],
    "gainsboro": [0.863, 0.863, 0.863],
    "ghostwhite": [0.973, 0.973, 1.000],
    "gold": [1.000, 0.843, 0.000],
    "goldenrod": [0.855, 0.647, 0.125],
    "gray": [0.502, 0.502, 0.502],
    "green": [0.000, 0.502, 0.000],
    "greenyellow": [0.678, 1.000, 0.184],
    "grey": [0.502, 0.502, 0.502],
    "honeydew": [0.941, 1.000, 0.941],
    "hotpink": [1.000, 0.412, 0.706],
    "indianred": [0.804, 0.361, 0.361],
    "indigo": [0.294, 0.000, 0.510],
    "ivory": [1.000, 1.000, 0.941],
    "khaki": [0.941, 0.902, 0.549],
    "lavender": [0.902, 0.902, 0.980],
    "lavenderblush": [1.000, 0.941, 0.961],
    "lawngreen": [0.486, 0.988, 0.000],
    "lemonchiffon": [1.000, 0.980, 0.804],
    "lightblue": [0.678, 0.847, 0.902],
    "lightcoral": [0.941, 0.502, 0.502],
    "lightcyan": [0.878, 1.000, 1.000],
    "lightgoldenrodyellow": [0.980, 0.980, 0.824],
    "lightgray": [0.827, 0.827, 0.827],
    "lightgreen": [0.565, 0.933, 0.565],
    "lightgrey": [0.827, 0.827, 0.827],
    "lightpink": [1.000, 0.714, 0.757],
    "lightsalmon": [1.000, 0.627, 0.478],
    "lightseagreen": [0.125, 0.698, 0.667],
    "lightskyblue": [0.529, 0.808, 0.980],
    "lightslategray": [0.467, 0.533, 0.600],
    "lightslategrey": [0.467, 0.533, 0.600],
    "lightsteelblue": [0.690, 0.769, 0.871],
    "lightyellow": [1.000, 1.000, 0.878],
    "lime": [0.000, 1.000, 0.000],
    "limegreen": [0.196, 0.804, 0.196],
    "linen": [0.980, 0.941, 0.902],
    "magenta": [1.000, 0.000, 1.000],
    "maroon": [0.502, 0.000, 0.000],
    "mediumaquamarine": [0.400, 0.804, 0.667],
    "mediumblue": [0.000, 0.000, 0.804],
    "mediumorchid": [0.729, 0.333, 0.827],
    "mediumpurple": [0.576, 0.439, 0.859],
    "mediumseagreen": [0.235, 0.702, 0.443],
    "mediumslateblue": [0.482, 0.408, 0.933],
    "mediumspringgreen": [0.000, 0.980, 0.604],
    "mediumturquoise": [0.282, 0.820, 0.800],
    "mediumvioletred": [0.780, 0.082, 0.522],
    "midnightblue": [0.098, 0.098, 0.439],
    "mintcream": [0.961, 1.000, 0.980],
    "mistyrose": [1.000, 0.894, 0.882],
    "moccasin": [1.000, 0.894, 0.710],
    "navajowhite": [1.000, 0.871, 0.678],
    "navy": [0.000, 0.000, 0.502],
    "oldlace": [0.992, 0.961, 0.902],
    "olive": [0.502, 0.502, 0.000],
    "olivedrab": [0.420, 0.557, 0.137],
    "orange": [1.000, 0.647, 0.000],
    "orangered": [1.000, 0.271, 0.000],
    "orchid": [0.855, 0.439, 0.839],
    "palegoldenrod": [0.933, 0.910, 0.667],
    "palegreen": [0.596, 0.984, 0.596],
    "paleturquoise": [0.686, 0.933, 0.933],
    "palevioletred": [0.859, 0.439, 0.576],
    "papayawhip": [1.000, 0.937, 0.835],
    "peachpuff": [1.000, 0.855, 0.725],
    "peru": [0.804, 0.522, 0.247],
    "pink": [1.000, 0.753, 0.796],
    "plum": [0.867, 0.627, 0.867],
    "powderblue": [0.690, 0.878, 0.902],
    "purple": [0.502, 0.000, 0.502],
    "rebeccapurple": [0.400, 0.200, 0.600],
    "red": [1.000, 0.000, 0.000],
    "rosybrown": [0.737, 0.561, 0.561],
    "royalblue": [0.255, 0.412, 0.882],
    "saddlebrown": [0.545, 0.271, 0.075],
    "salmon": [0.980, 0.502, 0.447],
    "sandybrown": [0.957, 0.643, 0.376],
    "seagreen": [0.180, 0.545, 0.341],
    "seashell": [1.000, 0.961, 0.933],
    "sienna": [0.627, 0.322, 0.176],
    "silver": [0.753, 0.753, 0.753],
    "skyblue": [0.529, 0.808, 0.922],
    "slateblue": [0.416, 0.353, 0.804],
    "slategray": [0.439, 0.502, 0.565],
    "slategrey": [0.439, 0.502, 0.565],
    "snow": [1.000, 0.980, 0.980],
    "springgreen": [0.000, 1.000, 0.498],
    "steelblue": [0.275, 0.510, 0.706],
    "tan": [0.824, 0.706, 0.549],
    "teal": [0.000, 0.502, 0.502],
    "thistle": [0.847, 0.749, 0.847],
    "tomato": [1.000, 0.388, 0.278],
    "turquoise": [0.251, 0.878, 0.816],
    "violet": [0.933, 0.510, 0.933],
    "wheat": [0.961, 0.871, 0.702],
    "white": [1.000, 1.000, 1.000],
    "whitesmoke": [0.961, 0.961, 0.961],
    "yellow": [1.000, 1.000, 0.000],
    "yellowgreen": [0.604, 0.804, 0.196],
}


def parse_scad_colors(src: str) -> tuple:
    """Parse OpenSCAD source, extract color calls, return (modified_src, colors)."""
    n = len(src)
    i = 0
    out = []
    colors = []
    seen = {}

    def skip_string(i):
        quote = src[i]
        i += 1
        while i < n:
            if src[i] == '\\':
                i += 2
                continue
            if src[i] == quote:
                return i + 1
            i += 1
        return i

    def skip_line_comment(i):
        i += 2
        while i < n and src[i] != '\n':
            i += 1
        return i

    def skip_block_comment(i):
        i += 2
        while i + 1 < n:
            if src[i:i+2] == '*/':
                return i + 2
            i += 1
        return i

    def parse_balanced(i):
        depth = 0
        start = i
        while i < n:
            ch = src[i]
            if ch in '"\'':
                i = skip_string(i)
                continue
            if src[i:i+2] == '//':
                i = skip_line_comment(i)
                continue
            if src[i:i+2] == '/*':
                i = skip_block_comment(i)
                continue
            if ch == '(':
                depth += 1
            elif ch == ')':
                depth -= 1
                if depth == 0:
                    return src[start+1:i], i + 1
            i += 1
        return None, i

    def split_args(s):
        args = []
        depth = 0
        in_str = False
        quote = ''
        start = 0
        i = 0
        while i < len(s):
            ch = s[i]
            if in_str:
                if ch == '\\':
                    i += 2
                    continue
                if ch == quote:
                    in_str = False
                i += 1
                continue
            if ch in '"\'':
                in_str = True
                quote = ch
            elif ch in '([{':
                depth += 1
            elif ch in ')]}':
                depth -= 1
            elif ch == ',' and depth == 0:
                args.append(s[start:i].strip())
                start = i + 1
            i += 1
        tail = s[start:].strip()
        if tail:
            args.append(tail)
        return args

    while i < n:
        ch = src[i]
        if ch in '"\'':
            end = skip_string(i)
            out.append(src[i:end])
            i = end
            continue
        if src[i:i+2] == '//':
            end = skip_line_comment(i)
            out.append(src[i:end])
            i = end
            continue
        if src[i:i+2] == '/*':
            end = skip_block_comment(i)
            out.append(src[i:end])
            i = end
            continue

        if src[i:i+5] == 'color' and (i == 0 or not src[i-1].isalnum()):
            j = i + 5
            while j < n and src[j].isspace():
                j += 1
            if j < n and src[j] == '(':
                args_str, end = parse_balanced(j)
                if args_str is not None:
                    args = split_args(args_str)
                    color_expr = args[0] if args else 'undef'
                    alpha_expr = args[1] if len(args) > 1 else None

                    if color_expr not in seen:
                        seen[color_expr] = len(colors)
                        colors.append({'expr': color_expr, 'alpha': alpha_expr})

                    idx = seen[color_expr]
                    out.append(f'COLOR_ID({idx}, {args_str})')
                    i = end
                    continue
        out.append(ch)
        i += 1

    return ''.join(out), colors


def parse_color_from_echo(val: str) -> list:
    """Parse color value from OpenSCAD echo output."""
    val = val.strip().strip('"')

    # Check if it's a named color
    name = val.lower()
    if name in NAMED_COLORS:
        return NAMED_COLORS[name] + [1.0]

    # Try to parse as [r, g, b] or [r, g, b, a]
    nums = re.findall(r'[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?', val)
    if len(nums) >= 3:
        rgb = [float(nums[0]), float(nums[1]), float(nums[2])]
        if max(rgb) > 1.0:
            rgb = [v/255.0 for v in rgb]
        a = float(nums[3]) if len(nums) >= 4 else 1.0
        if a > 1.0:
            a = a/255.0
        return rgb + [a]

    return DEFAULT_COLOR.copy()


def read_stl(path: str) -> list:
    """Read STL file, return vertex list."""
    with open(path, 'rb') as f:
        head = f.read(80)
        if head[:5].lower() == b'solid':
            f.seek(0)
            data = f.read().decode('utf-8', errors='ignore')
            if 'facet normal' in data:
                verts = []
                for line in data.splitlines():
                    line = line.strip()
                    if line.startswith('vertex'):
                        parts = line.split()
                        verts.append((float(parts[1]), float(parts[2]), float(parts[3])))
                return verts
        f.seek(80)
        tri_count = struct.unpack('<I', f.read(4))[0]
        verts = []
        for _ in range(tri_count):
            f.read(12)
            v1 = struct.unpack('<3f', f.read(12))
            v2 = struct.unpack('<3f', f.read(12))
            v3 = struct.unpack('<3f', f.read(12))
            f.read(2)
            verts.extend([v1, v2, v3])
        return verts


def fmt_vec(v):
    return '(' + ', '.join(f'{x:.6g}' for x in v) + ')'


def write_usda_multi(meshes: list, path: str):
    """Write multiple meshes to USDA."""
    lines = []
    lines.append('#usda 1.0')
    lines.append('(')
    lines.append('    upAxis = "Y"')
    lines.append('    metersPerUnit = 0.001')
    lines.append(')')
    lines.append('def Xform "Root" {')
    lines.append('  double3 xformOp:rotateXYZ = (-90, 0, 0)')
    lines.append('  uniform token[] xformOpOrder = ["xformOp:rotateXYZ"]')

    for m in meshes:
        verts = m['verts']
        if not verts:
            continue
        rgba = m.get('rgba', [0.8, 0.8, 0.8, 1.0])
        counts = [3] * (len(verts) // 3)
        indices = list(range(len(verts)))

        lines.append(f'  def Mesh "{m["name"]}" {{')
        lines.append('    int[] faceVertexCounts = [' + ', '.join(map(str, counts)) + ']')
        lines.append('    int[] faceVertexIndices = [' + ', '.join(map(str, indices)) + ']')
        lines.append('    point3f[] points = [' + ', '.join(fmt_vec(v) for v in verts) + ']')
        lines.append(f'    color3f[] primvars:displayColor = [{fmt_vec(rgba[:3])}]')
        lines.append('    uniform token primvars:displayColor:interpolation = "constant"')
        lines.append('  }')

    lines.append('}')

    with open(path, 'w') as f:
        f.write('\n'.join(lines))


def main():
    if len(sys.argv) < 2:
        print('Usage: scad2usdz <input.scad> [output.usdz] [-- openscad_args...]', file=sys.stderr)
        sys.exit(1)

    scad_path = sys.argv[1]
    usdz_path = None
    openscad_args = []

    i = 2
    while i < len(sys.argv):
        if sys.argv[i] == '--':
            openscad_args = sys.argv[i+1:]
            break
        elif not usdz_path:
            usdz_path = sys.argv[i]
        i += 1

    if not usdz_path:
        usdz_path = str(Path(scad_path).with_suffix('.usdz'))

    # Read source
    src = Path(scad_path).read_text()

    # Check for colors
    has_colors = 'color' in src and re.search(r'\bcolor\s*\(', src)

    with tempfile.TemporaryDirectory() as tmpdir:
        if has_colors:
            # Parse and extract colors
            modified_src, colors = parse_scad_colors(src)

            if not colors:
                has_colors = False
            else:
                # Initialize with default colors
                for c in colors:
                    c['rgba'] = DEFAULT_COLOR.copy()

                # Evaluate all colors via OpenSCAD echo
                echo_scad = Path(tmpdir) / 'echo_colors.scad'
                echo_lines = [modified_src, '']
                for idx, c in enumerate(colors):
                    echo_lines.append(f'echo(str("COLOR_EVAL:{idx}:", {c["expr"]}));')
                echo_scad.write_text('\n'.join(echo_lines))

                # Run OpenSCAD to get color values
                cmd = ['openscad', '-o', str(Path(tmpdir) / 'dummy.stl'), str(echo_scad)]
                cmd.extend(openscad_args)
                result = subprocess.run(cmd, capture_output=True, text=True)
                output = result.stdout + result.stderr

                # Parse echoed color values
                for line in output.splitlines():
                    if 'COLOR_EVAL:' not in line:
                        continue
                    m = re.search(r'COLOR_EVAL:(\d+):\s*(.+?)\s*$', line)
                    if not m:
                        continue
                    idx = int(m.group(1))
                    if idx < len(colors):
                        colors[idx]['rgba'] = parse_color_from_echo(m.group(2))

                # Create wrapper scad
                wrapper = []
                wrapper.append('// AUTO-GENERATED for color filtering')
                wrapper.append('COLOR_FILTER = is_undef(COLOR_FILTER) ? -1 : COLOR_FILTER;')
                wrapper.append('module COLOR_ID(i, c, a=1.0) {')
                wrapper.append('  if (COLOR_FILTER < 0 || i == COLOR_FILTER) color(c, a) children();')
                wrapper.append('}')
                wrapper.append('')

                colors_scad = Path(tmpdir) / 'colors.scad'
                colors_scad.write_text('\n'.join(wrapper) + '\n' + modified_src)

                # Export each color as separate STL
                meshes = []
                for idx, c in enumerate(colors):
                    stl_path = Path(tmpdir) / f'color_{idx}.stl'
                    cmd = ['openscad', '-o', str(stl_path), '-D', f'COLOR_FILTER={idx}', str(colors_scad)]
                    cmd.extend(openscad_args)
                    print(f'Exporting color {idx}: {c["expr"]}', file=sys.stderr)
                    subprocess.run(cmd, capture_output=True)

                    verts = read_stl(str(stl_path)) if stl_path.exists() else []
                    meshes.append({
                        'name': f'Mesh_{idx}',
                        'verts': verts,
                        'rgba': c['rgba']
                    })

                # Write multi-mesh USDA
                usda_path = Path(tmpdir) / 'model.usda'
                write_usda_multi(meshes, str(usda_path))

        if not has_colors:
            # Simple export without colors
            stl_path = Path(tmpdir) / 'model.stl'
            cmd = ['openscad', '-o', str(stl_path), scad_path]
            cmd.extend(openscad_args)
            print('Exporting STL...', file=sys.stderr)
            subprocess.run(cmd, capture_output=True)

            verts = read_stl(str(stl_path))
            meshes = [{'name': 'Mesh', 'verts': verts, 'rgba': [0.8, 0.8, 0.8, 1.0]}]

            usda_path = Path(tmpdir) / 'model.usda'
            write_usda_multi(meshes, str(usda_path))

        # Package as USDZ
        usdz_abs = str(Path(usdz_path).resolve())
        with zipfile.ZipFile(usdz_abs, 'w', compression=zipfile.ZIP_STORED) as zf:
            zf.write(str(usda_path), 'model.usda')

        print(f'Created: {usdz_path}', file=sys.stderr)
        print(usdz_path)


if __name__ == '__main__':
    main()
