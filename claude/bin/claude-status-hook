#!/usr/bin/env python3
"""
Claude Status Hook
Receives Claude hook events and updates Hammerspoon UI
"""

import sys
import json
import subprocess
import os
import uuid
import time
from pathlib import Path

# Configuration
RESPONSE_DIR = "/tmp"
POLL_INTERVAL = 0.5  # seconds
PERMISSION_TIMEOUT = 300  # 5 minutes

def log(message):
    """Log to stderr and file so we can debug"""
    print(f"[claude-status-hook] {message}", file=sys.stderr)
    try:
        with open("/tmp/claude-status-hook.log", "a") as f:
            import datetime
            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            f.write(f"[{timestamp}] {message}\n")
    except:
        pass

def update_hammerspoon(event_type, data):
    """Send update to Hammerspoon via hs CLI"""
    try:
        json_data = json.dumps(data)
        log(f"Sending to Hammerspoon: {event_type} with data keys: {list(data.keys())}")

        # Escape the JSON for embedding in Lua string
        # Use double brackets [[ ]] for Lua multiline string
        json_escaped = json_data.replace('\\', '\\\\').replace('"', '\\"')

        lua_code = f'''
            local json = "{json_escaped}"
            local ok, data = pcall(hs.json.decode, json)
            if not ok then
                print("ERROR: Failed to decode JSON: " .. tostring(data))
                return
            end
            if claudeStatus and claudeStatus.handleEvent then
                claudeStatus.handleEvent("{event_type}", data)
                print("SUCCESS: Called claudeStatus.handleEvent")
            else
                print("ERROR: claudeStatus not loaded or no handleEvent function")
            end
        '''

        result = subprocess.run(
            ['hs', '-c', lua_code],
            capture_output=True,
            text=True,
            timeout=5
        )

        if result.returncode != 0:
            log(f"hs command failed (code {result.returncode}): {result.stderr}")
        else:
            log(f"hs command output: {result.stdout.strip()}")

    except subprocess.TimeoutExpired:
        log("Timeout calling hs CLI")
    except FileNotFoundError:
        log("ERROR: hs command not found - is Hammerspoon installed?")
    except Exception as e:
        log(f"Error calling Hammerspoon: {e}")

def get_status_text(event_name, tool_name=None, tool_input=None):
    """Generate readable status text from event"""
    if event_name == "UserPromptSubmit":
        return "Processing your request..."

    elif event_name == "PreToolUse":
        if tool_name == "Bash":
            cmd = tool_input.get('command', '') if tool_input else ''
            # Truncate long commands
            if len(cmd) > 50:
                cmd = cmd[:47] + "..."
            return f"Running: {cmd}"

        elif tool_name == "Write":
            path = tool_input.get('file_path', '') if tool_input else ''
            filename = os.path.basename(path)
            return f"Writing: {filename}"

        elif tool_name == "Read":
            path = tool_input.get('file_path', '') if tool_input else ''
            filename = os.path.basename(path)
            return f"Reading: {filename}"

        elif tool_name == "Edit":
            path = tool_input.get('file_path', '') if tool_input else ''
            filename = os.path.basename(path)
            return f"Editing: {filename}"

        elif tool_name == "Glob":
            pattern = tool_input.get('pattern', '') if tool_input else ''
            return f"Finding: {pattern}"

        elif tool_name == "Grep":
            pattern = tool_input.get('pattern', '') if tool_input else ''
            return f"Searching: {pattern}"

        else:
            return f"Using {tool_name}..."

    elif event_name == "PostToolUse":
        return "Processing..."

    elif event_name == "PermissionRequest":
        if tool_name:
            return f"Needs permission: {tool_name}"
        return "Needs permission"

    elif event_name == "Stop":
        return "Waiting for input"

    elif event_name == "Notification":
        return "Idle"

    elif event_name == "SessionStart":
        return "Session started"

    elif event_name == "SessionEnd":
        return "Session ended"

    else:
        return event_name

def get_permission_description(tool_name, tool_input):
    """Generate human-readable permission request description"""
    if not tool_input:
        return tool_name

    if tool_name == "Bash":
        cmd = tool_input.get('command', '')
        # Truncate very long commands
        if len(cmd) > 80:
            cmd = cmd[:77] + "..."
        return cmd

    elif tool_name == "Write":
        path = tool_input.get('file_path', '')
        return f"Write to: {path}"

    elif tool_name == "Edit":
        path = tool_input.get('file_path', '')
        return f"Edit: {path}"

    else:
        return tool_name

def wait_for_permission_decision(request_id, timeout=PERMISSION_TIMEOUT):
    """Wait for user decision on permission request"""
    response_file = Path(RESPONSE_DIR) / f"claude-perm-{request_id}.json"
    start_time = time.time()

    log(f"Waiting for permission decision: {response_file}")

    while time.time() - start_time < timeout:
        if response_file.exists():
            try:
                with open(response_file, 'r') as f:
                    response = json.load(f)

                # Cleanup file
                try:
                    response_file.unlink()
                except Exception as e:
                    log(f"Failed to cleanup response file: {e}")

                decision = response.get('decision', 'deny')
                log(f"Received decision: {decision}")

                # Return decision in Claude's expected format
                return {
                    "hookSpecificOutput": {
                        "hookEventName": "PermissionRequest",
                        "decision": {
                            "behavior": decision,
                            "message": f"User {decision}ed"
                        }
                    }
                }

            except Exception as e:
                log(f"Error reading response file: {e}")
                break

        time.sleep(POLL_INTERVAL)

    # Timeout - deny by default
    log("Permission request timed out - denying")
    return {
        "hookSpecificOutput": {
            "hookEventName": "PermissionRequest",
            "decision": {
                "behavior": "deny",
                "message": "Timeout"
            }
        }
    }

def handle_user_prompt_submit(data):
    """Handle UserPromptSubmit event"""
    update_hammerspoon('update_session', {
        'session_id': data.get('session_id', 'unknown'),
        'cwd': data.get('cwd', ''),
        'status': 'processing',
        'status_text': get_status_text('UserPromptSubmit'),
        'color': '#FF8C00',  # Orange
        'current_tool': None
    })

def handle_pre_tool_use(data):
    """Handle PreToolUse event"""
    tool_name = data.get('tool_name', 'Unknown')
    tool_input = data.get('tool_input', {})

    update_hammerspoon('update_session', {
        'session_id': data.get('session_id', 'unknown'),
        'cwd': data.get('cwd', ''),
        'status': 'running_tool',
        'status_text': get_status_text('PreToolUse', tool_name, tool_input),
        'color': '#4A90E2',  # Blue
        'current_tool': tool_name
    })

def handle_post_tool_use(data):
    """Handle PostToolUse event"""
    update_hammerspoon('update_session', {
        'session_id': data.get('session_id', 'unknown'),
        'cwd': data.get('cwd', ''),
        'status': 'processing',
        'status_text': get_status_text('PostToolUse'),
        'color': '#FF8C00',  # Orange
        'current_tool': None
    })

def handle_permission_request(data):
    """Handle PermissionRequest event - BLOCKING"""
    request_id = str(uuid.uuid4())
    tool_name = data.get('tool_name', 'Unknown')
    tool_input = data.get('tool_input', {})

    # Send permission request to UI
    update_hammerspoon('permission_request', {
        'session_id': data.get('session_id', 'unknown'),
        'cwd': data.get('cwd', ''),
        'status': 'waiting_permission',
        'status_text': get_status_text('PermissionRequest', tool_name),
        'color': '#E74C3C',  # Red
        'permission_request': {
            'request_id': request_id,
            'tool_name': tool_name,
            'description': get_permission_description(tool_name, tool_input)
        }
    })

    # Wait for decision
    decision = wait_for_permission_decision(request_id)

    # Clear permission state in UI
    update_hammerspoon('update_session', {
        'session_id': data.get('session_id', 'unknown'),
        'cwd': data.get('cwd', ''),
        'status': 'processing',
        'status_text': 'Processing...',
        'color': '#FF8C00',
        'permission_request': None
    })

    # Return decision to Claude
    print(json.dumps(decision))
    sys.stdout.flush()

def handle_stop(data):
    """Handle Stop event"""
    update_hammerspoon('update_session', {
        'session_id': data.get('session_id', 'unknown'),
        'cwd': data.get('cwd', ''),
        'status': 'idle',
        'status_text': get_status_text('Stop'),
        'color': '#2ECC71',  # Green
        'current_tool': None
    })

def handle_notification(data):
    """Handle Notification event"""
    notification_type = data.get('notification_type', '')

    if notification_type == 'idle_prompt':
        update_hammerspoon('update_session', {
            'session_id': data.get('session_id', 'unknown'),
            'cwd': data.get('cwd', ''),
            'status': 'idle',
            'status_text': 'Idle',
            'color': '#2ECC71',  # Green
            'current_tool': None
        })

def handle_session_start(data):
    """Handle SessionStart event"""
    update_hammerspoon('update_session', {
        'session_id': data.get('session_id', 'unknown'),
        'cwd': data.get('cwd', ''),
        'status': 'idle',
        'status_text': 'Session started',
        'color': '#2ECC71',  # Green
        'current_tool': None
    })

def handle_session_end(data):
    """Handle SessionEnd event"""
    update_hammerspoon('remove_session', {
        'session_id': data.get('session_id', 'unknown')
    })

def main():
    """Main entry point"""
    try:
        # Read JSON from stdin
        input_data = sys.stdin.read()

        if not input_data:
            log("No input data received")
            sys.exit(0)

        # Log raw input for debugging
        log(f"Raw input: {input_data[:200]}...")

        # Parse JSON
        try:
            data = json.loads(input_data)
        except json.JSONDecodeError as e:
            log(f"Failed to parse JSON: {e}")
            log(f"Input was: {input_data[:500]}")
            sys.exit(0)

        # Get event name
        event_name = data.get('hook_event_name', 'Unknown')
        log(f"Received event: {event_name}")
        log(f"Data keys: {list(data.keys())}")

        # Route to appropriate handler
        if event_name == "UserPromptSubmit":
            handle_user_prompt_submit(data)

        elif event_name == "PreToolUse":
            handle_pre_tool_use(data)

        elif event_name == "PostToolUse":
            handle_post_tool_use(data)

        elif event_name == "PermissionRequest":
            handle_permission_request(data)

        elif event_name == "Stop":
            handle_stop(data)

        elif event_name == "Notification":
            handle_notification(data)

        elif event_name == "SessionStart":
            handle_session_start(data)

        elif event_name == "SessionEnd":
            handle_session_end(data)

        else:
            log(f"Unknown event type: {event_name}")

    except Exception as e:
        log(f"Error in main: {e}")
        import traceback
        traceback.print_exc(file=sys.stderr)

    # Always exit successfully to not block Claude
    sys.exit(0)

if __name__ == "__main__":
    main()
