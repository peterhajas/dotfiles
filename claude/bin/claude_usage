#!/usr/bin/env python3
"""
Parse claude /usage TUI output to extract usage stats and expiration.
"""

import subprocess
import sys
import re
import time


def capture_claude_usage():
    """Capture the claude /usage TUI output."""
    try:
        # Use script command to capture terminal output
        # -q: quiet mode (no start/done messages)
        # /dev/null: don't save to file
        # The command will be: script -q /dev/null claude /usage

        # Start the process
        process = subprocess.Popen(
            ['script', '-q', '/dev/null', 'claude', '/usage'],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )

        # Wait a bit for the TUI to render
        time.sleep(2)

        # Send 'q' to quit the TUI
        process.stdin.write('q\n')
        process.stdin.flush()

        # Wait for process to finish with timeout
        try:
            stdout, stderr = process.communicate(timeout=3)
        except subprocess.TimeoutExpired:
            process.kill()
            stdout, stderr = process.communicate()

        return stdout + stderr

    except FileNotFoundError:
        print("Error: 'script' command not found", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error capturing claude usage: {e}", file=sys.stderr)
        sys.exit(1)


def parse_usage(output):
    """Parse usage percentage from output."""
    # Look for patterns like "42%", "1.2M / 2.5M", "50000 / 100000 tokens"

    # Pattern 1: Direct percentage
    percent_match = re.search(r'(\d+(?:\.\d+)?)\s*%', output)
    if percent_match:
        return f"{percent_match.group(1)}%"

    # Pattern 2: Fraction of numbers (tokens/requests)
    fraction_match = re.search(r'(\d+(?:\.\d+)?[KMG]?)\s*/\s*(\d+(?:\.\d+)?[KMG]?)', output)
    if fraction_match:
        used = fraction_match.group(1)
        total = fraction_match.group(2)
        return f"{used}/{total}"

    return None


def parse_expiration(output):
    """Parse expiration date/time from output."""
    # Look for various date/time patterns

    # First, look for "Resets" pattern (e.g., "Resets 4pm (America/Denver)")
    resets_match = re.search(r'Resets\s+(\d{1,2}(?::\d{2})?\s*[ap]m)\s*\(([^)]+)\)', output, re.IGNORECASE)
    if resets_match:
        time_str = resets_match.group(1)
        timezone = resets_match.group(2)
        return f"{time_str} ({timezone})"

    # Fallback patterns for other formats
    patterns = [
        # ISO format with time
        r'(\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}(?::\d{2})?)',
        # ISO format date only
        r'(\d{4}-\d{2}-\d{2})',
        # Month Day, Year
        r'([A-Z][a-z]+\s+\d{1,2},?\s+\d{4})',
        # Day Month Year
        r'(\d{1,2}\s+[A-Z][a-z]+\s+\d{4})',
    ]

    for pattern in patterns:
        match = re.search(pattern, output)
        if match:
            return match.group(1)

    return None


def main():
    """Main entry point."""
    # Capture the TUI output
    output = capture_claude_usage()

    # Parse usage
    usage = parse_usage(output)

    # Parse expiration
    expiration = parse_expiration(output)

    # Print results on one line
    if usage and expiration:
        print(f"Usage: {usage} | Resets: {expiration}")
    elif usage:
        print(f"Usage: {usage}")
        print("Error: Could not parse reset time", file=sys.stderr)
    elif expiration:
        print(f"Resets: {expiration}")
        print("Error: Could not parse usage information", file=sys.stderr)
    else:
        print("Error: Could not parse usage information or reset time", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
