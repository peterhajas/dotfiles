#!/bin/sh

# Directories to search (edit these as needed)
SEARCH_DIRS="
$HOME
$HOME/src
"

# Bookmarked sessions: name|path
BOOKMARKS="
phajas-wiki|$HOME/phajas-wiki
scratch|$HOME/scratch
kanata|$HOME/.config/kanata
"

# Function to kill any existing "zellij attach SESSION_NAME" processes
kill_existing_attach_processes() {
    session_name="$1"
    # Kill any zellij clients already attached to this session (tmux-style "attach -d").
    # Match common argv forms like "zellij attach NAME" or "zellij a NAME".
    pids=$(pgrep -f "zellij(\\s+attach|\\s+a)(\\s+[^ ]+)*\\s+$session_name(\\s|$)" 2>/dev/null || true)
    if [ -n "$pids" ]; then
        echo "$pids" | xargs kill 2>/dev/null || true
    fi
}

if [ -n "$ZELLIJ" ]; then
    zellij action launch-or-focus-plugin session-manager --floating --move-to-focused-tab
    exit 0
fi

# Function to get the appropriate layout for a session
get_layout() {
    session_name="$1"
    layout_dir="$HOME/.config/zellij/layouts"

    # First try session-specific layout
    if [ -f "$layout_dir/$session_name.kdl" ]; then
        echo "$session_name"
    else
        # Fall back to zellij's built-in default layout
        echo "default"
    fi
}

set_terminal_title() {
    session_name="$1"
    [ -n "$session_name" ] && printf '\033]0;zellij: %s\a' "$session_name"
}

resolve_dir() {
    dir="$1"
    if [ -n "$dir" ] && [ -d "$dir" ]; then
        (cd "$dir" && pwd)
    else
        pwd
    fi
}

start_new_session() {
    session_name="$1"
    layout="$2"
    session_cwd=$(resolve_dir "$3")

    set_terminal_title "$session_name"

    # Prefer tying the session to a default cwd so new tabs open in the same workspace.
    if ! zellij options --default-cwd "$session_cwd" --default-layout "$layout" --session-name "$session_name" --attach-to-session true 2>/dev/null; then
        # Fallback for older zellij versions.
        (cd "$session_cwd" && zellij --new-session-with-layout "$layout" --session "$session_name")
    fi
}

# Get existing zellij sessions with visual indicator.
# Keep the raw names too so we can do fast membership checks later.
ACTIVE_SESSION_NAMES=$(zellij list-sessions --no-formatting --short 2>/dev/null | awk 'NF { print $1 }')
SESSIONS=""
if [ -n "$ACTIVE_SESSION_NAMES" ]; then
    while IFS= read -r session; do
        [ -n "$session" ] || continue
        SESSIONS="${SESSIONS}${session} [active session]
"
    done <<EOF
$ACTIVE_SESSION_NAMES
EOF
fi

session_exists() {
    target="$1"
    while IFS= read -r active; do
        [ -n "$active" ] || continue
        [ "$active" = "$target" ] && return 0
    done <<EOF
$ACTIVE_SESSION_NAMES
EOF
    return 1
}

# Build bookmark options with a stable label for fzf.
BOOKMARK_OPTIONS=""
IFS='
'
for line in $BOOKMARKS; do
    [ -n "$line" ] || continue
    name=$(printf "%s" "$line" | cut -d'|' -f1)
    dir=$(printf "%s" "$line" | cut -d'|' -f2-)
    [ -n "$name" ] || continue
    # If a session is already active, the active session entry is enough.
    if session_exists "$name"; then
        continue
    fi
    if [ -n "$dir" ] && [ -d "$dir" ]; then
        dir=$(resolve_dir "$dir")
    fi
    BOOKMARK_OPTIONS="${BOOKMARK_OPTIONS}${name} :: ${dir} [bookmark]
"
done
unset IFS

# Find directories at depth 1 in each search directory.
# Use shell globbing to avoid spawning find for every run.
DIRS=""
for search_dir in $SEARCH_DIRS; do
    if [ -d "$search_dir" ]; then
        for dir in "$search_dir"/*; do
            [ -d "$dir" ] || continue
            DIRS="${DIRS}${dir}
"
        done
    fi
done

# Combine sessions (first) and directories.
ALL_OPTIONS="$SESSIONS
$BOOKMARK_OPTIONS
$DIRS"

SCRIPT_PATH="$0"
case "$SCRIPT_PATH" in
    */*) ;;
    *)
        # When invoked via $PATH, $0 may be just "sessionize". Resolve to an
        # actual path so we can reliably find the preview helper next to it.
        SCRIPT_PATH=$(command -v -- "$SCRIPT_PATH" 2>/dev/null || printf "%s" "$SCRIPT_PATH")
        ;;
esac
SCRIPT_DIR=$(CDPATH= cd -- "$(dirname -- "$SCRIPT_PATH")" && pwd)
PREVIEW_HELPER="$SCRIPT_DIR/.zellij_sessionize_preview"
PREVIEW_CMD="sh $PREVIEW_HELPER {}"
RESULT=$(printf "%s\n" "$ALL_OPTIONS" | grep -v '^$' | fzf --prompt="Session: " --print-query --expect=ctrl-n --preview="$PREVIEW_CMD" --preview-window=right:70%:wrap --bind=ctrl-/:toggle-preview --ansi)

if [ -z "$RESULT" ]; then
    exit 0
fi

# fzf outputs: key pressed, query, selection
KEY=""
QUERY=""
SELECTION=""
{
    IFS= read -r KEY
    IFS= read -r QUERY
    IFS= read -r SELECTION
} <<EOF
$RESULT
EOF

# If Ctrl+N was pressed or no selection was made, create new session with query name
if [ "$KEY" = "ctrl-n" ] || [ -z "$SELECTION" ]; then
    SESSION_NAME="$QUERY"
    if [ -z "$SESSION_NAME" ]; then
        exit 0
    fi
    LAYOUT=$(get_layout "$SESSION_NAME")
    SESSION_CWD=$(pwd)

    # Check if session already exists
    if session_exists "$SESSION_NAME"; then
        # Session exists, attach to it
        if [ -n "$ZELLIJ" ]; then
            # Can't switch sessions from within Zellij, do nothing
            exit 0
        else
            kill_existing_attach_processes "$SESSION_NAME"
            set_terminal_title "$SESSION_NAME"
            zellij attach "$SESSION_NAME"
        fi
    else
        # Session doesn't exist, create it
        if [ -n "$ZELLIJ" ]; then
            zellij action new-session --layout "$LAYOUT" --name "$SESSION_NAME"
        else
            start_new_session "$SESSION_NAME" "$LAYOUT" "$SESSION_CWD"
        fi
    fi
    exit 0
fi

# Handle existing session selection
case "$SELECTION" in
*" [active session]")
    SESSION_NAME=${SELECTION% \[active session\]}
    if [ -n "$ZELLIJ" ]; then
        # Can't switch sessions from within Zellij, do nothing
        exit 0
    else
        kill_existing_attach_processes "$SESSION_NAME"
        set_terminal_title "$SESSION_NAME"
        zellij attach "$SESSION_NAME"
    fi
    exit 0
    ;;
esac

# Handle bookmark selection
case "$SELECTION" in
*" [bookmark]")
    SELECTION_NO_TAG=${SELECTION% \[bookmark\]}
    SESSION_NAME=${SELECTION_NO_TAG%% :: *}
    BOOKMARK_DIR=${SELECTION_NO_TAG#* :: }

    if [ -z "$SESSION_NAME" ]; then
        exit 0
    fi

    if [ -z "$BOOKMARK_DIR" ] || [ ! -d "$BOOKMARK_DIR" ]; then
        BOOKMARK_DIR="$HOME"
    fi

    if session_exists "$SESSION_NAME"; then
        if [ -n "$ZELLIJ" ]; then
            exit 0
        else
            kill_existing_attach_processes "$SESSION_NAME"
            set_terminal_title "$SESSION_NAME"
            zellij attach "$SESSION_NAME"
        fi
    else
        LAYOUT=$(get_layout "$SESSION_NAME")
        if [ -n "$ZELLIJ" ]; then
            zellij action new-session --layout "$LAYOUT" --name "$SESSION_NAME"
        else
            start_new_session "$SESSION_NAME" "$LAYOUT" "$BOOKMARK_DIR"
        fi
    fi
    exit 0
    ;;
esac

# Handle directory choice
DIR="$SELECTION"
SESSION_NAME=${DIR##*/}

# Check if session exists
if session_exists "$SESSION_NAME"; then
    # Session exists, attach to it
    if [ -n "$ZELLIJ" ]; then
        # Can't switch sessions from within Zellij, do nothing
        exit 0
    else
        kill_existing_attach_processes "$SESSION_NAME"
        set_terminal_title "$SESSION_NAME"
        zellij attach "$SESSION_NAME"
    fi
else
    # Session doesn't exist
    if [ -n "$ZELLIJ" ]; then
        # Inside Zellij: just switch (do nothing if session doesn't exist)
        exit 0
    else
        # Outside Zellij: create new session
        LAYOUT=$(get_layout "$SESSION_NAME")
        start_new_session "$SESSION_NAME" "$LAYOUT" "$DIR"
    fi
fi
