#!/usr/bin/env python3

import os
import re
import sys

def get_wiki_path():
    wiki_path = os.environ.get('TIDDLYWIKI_WIKI_PATH')

    if not wiki_path:
        print("Error: TIDDLYWIKI_WIKI_PATH environment variable is not set", file=sys.stderr)
        sys.exit(1)

    # Expand ~ to home directory
    wiki_path = os.path.expanduser(wiki_path)

    if not os.path.exists(wiki_path):
        print(f"Error: Wiki path does not exist: {wiki_path}", file=sys.stderr)
        sys.exit(1)

    return wiki_path

def extract_tiddler_stores(content):
    """Extract tiddler store JSON arrays from HTML content."""
    import json

    stores = []
    # Find the start of each tiddler store
    pattern = r'<script class="tiddlywiki-tiddler-store" type="application/json">'

    pos = 0
    while True:
        start_match = content.find(pattern, pos)
        if start_match == -1:
            break

        # Find the start of the JSON array
        json_start = content.find('[', start_match)
        if json_start == -1:
            break

        # Find the matching closing tag
        end_tag = '</script>'
        end_match = content.find(end_tag, json_start)
        if end_match == -1:
            break

        # Extract the JSON (trim whitespace)
        json_str = content[json_start:end_match].strip()

        try:
            # Use strict=False to allow control characters like tabs/newlines in strings
            tiddlers = json.loads(json_str, strict=False)
            stores.append({
                'start': start_match,
                'end': end_match + len(end_tag),
                'tiddlers': tiddlers
            })
        except json.JSONDecodeError as e:
            print(f"Warning: Failed to parse tiddler store: {e}", file=sys.stderr)

        pos = end_match + len(end_tag)

    return stores

def load_all_tiddlers(wiki_path):
    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    stores = extract_tiddler_stores(content)

    if not stores:
        print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
        sys.exit(1)

    # Collect all tiddlers from all stores
    all_tiddlers = []
    for store in stores:
        all_tiddlers.extend(store['tiddlers'])

    if not all_tiddlers:
        print("Error: Could not find any tiddlers in wiki", file=sys.stderr)
        sys.exit(1)

    return all_tiddlers

def list_tiddlers(wiki_path):
    all_tiddlers = load_all_tiddlers(wiki_path)

    # Collect all titles and sort alphabetically
    titles = [tiddler['title'] for tiddler in all_tiddlers if 'title' in tiddler]
    titles.sort()

    # Print all tiddler titles
    for title in titles:
        print(title)

def cat_tiddler(wiki_path, tiddler_title):
    all_tiddlers = load_all_tiddlers(wiki_path)

    # Find the tiddler with matching title
    tiddler = None
    for t in all_tiddlers:
        if t.get('title') == tiddler_title:
            tiddler = t
            break

    if not tiddler:
        print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
        sys.exit(1)

    # Print title first
    if 'title' in tiddler:
        print(f"title: {tiddler['title']}")

    # Print all other fields except 'text' and 'title'
    for key, value in sorted(tiddler.items()):
        if key not in ('text', 'title'):
            print(f"{key}: {value}")

    # Print the text content after a newline
    if 'text' in tiddler:
        print()
        print(tiddler['text'])

def get_tiddlywiki_timestamp():
    """Generate a TiddlyWiki timestamp in format YYYYMMDDhhmmssxxx (UTC)"""
    from datetime import datetime, timezone

    now = datetime.now(timezone.utc)
    # Format: YYYYMMDDhhmmssxxx where xxx is milliseconds
    timestamp = now.strftime('%Y%m%d%H%M%S') + f'{now.microsecond // 1000:03d}'
    return timestamp

def get_tiddler_field(wiki_path, tiddler_title, field_name):
    """Get the value of a specific field from a tiddler"""
    all_tiddlers = load_all_tiddlers(wiki_path)

    # Find the tiddler with matching title
    tiddler = None
    for t in all_tiddlers:
        if t.get('title') == tiddler_title:
            tiddler = t
            break

    if not tiddler:
        print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
        sys.exit(1)

    if field_name not in tiddler:
        print(f"Error: Field '{field_name}' not found in tiddler '{tiddler_title}'", file=sys.stderr)
        sys.exit(1)

    # Print the field value
    print(tiddler[field_name])

def json_tiddler(wiki_path, tiddler_title):
    """Output a tiddler as JSON"""
    import json

    all_tiddlers = load_all_tiddlers(wiki_path)

    # Find the tiddler with matching title
    tiddler = None
    for t in all_tiddlers:
        if t.get('title') == tiddler_title:
            tiddler = t
            break

    if not tiddler:
        print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
        sys.exit(1)

    # Print as formatted JSON
    print(json.dumps(tiddler, indent=2, ensure_ascii=False))

def set_tiddler_field(wiki_path, tiddler_title, field_name, field_value):
    """Set the value of a specific field in a tiddler"""
    import json

    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    stores = extract_tiddler_stores(content)

    if not stores:
        print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
        sys.exit(1)

    # Find the tiddler
    found_tiddler = None
    for store in stores:
        for tiddler in store['tiddlers']:
            if tiddler.get('title') == tiddler_title:
                found_tiddler = tiddler
                break
        if found_tiddler:
            break

    if not found_tiddler:
        print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
        sys.exit(1)

    # Set the field value
    found_tiddler[field_name] = field_value

    # Update modified timestamp if we're not setting it directly
    if field_name != 'modified':
        found_tiddler['modified'] = get_tiddlywiki_timestamp()

    # Build replacements for all stores
    replacements = []
    for store in stores:
        # Sort tiddlers alphabetically by title
        sorted_tiddlers = sorted(store['tiddlers'], key=lambda t: t.get('title', ''))
        # Rebuild the script tag
        tiddler_jsons = [json.dumps(t, ensure_ascii=False, separators=(',', ':')) for t in sorted_tiddlers]
        new_json = '[\n' + ',\n'.join(tiddler_jsons) + '\n]'
        new_json = new_json.replace('<', '\\u003C')
        new_store = f'<script class="tiddlywiki-tiddler-store" type="application/json">{new_json}</script>'
        replacements.append((store['start'], store['end'], new_store))

    # Apply replacements in reverse order
    new_content = content
    for start, end, replacement in reversed(replacements):
        new_content = new_content[:start] + replacement + new_content[end:]

    # Write back
    with open(wiki_path, 'w', encoding='utf-8') as f:
        f.write(new_content)

    print(f"Set {field_name} = {field_value}")

def touch_tiddler(wiki_path, tiddler_title, text=""):
    """Create a new tiddler or update an existing one"""
    import json

    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    stores = extract_tiddler_stores(content)

    if not stores:
        print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
        sys.exit(1)

    timestamp = get_tiddlywiki_timestamp()

    # Check if tiddler already exists
    existing_tiddler = None
    for store in stores:
        for tiddler in store['tiddlers']:
            if tiddler.get('title') == tiddler_title:
                existing_tiddler = tiddler
                break
        if existing_tiddler:
            break

    if existing_tiddler:
        # Update existing tiddler's modified timestamp
        existing_tiddler['modified'] = timestamp
        if text:
            existing_tiddler['text'] = text
        print(f"Updated tiddler: {tiddler_title}")
    else:
        # Create new tiddler
        new_tiddler = {
            "title": tiddler_title,
            "created": timestamp,
            "modified": timestamp,
            "text": text
        }

        # Add to the first store
        stores[0]['tiddlers'].append(new_tiddler)
        print(f"Created tiddler: {tiddler_title}")

    # Build replacements for all stores
    replacements = []
    for store in stores:
        # Sort tiddlers alphabetically by title
        sorted_tiddlers = sorted(store['tiddlers'], key=lambda t: t.get('title', ''))
        # Rebuild the script tag
        tiddler_jsons = [json.dumps(t, ensure_ascii=False, separators=(',', ':')) for t in sorted_tiddlers]
        new_json = '[\n' + ',\n'.join(tiddler_jsons) + '\n]'
        new_json = new_json.replace('<', '\\u003C')
        new_store = f'<script class="tiddlywiki-tiddler-store" type="application/json">{new_json}</script>'
        replacements.append((store['start'], store['end'], new_store))

    # Apply replacements in reverse order
    new_content = content
    for start, end, replacement in reversed(replacements):
        new_content = new_content[:start] + replacement + new_content[end:]

    # Write back
    with open(wiki_path, 'w', encoding='utf-8') as f:
        f.write(new_content)

def remove_tiddler(wiki_path, tiddler_title):
    import json

    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    stores = extract_tiddler_stores(content)

    if not stores:
        print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
        sys.exit(1)

    found = False

    # Build list of replacements
    replacements = []
    for store in stores:
        original_count = len(store['tiddlers'])
        # Filter out the tiddler with matching title
        filtered_tiddlers = [t for t in store['tiddlers'] if t.get('title') != tiddler_title]

        if len(filtered_tiddlers) < original_count:
            found = True

        # Sort tiddlers alphabetically by title
        sorted_tiddlers = sorted(filtered_tiddlers, key=lambda t: t.get('title', ''))

        # Rebuild the script tag with filtered tiddlers
        # Use ensure_ascii=False to preserve Unicode characters like curly quotes
        # Format each tiddler on its own line
        tiddler_jsons = [json.dumps(t, ensure_ascii=False, separators=(',', ':')) for t in sorted_tiddlers]
        new_json = '[\n' + ',\n'.join(tiddler_jsons) + '\n]'

        # Escape only < (not >) as Unicode to match TiddlyWiki format
        new_json = new_json.replace('<', '\\u003C')

        new_store = f'<script class="tiddlywiki-tiddler-store" type="application/json">{new_json}</script>'

        replacements.append((store['start'], store['end'], new_store))

    # Apply replacements in reverse order to maintain correct positions
    new_content = content
    for start, end, replacement in reversed(replacements):
        new_content = new_content[:start] + replacement + new_content[end:]

    if not found:
        print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
        sys.exit(1)

    # Write the modified content back to the file
    with open(wiki_path, 'w', encoding='utf-8') as f:
        f.write(new_content)

    print(f"Removed tiddler: {tiddler_title}")

def replace_tiddler(wiki_path, markdown_content):
    """Replace a tiddler from cat-style format (YAML frontmatter + text)

    This is the inverse of cat_tiddler - it parses the same format that
    cat outputs and inserts it back into the wiki.
    """
    import json

    # Parse YAML frontmatter and text
    lines = markdown_content.split('\n')

    # Check if content is empty
    if not lines:
        print("Error: Empty content provided", file=sys.stderr)
        sys.exit(1)

    # Parse YAML-style frontmatter (key: value format)
    # Until we hit an empty line, then everything else is text
    tiddler = {}
    text_start_index = None

    for i, line in enumerate(lines):
        if line.strip() == '':
            # Empty line marks end of frontmatter
            text_start_index = i + 1
            break
        elif ':' in line:
            # Parse field: value
            key, value = line.split(':', 1)
            tiddler[key.strip()] = value.strip()
        else:
            # If we encounter a line without ':', treat as start of text
            text_start_index = i
            break

    # Everything after the empty line (or non-field line) is the text
    if text_start_index is not None and text_start_index < len(lines):
        text_content = '\n'.join(lines[text_start_index:])
        # Strip trailing newline for perfect roundtrip with cat
        if text_content:
            # Only strip if it's just whitespace, otherwise keep the content
            text_stripped = text_content.rstrip('\n')
            if text_stripped:  # Only add text field if there's content
                tiddler['text'] = text_stripped

    # Verify it has a title field
    if 'title' not in tiddler:
        print("Error: Tiddler must have a 'title' field", file=sys.stderr)
        sys.exit(1)

    # Add timestamps if missing
    timestamp = get_tiddlywiki_timestamp()

    if 'created' not in tiddler:
        tiddler['created'] = timestamp

    if 'modified' not in tiddler:
        tiddler['modified'] = timestamp

    # Use insert_tiddler to do the actual insertion
    tiddler_json = json.dumps(tiddler)
    insert_tiddler(wiki_path, tiddler_json)

def insert_tiddler(wiki_path, tiddler_json):
    """Insert a tiddler from JSON, replacing if it already exists"""
    import json

    # Parse the input JSON
    try:
        new_tiddler = json.loads(tiddler_json)
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON: {e}", file=sys.stderr)
        sys.exit(1)

    # Verify it has a title field
    if 'title' not in new_tiddler:
        print("Error: Tiddler JSON must have a 'title' field", file=sys.stderr)
        sys.exit(1)

    # Add timestamps if missing
    timestamp = get_tiddlywiki_timestamp()

    if 'created' not in new_tiddler:
        new_tiddler['created'] = timestamp

    if 'modified' not in new_tiddler:
        new_tiddler['modified'] = timestamp

    tiddler_title = new_tiddler['title']

    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    stores = extract_tiddler_stores(content)

    if not stores:
        print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
        sys.exit(1)

    # Check if tiddler already exists and remove it from all stores
    found = False
    for store in stores:
        original_count = len(store['tiddlers'])
        store['tiddlers'] = [t for t in store['tiddlers'] if t.get('title') != tiddler_title]
        if len(store['tiddlers']) < original_count:
            found = True

    # Add the new tiddler to the first store
    stores[0]['tiddlers'].append(new_tiddler)

    # Build replacements for all stores
    replacements = []
    for store in stores:
        # Sort tiddlers alphabetically by title
        sorted_tiddlers = sorted(store['tiddlers'], key=lambda t: t.get('title', ''))
        # Rebuild the script tag
        tiddler_jsons = [json.dumps(t, ensure_ascii=False, separators=(',', ':')) for t in sorted_tiddlers]
        new_json = '[\n' + ',\n'.join(tiddler_jsons) + '\n]'
        new_json = new_json.replace('<', '\\u003C')
        new_store = f'<script class="tiddlywiki-tiddler-store" type="application/json">{new_json}</script>'
        replacements.append((store['start'], store['end'], new_store))

    # Apply replacements in reverse order
    new_content = content
    for start, end, replacement in reversed(replacements):
        new_content = new_content[:start] + replacement + new_content[end:]

    # Write back
    with open(wiki_path, 'w', encoding='utf-8') as f:
        f.write(new_content)

    if found:
        print(f"Replaced tiddler: {tiddler_title}")
    else:
        print(f"Inserted tiddler: {tiddler_title}")

def serve_wiki(wiki_path, host='localhost', port=8080):
    """Serve the TiddlyWiki file locally using Python's built-in HTTP server"""
    from http.server import HTTPServer, BaseHTTPRequestHandler

    class WikiHandler(BaseHTTPRequestHandler):
        def do_GET(self):
            """Handle GET requests by serving the wiki file"""
            try:
                with open(wiki_path, 'rb') as f:
                    content = f.read()

                self.send_response(200)
                self.send_header('Content-Type', 'text/html; charset=utf-8')
                self.send_header('Content-Length', str(len(content)))
                self.end_headers()
                self.wfile.write(content)
            except Exception as e:
                self.send_error(500, f'Error reading wiki file: {e}')

        def log_message(self, format, *args):
            """Override to provide cleaner log messages"""
            print(f"[{self.log_date_time_string()}] {format % args}")

    try:
        server = HTTPServer((host, port), WikiHandler)
        print(f"Serving TiddlyWiki at http://{host}:{port}")
        print(f"Wiki file: {wiki_path}")
        print("Press Ctrl+C to stop the server")
        server.serve_forever()
    except KeyboardInterrupt:
        print("\nServer stopped")
        sys.exit(0)
    except OSError as e:
        if e.errno == 48 or e.errno == 98:  # Address already in use
            print(f"Error: Port {port} is already in use", file=sys.stderr)
        else:
            print(f"Error starting server: {e}", file=sys.stderr)
        sys.exit(1)

def main():
    if len(sys.argv) < 2:
        print("Usage: tw <command> [args]", file=sys.stderr)
        print("Commands:", file=sys.stderr)
        print("  ls                           List all tiddlers", file=sys.stderr)
        print("  cat <tiddler>                Display tiddler contents", file=sys.stderr)
        print("  json <tiddler>               Output tiddler as JSON", file=sys.stderr)
        print("  get <tiddler> <field>        Get a specific field value", file=sys.stderr)
        print("  set <tiddler> <field> <value> Set a field value", file=sys.stderr)
        print("  rm <tiddler>                 Remove a tiddler", file=sys.stderr)
        print("  touch <tiddler> [text]       Create or update a tiddler", file=sys.stderr)
        print("  insert <json>                Insert/replace a tiddler from JSON", file=sys.stderr)
        print("  replace <content>            Insert/replace from cat format", file=sys.stderr)
        print("  serve [--host HOST] [--port PORT]  Serve wiki locally (default: localhost:8080)", file=sys.stderr)
        sys.exit(1)

    command = sys.argv[1]
    wiki_path = get_wiki_path()

    if command == "ls":
        list_tiddlers(wiki_path)
    elif command == "cat":
        if len(sys.argv) < 3:
            print("Error: cat command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[2]
        cat_tiddler(wiki_path, tiddler_title)
    elif command == "json":
        if len(sys.argv) < 3:
            print("Error: json command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[2]
        json_tiddler(wiki_path, tiddler_title)
    elif command == "get":
        if len(sys.argv) < 4:
            print("Error: get command requires a tiddler name and field name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[2]
        field_name = sys.argv[3]
        get_tiddler_field(wiki_path, tiddler_title, field_name)
    elif command == "set":
        if len(sys.argv) < 5:
            print("Error: set command requires a tiddler name, field name, and value", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[2]
        field_name = sys.argv[3]
        field_value = sys.argv[4]
        set_tiddler_field(wiki_path, tiddler_title, field_name, field_value)
    elif command == "rm":
        if len(sys.argv) < 3:
            print("Error: rm command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[2]
        remove_tiddler(wiki_path, tiddler_title)
    elif command == "touch":
        if len(sys.argv) < 3:
            print("Error: touch command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[2]
        text = sys.argv[3] if len(sys.argv) > 3 else ""
        touch_tiddler(wiki_path, tiddler_title, text)
    elif command == "insert":
        if len(sys.argv) < 3:
            print("Error: insert command requires a JSON string", file=sys.stderr)
            sys.exit(1)
        tiddler_json = sys.argv[2]
        insert_tiddler(wiki_path, tiddler_json)
    elif command == "replace":
        # Accept content from either command line argument or stdin
        if len(sys.argv) >= 3:
            content = sys.argv[2]
        else:
            # Read from stdin
            content = sys.stdin.read()
            if not content:
                print("Error: replace command requires content string or stdin input", file=sys.stderr)
                sys.exit(1)
        replace_tiddler(wiki_path, content)
    elif command == "serve":
        # Parse optional --host and --port arguments
        host = 'localhost'
        port = 8080

        i = 2
        while i < len(sys.argv):
            if sys.argv[i] == '--host' and i + 1 < len(sys.argv):
                host = sys.argv[i + 1]
                i += 2
            elif sys.argv[i] == '--port' and i + 1 < len(sys.argv):
                try:
                    port = int(sys.argv[i + 1])
                except ValueError:
                    print(f"Error: Invalid port number '{sys.argv[i + 1]}'", file=sys.stderr)
                    sys.exit(1)
                i += 2
            else:
                print(f"Error: Unknown argument '{sys.argv[i]}'", file=sys.stderr)
                print("Usage: tw serve [--host HOST] [--port PORT]", file=sys.stderr)
                sys.exit(1)

        serve_wiki(wiki_path, host, port)
    else:
        print(f"Error: Unknown command '{command}'", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
