#!/usr/bin/env python3

import os
import sys
import subprocess
import tempfile
import urllib.request
import urllib.error
from collections import OrderedDict

# Global cache to store original field orders for tiddlers
# Key: (wiki_path, tiddler_title) -> List of field names in original order
_original_field_orders = {}

# Mapping of TiddlyWiki MIME types to Neovim filetypes
MIME_TO_VIM_FILETYPE = {
    # TiddlyWiki formats
    'text/vnd.tiddlywiki': 'markdown',
    'text/x-tiddlywiki': 'markdown',
    'text/vnd.tiddlywiki-multiple': 'markdown',

    # Markup formats
    'text/markdown': 'markdown',
    'text/html': 'html',
    'text/plain': 'text',

    # Stylesheet
    'text/css': 'css',

    # Programming languages
    'application/javascript': 'javascript',
    'application/json': 'json',
    'application/x-tiddler-dictionary': 'text',
    'text/x-python': 'python',
    'text/x-shellscript': 'sh',
    'text/xml': 'xml',
    'application/xml': 'xml',
    'text/x-yaml': 'yaml',
    'text/x-sql': 'sql',
}

def record_field_order(wiki_path, tiddler_title, field_order):
    """Record the original field order for a tiddler"""
    key = (wiki_path, tiddler_title)
    _original_field_orders[key] = field_order

def get_field_order(wiki_path, tiddler_title):
    """Get the original field order for a tiddler, or None if not recorded"""
    key = (wiki_path, tiddler_title)
    return _original_field_orders.get(key)

def reorder_tiddler_fields(tiddler, wiki_path, tiddler_title):
    """Reorder tiddler fields to match original order if available.

    If original order is known, reorder fields to match.
    New fields (not in original) are appended at the end.
    """
    original_order = get_field_order(wiki_path, tiddler_title)

    if not original_order:
        # No original order recorded, return as-is
        return tiddler

    # Create new dict with fields in original order
    reordered = OrderedDict()

    # Add fields in original order
    for field in original_order:
        if field in tiddler:
            reordered[field] = tiddler[field]

    # Add any new fields that weren't in original order
    for field, value in tiddler.items():
        if field not in reordered:
            reordered[field] = value

    return reordered

def get_wiki_path(wiki_path=None):
    """Get the wiki path from argument or environment variable.

    Args:
        wiki_path: Optional wiki path. If not provided, uses TIDDLYWIKI_WIKI_PATH env var.

    Returns:
        Absolute path to the wiki file.
    """
    if not wiki_path:
        wiki_path = os.environ.get('TIDDLYWIKI_WIKI_PATH')

    if not wiki_path:
        print("Error: Wiki path not provided and TIDDLYWIKI_WIKI_PATH environment variable is not set", file=sys.stderr)
        sys.exit(1)

    # Expand ~ to home directory
    wiki_path = os.path.expanduser(wiki_path)

    if not os.path.exists(wiki_path):
        print(f"Error: Wiki path does not exist: {wiki_path}", file=sys.stderr)
        sys.exit(1)

    return wiki_path

def extract_tiddler_stores(content):
    """Extract tiddler store JSON arrays from HTML content."""
    import json

    stores = []
    # Find the start of each tiddler store
    pattern = r'<script class="tiddlywiki-tiddler-store" type="application/json">'

    pos = 0
    while True:
        start_match = content.find(pattern, pos)
        if start_match == -1:
            break

        # Find the start of the JSON array
        json_start = content.find('[', start_match)
        if json_start == -1:
            break

        # Find the matching closing tag
        end_tag = '</script>'
        end_match = content.find(end_tag, json_start)
        if end_match == -1:
            break

        # Extract the JSON (trim whitespace)
        json_str = content[json_start:end_match].strip()

        try:
            # Use strict=False to allow control characters like tabs/newlines in strings
            tiddlers = json.loads(json_str, strict=False)
            stores.append({
                'start': start_match,
                'end': end_match + len(end_tag),
                'tiddlers': tiddlers
            })
        except json.JSONDecodeError as e:
            print(f"Warning: Failed to parse tiddler store: {e}", file=sys.stderr)

        pos = end_match + len(end_tag)

    return stores

def load_all_tiddlers(wiki_path):
    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    stores = extract_tiddler_stores(content)

    if not stores:
        print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
        sys.exit(1)

    # Collect all tiddlers from all stores and record their field order
    all_tiddlers = []
    for store in stores:
        all_tiddlers.extend(store['tiddlers'])
        # Record the field order for each tiddler as it appears in the file
        for tiddler in store['tiddlers']:
            if 'title' in tiddler:
                field_order = list(tiddler.keys())
                record_field_order(wiki_path, tiddler['title'], field_order)

    if not all_tiddlers:
        print("Error: Could not find any tiddlers in wiki", file=sys.stderr)
        sys.exit(1)

    return all_tiddlers

def list_tiddlers(wiki_path):
    all_tiddlers = load_all_tiddlers(wiki_path)

    # Collect all titles and sort alphabetically
    titles = [tiddler['title'] for tiddler in all_tiddlers if 'title' in tiddler]
    titles.sort()

    # Print all tiddler titles
    for title in titles:
        print(title)

def cat_tiddler(wiki_path, tiddler_title):
    all_tiddlers = load_all_tiddlers(wiki_path)

    # Find the tiddler with matching title
    tiddler = None
    for t in all_tiddlers:
        if t.get('title') == tiddler_title:
            tiddler = t
            break

    if not tiddler:
        print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
        sys.exit(1)

    # Print title first
    if 'title' in tiddler:
        print(f"title: {tiddler['title']}")

    # Print all other fields except 'text' and 'title'
    for key, value in sorted(tiddler.items()):
        if key not in ('text', 'title'):
            print(f"{key}: {value}")

    # Print the text content after a newline
    if 'text' in tiddler:
        print()
        print(tiddler['text'])

def edit_tiddler(wiki_path, tiddler_title):
    """Open a tiddler in $EDITOR for editing in YAML-style format"""
    import threading
    import time

    # Check if EDITOR environment variable is set
    editor = os.environ.get('EDITOR')
    if not editor:
        # Fall back to common editors if EDITOR is not set
        for fallback_editor in ['nvim', 'vim', 'nano', 'emacs', 'vi']:
            import shutil
            if shutil.which(fallback_editor):
                editor = fallback_editor
                break

    if not editor:
        print("Error: $EDITOR environment variable is not set and no fallback editor found", file=sys.stderr)
        sys.exit(1)

    all_tiddlers = load_all_tiddlers(wiki_path)

    # Find the tiddler with matching title
    tiddler = None
    is_new_tiddler = False
    for t in all_tiddlers:
        if t.get('title') == tiddler_title:
            tiddler = t
            break

    # If tiddler doesn't exist, create a template
    if not tiddler:
        tiddler = {
            "title": tiddler_title,
            "created": get_tiddlywiki_timestamp(),
            "modified": get_tiddlywiki_timestamp()
        }
        is_new_tiddler = True

    # Store the original tiddler's meaningful content (excluding timestamps) for comparison
    def get_editable_fields(t):
        """Get tiddler fields excluding created/modified timestamps"""
        result = {}
        for key, value in t.items():
            if key not in ('created', 'modified'):
                result[key] = value
        return result

    original_editable = get_editable_fields(tiddler)

    # Create a temporary file to edit
    temp_fd, temp_path = tempfile.mkstemp(suffix='.txt', text=True)

    try:
        # Write tiddler in cat format to temp file
        # NOTE: We exclude 'created' and 'modified' so that replace_tiddler
        # can detect whether content changed and update the timestamp appropriately
        with os.fdopen(temp_fd, 'w', encoding='utf-8') as f:
            # Write title first
            if 'title' in tiddler:
                f.write(f"title: {tiddler['title']}\n")

            # Write all other fields except 'text', 'title', 'created', and 'modified'
            for key, value in sorted(tiddler.items()):
                if key not in ('text', 'title', 'created', 'modified'):
                    f.write(f"{key}: {value}\n")

            # Write the text content after a blank line
            if 'text' in tiddler:
                f.write('\n')
                f.write(tiddler['text'])

        # Start background watcher for live updates
        stop_watching = threading.Event()
        last_mtime = [os.path.getmtime(temp_path)]
        # Initialize with current content to avoid treating initial write-back as a change
        with open(temp_path, 'r', encoding='utf-8') as f:
            initial_content = f.read()
        last_content = [initial_content]

        def watch_and_update():
            """Background thread that watches for file changes and updates the tiddler"""
            import io
            import contextlib

            while not stop_watching.is_set():
                time.sleep(0.5)  # Poll every 0.5 seconds
                try:
                    current_mtime = os.path.getmtime(temp_path)
                    if current_mtime != last_mtime[0]:
                        last_mtime[0] = current_mtime

                        # Read the updated content
                        with open(temp_path, 'r', encoding='utf-8') as f:
                            updated_content = f.read()

                        # Check if content actually changed (not just mtime)
                        if updated_content == last_content[0]:
                            # Content is identical, skip update
                            continue

                        last_content[0] = updated_content

                        # Add timestamps and update the wiki
                        updated_content_lines = updated_content.split('\n')
                        # Find where to insert timestamps (before the empty line or text)
                        insert_pos = 0
                        for i, line in enumerate(updated_content_lines):
                            if line.strip() == '':
                                insert_pos = i
                                break

                        # Reconstruct content with timestamps
                        new_lines = updated_content_lines[:insert_pos]
                        # Always add created timestamp
                        new_lines.insert(insert_pos, f"created: {tiddler['created']}")
                        # replace_tiddler will update modified timestamp automatically
                        new_lines.extend(updated_content_lines[insert_pos:])
                        content_with_timestamps = '\n'.join(new_lines)

                        # Update the tiddler in the wiki (suppress output)
                        with contextlib.redirect_stdout(io.StringIO()):
                            replace_tiddler(wiki_path, content_with_timestamps, update_modified=True)
                except (FileNotFoundError, OSError):
                    # File was deleted or other OS error, stop watching
                    break

        watcher = threading.Thread(target=watch_and_update, daemon=True)
        watcher.start()

        # Open the file in the editor
        # Split the editor command in case it has arguments (e.g., "emacs -nw")
        editor_parts = editor.split()

        # Get the tiddler type and map to vim filetype
        tiddler_type = tiddler.get('type', 'text/vnd.tiddlywiki')
        vim_filetype = MIME_TO_VIM_FILETYPE.get(tiddler_type, 'text')

        # If using nvim/vim, add filetype command
        editor_base = editor_parts[0].lower() if editor_parts else ''
        if 'vim' in editor_base or 'nvim' in editor_base:
            # Add vim command to set filetype
            editor_parts = editor_parts + ['-c', f'set filetype={vim_filetype}']

        result = subprocess.run(editor_parts + [temp_path], check=False)

        # Stop the watcher
        stop_watching.set()
        watcher.join(timeout=2)

        if result.returncode != 0:
            print(f"Error: Editor exited with status {result.returncode}", file=sys.stderr)
            sys.exit(1)

        # Read the final edited content
        with open(temp_path, 'r', encoding='utf-8') as f:
            edited_content = f.read()

        # Parse the edited content to check what actually changed
        edited_lines = edited_content.split('\n')
        edited_tiddler = {}
        text_start_index = None

        for i, line in enumerate(edited_lines):
            if line.strip() == '':
                text_start_index = i + 1
                break
            elif ':' in line:
                key, value = line.split(':', 1)
                edited_tiddler[key.strip()] = value.strip()
            else:
                text_start_index = i
                break

        if text_start_index is not None and text_start_index < len(edited_lines):
            text_content = '\n'.join(edited_lines[text_start_index:])
            if text_content:
                text_stripped = text_content.rstrip('\n')
                if text_stripped:
                    edited_tiddler['text'] = text_stripped

        # Compare the editable fields
        edited_editable = get_editable_fields(edited_tiddler)
        content_changed = (edited_editable != original_editable)

        # Check if tiddler is missing timestamps
        missing_timestamps = 'created' not in tiddler or 'modified' not in tiddler

        # Save if: content changed, new tiddler, or missing timestamps
        if is_new_tiddler or content_changed or missing_timestamps:
            # For new tiddlers, always update modified. For existing tiddlers, only update if changed.
            should_update_modified = is_new_tiddler or content_changed

            # Ensure timestamps exist for both new and existing tiddlers
            if 'created' not in tiddler:
                tiddler['created'] = get_tiddlywiki_timestamp()
            if 'modified' not in tiddler:
                tiddler['modified'] = get_tiddlywiki_timestamp()

            # Add timestamps to edited_content before saving
            edited_content_lines = edited_content.split('\n')
            # Find where to insert timestamps (before the empty line or text)
            insert_pos = 0
            for i, line in enumerate(edited_content_lines):
                if line.strip() == '':
                    insert_pos = i
                    break

            # Reconstruct content with timestamps
            new_lines = edited_content_lines[:insert_pos]
            # Always add created timestamp
            new_lines.insert(insert_pos, f"created: {tiddler['created']}")
            # Only add modified if content didn't change (otherwise replace_tiddler will update it)
            if not content_changed:
                new_lines.insert(insert_pos + 1, f"modified: {tiddler['modified']}")
            new_lines.extend(edited_content_lines[insert_pos:])
            edited_content = '\n'.join(new_lines)

            # Use replace_tiddler to save the changes (final save when editor closes)
            replace_tiddler(wiki_path, edited_content, update_modified=should_update_modified)

    finally:
        # Clean up the temporary file
        try:
            os.unlink(temp_path)
        except OSError:
            pass

def get_tiddlywiki_timestamp():
    """Generate a TiddlyWiki timestamp in format YYYYMMDDhhmmssxxx (UTC)"""
    from datetime import datetime, timezone

    now = datetime.now(timezone.utc)
    # Format: YYYYMMDDhhmmssxxx where xxx is milliseconds
    timestamp = now.strftime('%Y%m%d%H%M%S') + f'{now.microsecond // 1000:03d}'
    return timestamp

def ensure_timestamps(tiddler, is_modification=True):
    """Ensure a tiddler has created and modified timestamps.

    Args:
        tiddler: The tiddler dict to update
        is_modification: If True, update modified timestamp. If False, only ensure created exists.

    Returns:
        The timestamp used (for consistency across the tiddler)
    """
    timestamp = get_tiddlywiki_timestamp()

    # Always ensure created exists
    if 'created' not in tiddler:
        tiddler['created'] = timestamp

    # Update modified if this is a modification
    if is_modification:
        tiddler['modified'] = timestamp

    return timestamp

def get_tiddler_field(wiki_path, tiddler_title, field_name):
    """Get the value of a specific field from a tiddler"""
    all_tiddlers = load_all_tiddlers(wiki_path)

    # Find the tiddler with matching title
    tiddler = None
    for t in all_tiddlers:
        if t.get('title') == tiddler_title:
            tiddler = t
            break

    if not tiddler:
        print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
        sys.exit(1)

    if field_name not in tiddler:
        print(f"Error: Field '{field_name}' not found in tiddler '{tiddler_title}'", file=sys.stderr)
        sys.exit(1)

    # Print the field value
    print(tiddler[field_name])

def json_tiddler(wiki_path, *tiddler_titles):
    """Output tiddler(s) as JSON.

    If one tiddler is specified, outputs a JSON object.
    If multiple tiddlers are specified, outputs a JSON array.
    """
    import json

    if not tiddler_titles:
        print("Error: At least one tiddler title is required", file=sys.stderr)
        sys.exit(1)

    all_tiddlers = load_all_tiddlers(wiki_path)

    # Find all requested tiddlers
    found_tiddlers = []
    for title in tiddler_titles:
        tiddler = None
        for t in all_tiddlers:
            if t.get('title') == title:
                tiddler = t
                break

        if not tiddler:
            print(f"Error: Tiddler '{title}' not found", file=sys.stderr)
            sys.exit(1)

        found_tiddlers.append(tiddler)

    # Output format depends on number of tiddlers
    if len(found_tiddlers) == 1:
        # Single tiddler - output as object (backward compatible)
        print(json.dumps(found_tiddlers[0], indent=2, ensure_ascii=False))
    else:
        # Multiple tiddlers - output as array
        print(json.dumps(found_tiddlers, indent=2, ensure_ascii=False))

def set_tiddler_field(wiki_path, tiddler_title, field_name, field_value):
    """Set the value of a specific field in a tiddler"""
    import json

    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    stores = extract_tiddler_stores(content)

    if not stores:
        print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
        sys.exit(1)

    # Find the tiddler
    found_tiddler = None
    for store in stores:
        for tiddler in store['tiddlers']:
            if tiddler.get('title') == tiddler_title:
                found_tiddler = tiddler
                break
        if found_tiddler:
            break

    is_new_tiddler = False
    if not found_tiddler:
        # Create new tiddler if it doesn't exist
        found_tiddler = {
            "title": tiddler_title
        }
        is_new_tiddler = True
        # Add to the first store
        stores[0]['tiddlers'].append(found_tiddler)
        print(f"Created tiddler: {tiddler_title}")

    # Check if the field value actually changed
    old_value = found_tiddler.get(field_name)
    field_changed = (old_value != field_value)

    # Set the field value
    found_tiddler[field_name] = field_value

    # Update timestamps if:
    # 1. This is a new tiddler, OR
    # 2. The field changed AND we're not setting timestamps directly
    if is_new_tiddler or (field_changed and field_name not in ('modified', 'created')):
        ensure_timestamps(found_tiddler, is_modification=True)
    elif not is_new_tiddler:
        # For existing tiddlers, ensure created exists even if nothing changed
        ensure_timestamps(found_tiddler, is_modification=False)

    # Build replacements for all stores
    replacements = []
    for store in stores:
        # Sort tiddlers alphabetically by title
        sorted_tiddlers = sorted(store['tiddlers'], key=lambda t: t.get('title', ''))
        # Rebuild the script tag
        tiddler_jsons = [json.dumps(reorder_tiddler_fields(t, wiki_path, t.get('title', '')), ensure_ascii=False, separators=(',', ':')) for t in sorted_tiddlers]
        new_json = '[\n' + ',\n'.join(tiddler_jsons) + '\n]'
        new_json = new_json.replace('<', '\\u003C')
        new_store = f'<script class="tiddlywiki-tiddler-store" type="application/json">{new_json}</script>'
        replacements.append((store['start'], store['end'], new_store))

    # Apply replacements in reverse order
    new_content = content
    for start, end, replacement in reversed(replacements):
        new_content = new_content[:start] + replacement + new_content[end:]

    # Write back
    with open(wiki_path, 'w', encoding='utf-8') as f:
        f.write(new_content)

    print(f"Set {field_name} = {field_value}")

def touch_tiddler(wiki_path, tiddler_title, text=""):
    """Create a new tiddler or update an existing one"""
    import json

    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    stores = extract_tiddler_stores(content)

    if not stores:
        print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
        sys.exit(1)

    # Check if tiddler already exists
    existing_tiddler = None
    for store in stores:
        for tiddler in store['tiddlers']:
            if tiddler.get('title') == tiddler_title:
                existing_tiddler = tiddler
                break
        if existing_tiddler:
            break

    if existing_tiddler:
        # Update existing tiddler's modified timestamp and ensure created exists
        ensure_timestamps(existing_tiddler, is_modification=True)
        if text:
            existing_tiddler['text'] = text
        print(f"Updated tiddler: {tiddler_title}")
    else:
        # Create new tiddler
        new_tiddler = {
            "title": tiddler_title,
            "text": text
        }
        ensure_timestamps(new_tiddler, is_modification=True)

        # Add to the first store
        stores[0]['tiddlers'].append(new_tiddler)
        print(f"Created tiddler: {tiddler_title}")

    # Build replacements for all stores
    replacements = []
    for store in stores:
        # Sort tiddlers alphabetically by title
        sorted_tiddlers = sorted(store['tiddlers'], key=lambda t: t.get('title', ''))
        # Rebuild the script tag
        tiddler_jsons = [json.dumps(reorder_tiddler_fields(t, wiki_path, t.get('title', '')), ensure_ascii=False, separators=(',', ':')) for t in sorted_tiddlers]
        new_json = '[\n' + ',\n'.join(tiddler_jsons) + '\n]'
        new_json = new_json.replace('<', '\\u003C')
        new_store = f'<script class="tiddlywiki-tiddler-store" type="application/json">{new_json}</script>'
        replacements.append((store['start'], store['end'], new_store))

    # Apply replacements in reverse order
    new_content = content
    for start, end, replacement in reversed(replacements):
        new_content = new_content[:start] + replacement + new_content[end:]

    # Write back
    with open(wiki_path, 'w', encoding='utf-8') as f:
        f.write(new_content)

def remove_tiddler(wiki_path, tiddler_title):
    import json

    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    stores = extract_tiddler_stores(content)

    if not stores:
        print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
        sys.exit(1)

    found = False

    # Build list of replacements
    replacements = []
    for store in stores:
        original_count = len(store['tiddlers'])
        # Filter out the tiddler with matching title
        filtered_tiddlers = [t for t in store['tiddlers'] if t.get('title') != tiddler_title]

        if len(filtered_tiddlers) < original_count:
            found = True

        # Sort tiddlers alphabetically by title
        sorted_tiddlers = sorted(filtered_tiddlers, key=lambda t: t.get('title', ''))

        # Rebuild the script tag with filtered tiddlers
        # Use ensure_ascii=False to preserve Unicode characters like curly quotes
        # Format each tiddler on its own line
        tiddler_jsons = [json.dumps(reorder_tiddler_fields(t, wiki_path, t.get('title', '')), ensure_ascii=False, separators=(',', ':')) for t in sorted_tiddlers]
        new_json = '[\n' + ',\n'.join(tiddler_jsons) + '\n]'

        # Escape only < (not >) as Unicode to match TiddlyWiki format
        new_json = new_json.replace('<', '\\u003C')

        new_store = f'<script class="tiddlywiki-tiddler-store" type="application/json">{new_json}</script>'

        replacements.append((store['start'], store['end'], new_store))

    # Apply replacements in reverse order to maintain correct positions
    new_content = content
    for start, end, replacement in reversed(replacements):
        new_content = new_content[:start] + replacement + new_content[end:]

    if not found:
        print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
        sys.exit(1)

    # Write the modified content back to the file
    with open(wiki_path, 'w', encoding='utf-8') as f:
        f.write(new_content)

    print(f"Removed tiddler: {tiddler_title}")

def replace_tiddler(wiki_path, markdown_content, update_modified=True):
    """Replace a tiddler from cat-style format (YAML frontmatter + text)

    This is the inverse of cat_tiddler - it parses the same format that
    cat outputs and inserts it back into the wiki.

    Args:
        wiki_path: Path to the wiki file
        markdown_content: Content in cat format (YAML frontmatter + text)
        update_modified: If True, update the modified timestamp. If False, preserve existing timestamp.
    """
    import json

    # Parse YAML frontmatter and text
    lines = markdown_content.split('\n')

    # Check if content is empty
    if not lines:
        print("Error: Empty content provided", file=sys.stderr)
        sys.exit(1)

    # Parse YAML-style frontmatter (key: value format)
    # Until we hit an empty line, then everything else is text
    tiddler = {}
    text_start_index = None
    user_provided_modified = False

    for i, line in enumerate(lines):
        if line.strip() == '':
            # Empty line marks end of frontmatter
            text_start_index = i + 1
            break
        elif ':' in line:
            # Parse field: value
            key, value = line.split(':', 1)
            key_stripped = key.strip()
            if key_stripped == 'modified':
                user_provided_modified = True
            tiddler[key_stripped] = value.strip()
        else:
            # If we encounter a line without ':', treat as start of text
            text_start_index = i
            break

    # Everything after the empty line (or non-field line) is the text
    if text_start_index is not None and text_start_index < len(lines):
        text_content = '\n'.join(lines[text_start_index:])
        # Strip trailing newline for perfect roundtrip with cat
        if text_content:
            # Only strip if it's just whitespace, otherwise keep the content
            text_stripped = text_content.rstrip('\n')
            if text_stripped:  # Only add text field if there's content
                tiddler['text'] = text_stripped

    # Verify it has a title field
    if 'title' not in tiddler:
        print("Error: Tiddler must have a 'title' field", file=sys.stderr)
        sys.exit(1)

    # Ensure created timestamp exists
    if 'created' not in tiddler:
        tiddler['created'] = get_tiddlywiki_timestamp()

    # Handle modified timestamp
    if 'modified' not in tiddler:
        # No modified field provided - add one
        tiddler['modified'] = get_tiddlywiki_timestamp()
    elif update_modified and not user_provided_modified:
        # Update modified timestamp only if:
        # 1. update_modified=True (requested), AND
        # 2. The user didn't explicitly provide the modified field in the input
        tiddler['modified'] = get_tiddlywiki_timestamp()

    # Use insert_tiddler to do the actual insertion
    tiddler_json = json.dumps(tiddler)
    insert_tiddler(wiki_path, tiddler_json)

def append_tiddler(wiki_path, tiddler_title, text_to_append=None):
    """Append text to a tiddler's text field

    Args:
        wiki_path: Path to the wiki file
        tiddler_title: Title of the tiddler to append to
        text_to_append: Text to append (if None, read from stdin)
    """
    import json

    # Read from stdin if no text provided
    if text_to_append is None:
        text_to_append = sys.stdin.read()

    all_tiddlers = load_all_tiddlers(wiki_path)

    # Find the tiddler with matching title
    tiddler = None
    for t in all_tiddlers:
        if t.get('title') == tiddler_title:
            tiddler = t
            break

    if not tiddler:
        print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
        sys.exit(1)

    # Append to existing text
    existing_text = tiddler.get('text', '')
    if existing_text:
        # Add newline between existing and new content if both have content
        tiddler['text'] = existing_text + '\n' + text_to_append
    else:
        tiddler['text'] = text_to_append

    # Update modified timestamp and ensure created exists
    ensure_timestamps(tiddler, is_modification=True)

    # Use insert_tiddler to save (it handles the full update)
    tiddler_json = json.dumps(tiddler)
    insert_tiddler(wiki_path, tiddler_json)

def insert_tiddler(wiki_path, tiddler_json):
    """Insert tiddler(s) from JSON, replacing if they already exist.

    Accepts either a single tiddler as a JSON object or multiple tiddlers as a JSON array.
    """
    import json

    # Parse the input JSON
    try:
        parsed_json = json.loads(tiddler_json)
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON: {e}", file=sys.stderr)
        sys.exit(1)

    # Determine if we have a single tiddler (dict) or multiple tiddlers (list)
    if isinstance(parsed_json, dict):
        # Single tiddler - use existing logic
        tiddlers_to_insert = [parsed_json]
    elif isinstance(parsed_json, list):
        # Multiple tiddlers
        tiddlers_to_insert = parsed_json
    else:
        print("Error: JSON must be either an object (single tiddler) or an array (multiple tiddlers)", file=sys.stderr)
        sys.exit(1)

    # Validate all tiddlers before inserting any
    for i, tiddler in enumerate(tiddlers_to_insert):
        if not isinstance(tiddler, dict):
            print(f"Error: Array element {i} is not a valid tiddler object", file=sys.stderr)
            sys.exit(1)
        if 'title' not in tiddler:
            print(f"Error: Array element {i} is missing required 'title' field", file=sys.stderr)
            sys.exit(1)

    # Load the wiki once
    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    stores = extract_tiddler_stores(content)

    if not stores:
        print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
        sys.exit(1)

    # Track which tiddlers were replaced vs inserted
    replaced_titles = []
    inserted_titles = []

    # Process each tiddler
    for new_tiddler in tiddlers_to_insert:
        # Ensure timestamps exist - always ensure created, and add modified only if missing
        # This preserves user-provided timestamps in the JSON
        if 'created' not in new_tiddler:
            new_tiddler['created'] = get_tiddlywiki_timestamp()
        if 'modified' not in new_tiddler:
            new_tiddler['modified'] = get_tiddlywiki_timestamp()

        tiddler_title = new_tiddler['title']

        # Check if tiddler already exists and remove it from all stores
        found = False
        for store in stores:
            original_count = len(store['tiddlers'])
            store['tiddlers'] = [t for t in store['tiddlers'] if t.get('title') != tiddler_title]
            if len(store['tiddlers']) < original_count:
                found = True

        # Add the new tiddler to the first store
        stores[0]['tiddlers'].append(new_tiddler)

        # Track what happened
        if found:
            replaced_titles.append(tiddler_title)
        else:
            inserted_titles.append(tiddler_title)

    # Build replacements for all stores
    replacements = []
    for store in stores:
        # Sort tiddlers alphabetically by title
        sorted_tiddlers = sorted(store['tiddlers'], key=lambda t: t.get('title', ''))
        # Rebuild the script tag
        tiddler_jsons = [json.dumps(reorder_tiddler_fields(t, wiki_path, t.get('title', '')), ensure_ascii=False, separators=(',', ':')) for t in sorted_tiddlers]
        new_json = '[\n' + ',\n'.join(tiddler_jsons) + '\n]'
        new_json = new_json.replace('<', '\\u003C')
        new_store = f'<script class="tiddlywiki-tiddler-store" type="application/json">{new_json}</script>'
        replacements.append((store['start'], store['end'], new_store))

    # Apply replacements in reverse order
    new_content = content
    for start, end, replacement in reversed(replacements):
        new_content = new_content[:start] + replacement + new_content[end:]

    # Write back
    with open(wiki_path, 'w', encoding='utf-8') as f:
        f.write(new_content)

    # Print summary
    for title in replaced_titles:
        print(f"Replaced tiddler: {title}")
    for title in inserted_titles:
        print(f"Inserted tiddler: {title}")

def install_live_reload_plugin(wiki_path):
    """Install the live reload plugin into the wiki"""
    import json

    # The live reload plugin code
    plugin_code = """(function(){
  "use strict";

  exports.name = "live-reload";
  exports.platforms = ["browser"];
  exports.after = ["startup"];
  exports.synchronous = true;

  exports.startup = function() {
    // Only run in browser
    if($tw.browser) {
      checkForServer();
    }
  };

  function checkForServer() {
    var meta = document.querySelector('meta[name="tw-server"]');
    if (!meta || meta.getAttribute('content') !== 'enabled') {
      console.log('[LiveReload] Not running on tw server, aborting');
      return;
    }

    console.log('[LiveReload] Detected tw server, starting live reload');
    startPolling();
    enableWebDAVSaver();
  }

  function enableWebDAVSaver() {
    // Check if server supports WebDAV via OPTIONS request
    fetch('/', {method: 'OPTIONS'})
      .then(function(response) {
        var davHeader = response.headers.get('DAV');
        if (davHeader) {
          console.log('[LiveReload] WebDAV detected (DAV: ' + davHeader + '), enabling saver');

          // TiddlyWiki's WebDAV saver is already built-in and will auto-detect WebDAV support
          // We only need to set AutoSave config if it doesn't already exist or is different
          var existingTiddler = $tw.wiki.getTiddler('$:/config/AutoSave');
          var shouldUpdate = !existingTiddler || existingTiddler.fields.text !== 'yes';

          if (shouldUpdate) {
            $tw.wiki.addTiddler(new $tw.Tiddler({
              title: '$:/config/AutoSave',
              text: 'yes'
            }));
            console.log('[LiveReload] WebDAV saver enabled - you can now save changes!');
          } else {
            console.log('[LiveReload] WebDAV saver already enabled');
          }
        } else {
          console.log('[LiveReload] WebDAV not available on server');
        }
      })
      .catch(function(error) {
        console.log('[LiveReload] Could not check for WebDAV support:', error);
      });
  }

  var lastVersion = null;
  var savedVersions = {}; // Track versions we saved: {version: timestamp}
  var VERSION_SKIP_DURATION = 10000; // Skip reloading versions we saved for 10 seconds
  var isReloading = false; // Flag to prevent marking as dirty during reload
  var isSaving = false; // Flag to track when a save is in progress

  // Hook into TiddlyWiki's save mechanism to track when we initiate a save
  if ($tw.wiki) {
    var originalAddTiddler = $tw.wiki.addTiddler;
    $tw.wiki.addTiddler = function(tiddler) {
      var result = originalAddTiddler.apply(this, arguments);
      // If this is a user-initiated change (not from our plugin reload), mark as saving
      // Ignore: reloads and temporary tiddlers
      if (!isReloading &&
          tiddler &&
          tiddler.fields &&
          tiddler.fields.title &&
          !tiddler.fields.title.startsWith('$:/temp')) {

        // Debounce: only mark as saving if we're not already saving
        if (!isSaving) {
          isSaving = true;
          console.log('[LiveReload] User change detected:', tiddler.fields.title);

          // Clear the saving flag after a short delay to capture the version after save
          setTimeout(function() {
            if (isSaving) {
              // Fetch current version and mark it as saved by us
              fetch('/_tw/version')
                .then(function(response) { return response.json(); })
                .then(function(data) {
                  savedVersions[data.version] = Date.now();
                  console.log('[LiveReload] Marked version as saved:', data.version);
                  isSaving = false;
                })
                .catch(function(error) {
                  console.error('[LiveReload] Error fetching version after save:', error);
                  isSaving = false;
                });
            }
          }, 1000); // Wait 1 second for the save to complete
        }
      }
      return result;
    };
  }

  function startPolling() {
    setInterval(function() {
      checkVersion();
      cleanupOldSavedVersions();
    }, 3000); // Poll every 3 seconds
  }

  function cleanupOldSavedVersions() {
    // Remove saved versions older than VERSION_SKIP_DURATION
    var now = Date.now();
    for (var version in savedVersions) {
      if (now - savedVersions[version] > VERSION_SKIP_DURATION) {
        delete savedVersions[version];
      }
    }
  }

  function checkVersion() {
    fetch('/_tw/version')
      .then(function(response) { return response.json(); })
      .then(function(data) {
        console.log('[LiveReload] Version check:', data.version);

        if (lastVersion === null) {
          // First check, just store the version
          lastVersion = data.version;
          console.log('[LiveReload] Initial version:', lastVersion);
          return;
        }

        if (data.version !== lastVersion) {
          // Check if this version was saved by us
          if (savedVersions[data.version]) {
            var timeSinceSave = Date.now() - savedVersions[data.version];
            console.log('[LiveReload] File changed to version we just saved (' + timeSinceSave + 'ms ago), skipping reload');
            lastVersion = data.version;
            return;
          }

          console.log('[LiveReload] File changed! Old:', lastVersion, 'New:', data.version);
          lastVersion = data.version;
          reloadTiddlers();
        }
      })
      .catch(function(error) {
        console.error('[LiveReload] Error checking version:', error);
      });
  }

  function reloadTiddlers() {
    fetch('/_tw/tiddlers')
      .then(function(response) { return response.json(); })
      .then(function(data) {
        console.log('[LiveReload] Got', data.tiddlers.length, 'tiddlers from server');

        // Set flag to prevent marking wiki as dirty during reload
        isReloading = true;

        // Get current tiddler titles (all tiddlers from the store)
        var currentTitles = $tw.wiki.getTiddlers();

        var newTitles = data.tiddlers.map(function(t) { return t.title; });

        var updateCount = 0;
        var deleteCount = 0;
        var changedTiddlers = {};

        // Update/add tiddlers
        data.tiddlers.forEach(function(tiddlerData) {
          var browserTiddler = $tw.wiki.getTiddler(tiddlerData.title);

          if (!browserTiddler) {
            // New tiddler - not in browser
            console.log('[LiveReload] Adding new tiddler:', tiddlerData.title);
            $tw.wiki.addTiddler(new $tw.Tiddler(tiddlerData));
            changedTiddlers[tiddlerData.title] = true;
            updateCount++;
          } else {
            // Compare canonical serialized representations instead of field-by-field
            // This handles all data types uniformly without special cases

            // Fields to ignore when comparing (metadata/computed fields)
            var ignoreFields = {
              'modified': true,
              'created': true,
              'revision': true,
              'bag': true
            };

            // Create normalized copies without ignored fields
            var serverNormalized = {};
            var browserNormalized = {};

            // Copy server fields (except ignored)
            for (var field in tiddlerData) {
              if (!ignoreFields[field]) {
                serverNormalized[field] = tiddlerData[field];
              }
            }

            // Copy browser fields (except ignored)
            // Convert arrays to TiddlyWiki string format to match server
            for (var field in browserTiddler.fields) {
              if (!ignoreFields[field]) {
                var value = browserTiddler.fields[field];
                // TiddlyWiki represents tags/lists as arrays in browser but strings in files
                // Use TiddlyWiki's stringifyList to convert arrays to proper format
                if (Array.isArray(value) && $tw.utils.stringifyList) {
                  browserNormalized[field] = $tw.utils.stringifyList(value);
                } else {
                  browserNormalized[field] = value;
                }
              }
            }

            // Serialize both to JSON with sorted keys for consistent comparison
            var serverJson = JSON.stringify(serverNormalized, Object.keys(serverNormalized).sort());
            var browserJson = JSON.stringify(browserNormalized, Object.keys(browserNormalized).sort());

            if (serverJson !== browserJson) {
              console.log('[DEBUG] ' + tiddlerData.title + ' content changed');
              console.log('  Server JSON: ' + serverJson.substring(0, 200));
              console.log('  Browser JSON: ' + browserJson.substring(0, 200));

              $tw.wiki.addTiddler(new $tw.Tiddler(tiddlerData));
              changedTiddlers[tiddlerData.title] = true;
              updateCount++;
            }
          }
        });

        // Delete removed tiddlers
        currentTitles.forEach(function(title) {
          if (newTitles.indexOf(title) === -1) {
            console.log('[LiveReload] Deleting tiddler:', title);
            $tw.wiki.deleteTiddler(title);
            changedTiddlers[title] = true;
            deleteCount++;
          }
        });

        // Refresh the UI if any changes were made
        if (updateCount > 0 || deleteCount > 0) {
          // Trigger a refresh of the root widget
          $tw.rootWidget.refresh(changedTiddlers);
          console.log('[LiveReload] Reload complete - updated:', updateCount, 'deleted:', deleteCount);

          // Mark the wiki as saved at current change count
          // This prevents the wiki from showing as "dirty" after a reload from server
          if ($tw.wiki.getChangeCount && $tw.syncer && $tw.syncer.wiki) {
            $tw.syncer.wiki.addTiddler(new $tw.Tiddler(
              $tw.wiki.getTiddler('$:/config/SaverStartupTime'),
              {text: '' + $tw.wiki.getChangeCount()}
            ));
            console.log('[LiveReload] Updated save marker to change count:', $tw.wiki.getChangeCount());
          }
        } else {
          console.log('[LiveReload] No changes detected');
        }

        // Clear the reloading flag after a delay to let TiddlyWiki's reactive updates settle
        setTimeout(function() {
          isReloading = false;
          console.log('[LiveReload] Reload flag cleared');
        }, 500);
      })
      .catch(function(error) {
        console.error('[LiveReload] Error reloading tiddlers:', error);
        // Clear flag even on error, with delay for consistency
        setTimeout(function() {
          isReloading = false;
        }, 500);
      });
  }
})();
"""

    # Create the plugin tiddler
    plugin_tiddler = {
        "title": "$:/plugins/phajas/live-reload",
        "type": "application/javascript",
        "module-type": "startup",
        "text": plugin_code,
        "tags": "$:/tags/StartupModule",
        "description": "Live reload functionality with WebDAV save support for tw server",
        "version": "0.8.1"
    }

    # Convert to JSON and insert
    plugin_json = json.dumps(plugin_tiddler)
    insert_tiddler(wiki_path, plugin_json)

    print("Live reload plugin installed successfully")
    print("Start the server with: tw serve")

def init_wiki(dest_path):
    """Download an empty TiddlyWiki and save it to the specified path"""
    # Expand ~ to home directory
    dest_path = os.path.expanduser(dest_path)

    # Check if file already exists
    if os.path.exists(dest_path):
        print(f"Error: File already exists: {dest_path}", file=sys.stderr)
        sys.exit(1)

    # Check if parent directory exists
    parent_dir = os.path.dirname(dest_path)
    if parent_dir and not os.path.exists(parent_dir):
        print(f"Error: Parent directory does not exist: {parent_dir}", file=sys.stderr)
        sys.exit(1)

    try:
        print(f"Downloading empty wiki from tiddlywiki.com...")
        # Download the empty wiki
        url = 'https://tiddlywiki.com/empty.html'
        with urllib.request.urlopen(url, timeout=10) as response:
            wiki_content = response.read().decode('utf-8')
    except urllib.error.URLError as e:
        print(f"Error: Failed to download wiki: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

    # Verify the downloaded content has tiddler stores
    stores = extract_tiddler_stores(wiki_content)
    if not stores:
        print("Error: Downloaded wiki does not contain tiddler stores", file=sys.stderr)
        sys.exit(1)

    # Write to file atomically (temp file + rename)
    temp_path = dest_path + '.tmp'
    try:
        with open(temp_path, 'w', encoding='utf-8') as f:
            f.write(wiki_content)
        os.replace(temp_path, dest_path)
    except Exception as e:
        # Clean up temp file if it exists
        if os.path.exists(temp_path):
            try:
                os.remove(temp_path)
            except:
                pass
        print(f"Error: Failed to write wiki file: {e}", file=sys.stderr)
        sys.exit(1)

    print(f"Created wiki: {dest_path}")

def serve_wiki(wiki_path, host='localhost', port=8080, readonly=False):
    """Serve the TiddlyWiki file locally using Python's built-in HTTP server

    Args:
        wiki_path: Path to the wiki HTML file
        host: Host to bind to (default: localhost)
        port: Port to bind to (default: 8080)
        readonly: If True, disable saving via PUT requests (default: False)
    """
    from http.server import HTTPServer, BaseHTTPRequestHandler
    import threading
    import time
    import json
    import mimetypes

    class WikiWatcher:
        """Watch the wiki file for changes and track version"""
        def __init__(self, wiki_path):
            self.wiki_path = wiki_path
            self.current_mtime = os.path.getmtime(wiki_path)
            self.lock = threading.Lock()

        def watch(self):
            """Background thread that polls for file changes"""
            while True:
                time.sleep(0.5)
                try:
                    mtime = os.path.getmtime(self.wiki_path)
                    if mtime != self.current_mtime:
                        with self.lock:
                            self.current_mtime = mtime
                        print(f"[File changed] {self.wiki_path} (mtime: {mtime})")
                except OSError as e:
                    print(f"[Warning] Could not check file: {e}")

        def get_version(self):
            """Get the current file modification time"""
            with self.lock:
                return self.current_mtime

    # Initialize the file watcher
    watcher = WikiWatcher(wiki_path)
    watcher_thread = threading.Thread(target=watcher.watch, daemon=True)
    watcher_thread.start()

    class WikiHandler(BaseHTTPRequestHandler):
        def send_webdav_headers(self):
            """Send WebDAV-specific headers"""
            self.send_header('DAV', '1,2')
            self.send_header('Allow', 'OPTIONS, GET, HEAD, PUT')
            self.send_header('Access-Control-Allow-Origin', '*')
            self.send_header('Access-Control-Allow-Methods', 'OPTIONS, GET, HEAD, PUT')
            self.send_header('Access-Control-Allow-Headers', 'Content-Type, X-Requested-With')

        def do_OPTIONS(self):
            """Handle OPTIONS requests for WebDAV discovery"""
            self.send_response(200)
            self.send_webdav_headers()
            self.send_header('Content-Length', '0')
            self.end_headers()

        def do_PUT(self):
            """Handle PUT requests to save the wiki file"""
            # Reject all save attempts in readonly mode
            if readonly:
                self.send_error(403, 'Server is in readonly mode')
                print(f"[WebDAV PUT] Rejected save attempt (readonly mode)", file=sys.stderr)
                return

            try:
                # Read the incoming HTML from request body
                content_length = int(self.headers.get('Content-Length', 0))
                if content_length == 0:
                    self.send_error(400, 'Empty request body')
                    return

                wiki_html = self.rfile.read(content_length)

                # Decode to string for validation
                try:
                    wiki_html_str = wiki_html.decode('utf-8')
                except UnicodeDecodeError as e:
                    self.send_error(400, f'Invalid UTF-8 encoding: {e}')
                    return

                # Validate that the HTML has tiddler stores
                stores = extract_tiddler_stores(wiki_html_str)
                if not stores:
                    self.send_error(400, 'Invalid wiki HTML: no tiddler stores found')
                    print(f"[WebDAV PUT] Rejected invalid HTML (no tiddler stores)", file=sys.stderr)
                    return

                # Write to temp file first (atomic operation)
                temp_path = wiki_path + '.tmp'
                with open(temp_path, 'wb') as f:
                    f.write(wiki_html)

                # Atomic replace
                os.replace(temp_path, wiki_path)

                print(f"[WebDAV PUT] Saved wiki file ({len(wiki_html)} bytes)")

                # Return success (204 No Content is standard for WebDAV PUT)
                self.send_response(204)
                self.send_webdav_headers()
                self.end_headers()

            except Exception as e:
                print(f"[WebDAV PUT] Error saving file: {e}", file=sys.stderr)
                self.send_error(500, f'Error saving file: {e}')

        def do_HEAD(self):
            """Handle HEAD requests - same as GET but without body"""
            # Just use do_GET, but the BaseHTTPRequestHandler will automatically
            # not send the body for HEAD requests
            self.do_GET()

        def do_GET(self):
            """Handle GET requests by serving the wiki file or API endpoints"""
            # API endpoint: version check
            if self.path == '/_tw/version':
                self.send_version_response()
                return

            # API endpoint: tiddlers JSON
            if self.path == '/_tw/tiddlers':
                self.send_tiddlers_response()
                return

            # Root path: serve the wiki HTML
            if self.path == '/' or self.path == '':
                self.send_wiki_html()
                return

            # For any other path, try to serve as a file (for _canonical_uri support)
            self.send_file()

        def send_version_response(self):
            """Send current file version/mtime"""
            try:
                version = watcher.get_version()
                response_data = {
                    "version": version,
                    "mtime": version,
                    "server": "tw-python"
                }

                response_json = json.dumps(response_data).encode('utf-8')

                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.send_header('Content-Length', str(len(response_json)))
                self.end_headers()
                self.wfile.write(response_json)
            except Exception as e:
                self.send_error(500, f'Error getting version: {e}')

        def send_tiddlers_response(self):
            """Send the tiddler store JSON"""
            try:
                # Load all tiddlers from the wiki
                all_tiddlers = load_all_tiddlers(wiki_path)
                version = watcher.get_version()

                response_data = {
                    "version": version,
                    "tiddlers": all_tiddlers
                }

                response_json = json.dumps(response_data, ensure_ascii=False).encode('utf-8')

                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.send_header('Content-Length', str(len(response_json)))
                self.end_headers()
                self.wfile.write(response_json)
            except Exception as e:
                self.send_error(500, f'Error getting tiddlers: {e}')

        def send_wiki_html(self):
            """Serve the wiki HTML with injected meta tag"""
            try:
                with open(wiki_path, 'r', encoding='utf-8') as f:
                    content = f.read()

                # Inject meta tag after <head> or at the beginning if no head tag
                meta_tag = '<meta name="tw-server" content="enabled">'

                # Look for <head> tag (case insensitive)
                head_pos = content.lower().find('<head>')
                if head_pos != -1:
                    # Find the end of the <head> tag
                    insert_pos = content.find('>', head_pos) + 1
                    content = content[:insert_pos] + '\n' + meta_tag + content[insert_pos:]
                else:
                    # No head tag, insert at the beginning
                    content = meta_tag + '\n' + content

                content_bytes = content.encode('utf-8')

                self.send_response(200)
                self.send_header('Content-Type', 'text/html; charset=utf-8')
                self.send_header('Content-Length', str(len(content_bytes)))
                self.end_headers()
                self.wfile.write(content_bytes)
            except (ConnectionResetError, BrokenPipeError) as e:
                # Client closed connection - this is normal, just log it
                print(f"[Client disconnected] {e.__class__.__name__}")
            except Exception as e:
                try:
                    self.send_error(500, f'Error reading wiki file: {e}')
                except (ConnectionResetError, BrokenPipeError):
                    # Can't send error if connection is already broken
                    print(f"[Client disconnected during error handling]")

        def send_file(self):
            """Serve a file from the filesystem (for _canonical_uri support)"""
            try:
                # Parse the request path, removing query parameters and fragments
                from urllib.parse import urlparse, unquote
                parsed_path = urlparse(self.path)
                # Decode URL encoding (e.g., %20 -> space)
                file_path = unquote(parsed_path.path)

                # Remove leading slash
                if file_path.startswith('/'):
                    file_path = file_path[1:]

                # Prevent directory traversal attacks
                if '..' in file_path or file_path.startswith('/'):
                    self.send_error(403, 'Access denied')
                    return

                # Resolve path relative to wiki file's directory
                wiki_dir = os.path.dirname(os.path.abspath(wiki_path))
                full_path = os.path.join(wiki_dir, file_path)

                # Normalize the path to resolve any .. or . components
                full_path = os.path.normpath(full_path)

                # Ensure the resolved path is still within wiki_dir
                if not full_path.startswith(wiki_dir):
                    self.send_error(403, 'Access denied')
                    return

                # Check if file exists and is a file (not a directory)
                if not os.path.isfile(full_path):
                    self.send_error(404, 'File not found')
                    return

                # Determine MIME type
                mime_type, _ = mimetypes.guess_type(full_path)
                if mime_type is None:
                    mime_type = 'application/octet-stream'

                # Read and serve the file
                with open(full_path, 'rb') as f:
                    content = f.read()

                self.send_response(200)
                self.send_header('Content-Type', mime_type)
                self.send_header('Content-Length', str(len(content)))
                # Add CORS headers to allow cross-origin requests
                self.send_header('Access-Control-Allow-Origin', '*')
                self.end_headers()
                self.wfile.write(content)

                print(f"[File served] {file_path} ({mime_type}, {len(content)} bytes)")

            except (ConnectionResetError, BrokenPipeError) as e:
                # Client closed connection - this is normal
                print(f"[Client disconnected] {e.__class__.__name__}")
            except Exception as e:
                print(f"[Error serving file] {e}", file=sys.stderr)
                try:
                    self.send_error(500, f'Error serving file: {e}')
                except (ConnectionResetError, BrokenPipeError):
                    print(f"[Client disconnected during error handling]")

        def log_message(self, format, *args):
            """Override to provide cleaner log messages"""
            print(f"[{self.log_date_time_string()}] {format % args}")

    try:
        server = HTTPServer((host, port), WikiHandler)
        if readonly:
            print(f"Serving TiddlyWiki at http://{host}:{port} (READONLY MODE)")
        else:
            print(f"Serving TiddlyWiki at http://{host}:{port}")
        print(f"Wiki file: {wiki_path}")
        if readonly:
            print("Mode: READONLY - save attempts will be rejected")
        print("Press Ctrl+C to stop the server")
        server.serve_forever()
    except KeyboardInterrupt:
        print("\nServer stopped")
        sys.exit(0)
    except OSError as e:
        if e.errno == 48 or e.errno == 98:  # Address already in use
            print(f"Error: Port {port} is already in use", file=sys.stderr)
        else:
            print(f"Error starting server: {e}", file=sys.stderr)
        sys.exit(1)

def main():
    if len(sys.argv) < 2:
        print("Usage: tw [<wiki_path>] <command> [args]", file=sys.stderr)
        print("", file=sys.stderr)
        print("Commands:", file=sys.stderr)
        print("", file=sys.stderr)
        print("  init <dest_path>", file=sys.stderr)
        print("    Create a new empty wiki", file=sys.stderr)
        print("    Example: tw init ~/my-wiki.html", file=sys.stderr)
        print("", file=sys.stderr)
        print("  ls", file=sys.stderr)
        print("    List all tiddlers", file=sys.stderr)
        print("    Example: tw ls", file=sys.stderr)
        print("             tw ~/my-wiki.html ls", file=sys.stderr)
        print("", file=sys.stderr)
        print("  cat <tiddler>", file=sys.stderr)
        print("    Display tiddler contents", file=sys.stderr)
        print("    Example: tw cat \"My Tiddler\"", file=sys.stderr)
        print("             tw ~/my-wiki.html cat Index", file=sys.stderr)
        print("", file=sys.stderr)
        print("  edit <tiddler>", file=sys.stderr)
        print("    Edit tiddler in $EDITOR", file=sys.stderr)
        print("    Example: tw edit \"My Tiddler\"", file=sys.stderr)
        print("             EDITOR=vim tw edit Index", file=sys.stderr)
        print("", file=sys.stderr)
        print("  json <tiddler> [<tiddler2> ...]", file=sys.stderr)
        print("    Output tiddler(s) as JSON", file=sys.stderr)
        print("    Single tiddler returns object, multiple return array", file=sys.stderr)
        print("    Example: tw json \"My Tiddler\"", file=sys.stderr)
        print("             tw json Index | jq .text", file=sys.stderr)
        print("             tw json Tiddler1 Tiddler2 Tiddler3", file=sys.stderr)
        print("", file=sys.stderr)
        print("  get <tiddler> <field>", file=sys.stderr)
        print("    Get a specific field value", file=sys.stderr)
        print("    Example: tw get \"My Tiddler\" text", file=sys.stderr)
        print("             tw get \"My Tiddler\" created", file=sys.stderr)
        print("", file=sys.stderr)
        print("  set <tiddler> <field> <value>", file=sys.stderr)
        print("    Set a field value", file=sys.stderr)
        print("    Example: tw set \"My Tiddler\" text \"New content\"", file=sys.stderr)
        print("             tw set \"My Tiddler\" tags \"tag1 tag2\"", file=sys.stderr)
        print("", file=sys.stderr)
        print("  rm <tiddler>", file=sys.stderr)
        print("    Remove a tiddler", file=sys.stderr)
        print("    Example: tw rm \"My Tiddler\"", file=sys.stderr)
        print("             tw rm \"Temporary Note\"", file=sys.stderr)
        print("", file=sys.stderr)
        print("  touch <tiddler> [text]", file=sys.stderr)
        print("    Create or update a tiddler", file=sys.stderr)
        print("    Example: tw touch \"New Tiddler\"", file=sys.stderr)
        print("             tw touch \"My Note\" \"Initial content\"", file=sys.stderr)
        print("", file=sys.stderr)
        print("  insert <json>", file=sys.stderr)
        print("    Insert/replace tiddler(s) from JSON", file=sys.stderr)
        print("    Accepts single object or array of objects", file=sys.stderr)
        print("    Example: tw insert '{\"title\":\"MyTiddler\",\"text\":\"content\"}'", file=sys.stderr)
        print("             tw json Source | tw insert", file=sys.stderr)
        print("             tw insert '[{\"title\":\"T1\",\"text\":\"a\"},{\"title\":\"T2\",\"text\":\"b\"}]'", file=sys.stderr)
        print("             tw json Tiddler1 Tiddler2 | tw insert  # roundtrip multiple tiddlers", file=sys.stderr)
        print("", file=sys.stderr)
        print("  replace <content>", file=sys.stderr)
        print("    Insert/replace from cat format", file=sys.stderr)
        print("    Example: tw replace \"title: MyTitle\\ntext: content\"", file=sys.stderr)
        print("             tw cat MyTiddler | tw replace", file=sys.stderr)
        print("", file=sys.stderr)
        print("  append <tiddler> [text]", file=sys.stderr)
        print("    Append text to tiddler (from args or stdin)", file=sys.stderr)
        print("    Example: tw append \"My Tiddler\" \"More content\"", file=sys.stderr)
        print("             tw append MyLog some text here", file=sys.stderr)
        print("             echo \"More content\" | tw append \"My Tiddler\"", file=sys.stderr)
        print("", file=sys.stderr)
        print("  install_plugin", file=sys.stderr)
        print("    Install live reload plugin", file=sys.stderr)
        print("    Example: tw install_plugin", file=sys.stderr)
        print("", file=sys.stderr)
        print("  serve [--host HOST] [--port PORT] [--readonly]", file=sys.stderr)
        print("    Serve wiki locally (default: localhost:8080)", file=sys.stderr)
        print("    --readonly: Disable saving (read-only mode)", file=sys.stderr)
        print("    Example: tw serve", file=sys.stderr)
        print("             tw serve --port 3000", file=sys.stderr)
        print("             tw serve --host 0.0.0.0 --port 8000", file=sys.stderr)
        print("             tw serve --readonly", file=sys.stderr)
        sys.exit(1)

    # Parse arguments: check if first arg is a wiki path or a command
    arg_idx = 1
    wiki_path_arg = None

    # If first arg looks like a file path (ends with .html or exists as a file), treat it as wiki path
    if len(sys.argv) > 2 and (sys.argv[1].endswith('.html') or os.path.exists(sys.argv[1])):
        wiki_path_arg = sys.argv[1]
        arg_idx = 2

    command = sys.argv[arg_idx] if arg_idx < len(sys.argv) else None

    if not command:
        print("Error: No command provided", file=sys.stderr)
        sys.exit(1)

    # Handle 'init' command separately since it doesn't need a wiki path parameter
    if command == "init":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: init command requires a destination path", file=sys.stderr)
            sys.exit(1)
        # init doesn't use wiki_path_arg - it creates a new wiki
        dest_path = sys.argv[arg_idx + 1]
        init_wiki(dest_path)
        return

    wiki_path = get_wiki_path(wiki_path_arg)

    if command == "ls":
        list_tiddlers(wiki_path)
    elif command == "cat":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: cat command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        cat_tiddler(wiki_path, tiddler_title)
    elif command == "edit":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: edit command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        edit_tiddler(wiki_path, tiddler_title)
    elif command == "json":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: json command requires at least one tiddler name", file=sys.stderr)
            sys.exit(1)
        # Collect all remaining arguments as tiddler titles
        tiddler_titles = sys.argv[arg_idx + 1:]
        json_tiddler(wiki_path, *tiddler_titles)
    elif command == "get":
        if arg_idx + 2 >= len(sys.argv):
            print("Error: get command requires a tiddler name and field name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        field_name = sys.argv[arg_idx + 2]
        get_tiddler_field(wiki_path, tiddler_title, field_name)
    elif command == "set":
        if arg_idx + 3 >= len(sys.argv):
            print("Error: set command requires a tiddler name, field name, and value", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        field_name = sys.argv[arg_idx + 2]
        field_value = sys.argv[arg_idx + 3]
        set_tiddler_field(wiki_path, tiddler_title, field_name, field_value)
    elif command == "rm":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: rm command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        remove_tiddler(wiki_path, tiddler_title)
    elif command == "touch":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: touch command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        text = sys.argv[arg_idx + 2] if arg_idx + 2 < len(sys.argv) else ""
        touch_tiddler(wiki_path, tiddler_title, text)
    elif command == "insert":
        # Accept JSON from either command line argument or stdin
        if arg_idx + 1 < len(sys.argv):
            tiddler_json = sys.argv[arg_idx + 1]
        else:
            # Read from stdin
            tiddler_json = sys.stdin.read()
            if not tiddler_json:
                print("Error: insert command requires JSON string or stdin input", file=sys.stderr)
                sys.exit(1)
        insert_tiddler(wiki_path, tiddler_json)
    elif command == "replace":
        # Accept content from either command line argument or stdin
        if arg_idx + 1 < len(sys.argv):
            content = sys.argv[arg_idx + 1]
        else:
            # Read from stdin
            content = sys.stdin.read()
            if not content:
                print("Error: replace command requires content string or stdin input", file=sys.stderr)
                sys.exit(1)
        replace_tiddler(wiki_path, content)
    elif command == "append":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: append command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        # Check if there are additional arguments for text to append
        if arg_idx + 2 < len(sys.argv):
            # Join all remaining arguments as the text
            text_to_append = ' '.join(sys.argv[arg_idx + 2:])
            append_tiddler(wiki_path, tiddler_title, text_to_append)
        else:
            # No text argument, will read from stdin
            append_tiddler(wiki_path, tiddler_title)
    elif command == "install_plugin":
        install_live_reload_plugin(wiki_path)
    elif command == "serve":
        # Parse optional --host, --port, and --readonly arguments
        host = 'localhost'
        port = 8080
        readonly = False

        i = arg_idx + 1
        while i < len(sys.argv):
            if sys.argv[i] == '--host' and i + 1 < len(sys.argv):
                host = sys.argv[i + 1]
                i += 2
            elif sys.argv[i] == '--port' and i + 1 < len(sys.argv):
                try:
                    port = int(sys.argv[i + 1])
                except ValueError:
                    print(f"Error: Invalid port number '{sys.argv[i + 1]}'", file=sys.stderr)
                    sys.exit(1)
                i += 2
            elif sys.argv[i] == '--readonly':
                readonly = True
                i += 1
            else:
                print(f"Error: Unknown argument '{sys.argv[i]}'", file=sys.stderr)
                print("Usage: tw [<wiki_path>] serve [--host HOST] [--port PORT] [--readonly]", file=sys.stderr)
                sys.exit(1)

        serve_wiki(wiki_path, host, port, readonly)
    else:
        print(f"Error: Unknown command '{command}'", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
