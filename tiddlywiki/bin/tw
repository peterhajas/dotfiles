#!/usr/bin/env python3

import os
import re
import sys
import subprocess
import tempfile
import urllib.request
import urllib.error

def get_wiki_path(wiki_path=None):
    """Get the wiki path from argument or environment variable.

    Args:
        wiki_path: Optional wiki path. If not provided, uses TIDDLYWIKI_WIKI_PATH env var.

    Returns:
        Absolute path to the wiki file.
    """
    if not wiki_path:
        wiki_path = os.environ.get('TIDDLYWIKI_WIKI_PATH')

    if not wiki_path:
        print("Error: Wiki path not provided and TIDDLYWIKI_WIKI_PATH environment variable is not set", file=sys.stderr)
        sys.exit(1)

    # Expand ~ to home directory
    wiki_path = os.path.expanduser(wiki_path)

    if not os.path.exists(wiki_path):
        print(f"Error: Wiki path does not exist: {wiki_path}", file=sys.stderr)
        sys.exit(1)

    return wiki_path

def extract_tiddler_stores(content):
    """Extract tiddler store JSON arrays from HTML content."""
    import json

    stores = []
    # Find the start of each tiddler store
    pattern = r'<script class="tiddlywiki-tiddler-store" type="application/json">'

    pos = 0
    while True:
        start_match = content.find(pattern, pos)
        if start_match == -1:
            break

        # Find the start of the JSON array
        json_start = content.find('[', start_match)
        if json_start == -1:
            break

        # Find the matching closing tag
        end_tag = '</script>'
        end_match = content.find(end_tag, json_start)
        if end_match == -1:
            break

        # Extract the JSON (trim whitespace)
        json_str = content[json_start:end_match].strip()

        try:
            # Use strict=False to allow control characters like tabs/newlines in strings
            tiddlers = json.loads(json_str, strict=False)
            stores.append({
                'start': start_match,
                'end': end_match + len(end_tag),
                'tiddlers': tiddlers
            })
        except json.JSONDecodeError as e:
            print(f"Warning: Failed to parse tiddler store: {e}", file=sys.stderr)

        pos = end_match + len(end_tag)

    return stores

def load_all_tiddlers(wiki_path):
    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    stores = extract_tiddler_stores(content)

    if not stores:
        print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
        sys.exit(1)

    # Collect all tiddlers from all stores
    all_tiddlers = []
    for store in stores:
        all_tiddlers.extend(store['tiddlers'])

    if not all_tiddlers:
        print("Error: Could not find any tiddlers in wiki", file=sys.stderr)
        sys.exit(1)

    return all_tiddlers

def list_tiddlers(wiki_path):
    all_tiddlers = load_all_tiddlers(wiki_path)

    # Collect all titles and sort alphabetically
    titles = [tiddler['title'] for tiddler in all_tiddlers if 'title' in tiddler]
    titles.sort()

    # Print all tiddler titles
    for title in titles:
        print(title)

def cat_tiddler(wiki_path, tiddler_title):
    all_tiddlers = load_all_tiddlers(wiki_path)

    # Find the tiddler with matching title
    tiddler = None
    for t in all_tiddlers:
        if t.get('title') == tiddler_title:
            tiddler = t
            break

    if not tiddler:
        print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
        sys.exit(1)

    # Print title first
    if 'title' in tiddler:
        print(f"title: {tiddler['title']}")

    # Print all other fields except 'text' and 'title'
    for key, value in sorted(tiddler.items()):
        if key not in ('text', 'title'):
            print(f"{key}: {value}")

    # Print the text content after a newline
    if 'text' in tiddler:
        print()
        print(tiddler['text'])

def edit_tiddler(wiki_path, tiddler_title):
    """Open a tiddler in $EDITOR for editing in YAML-style format"""
    # Check if EDITOR environment variable is set
    editor = os.environ.get('EDITOR')
    if not editor:
        # Fall back to common editors if EDITOR is not set
        for fallback_editor in ['nvim', 'vim', 'nano', 'emacs', 'vi']:
            import shutil
            if shutil.which(fallback_editor):
                editor = fallback_editor
                break

    if not editor:
        print("Error: $EDITOR environment variable is not set and no fallback editor found", file=sys.stderr)
        sys.exit(1)

    all_tiddlers = load_all_tiddlers(wiki_path)

    # Find the tiddler with matching title
    tiddler = None
    for t in all_tiddlers:
        if t.get('title') == tiddler_title:
            tiddler = t
            break

    if not tiddler:
        print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
        sys.exit(1)

    # Create a temporary file to edit
    temp_fd, temp_path = tempfile.mkstemp(suffix='.txt', text=True)

    try:
        # Write tiddler in cat format to temp file
        with os.fdopen(temp_fd, 'w', encoding='utf-8') as f:
            # Write title first
            if 'title' in tiddler:
                f.write(f"title: {tiddler['title']}\n")

            # Write all other fields except 'text' and 'title'
            for key, value in sorted(tiddler.items()):
                if key not in ('text', 'title'):
                    f.write(f"{key}: {value}\n")

            # Write the text content after a blank line
            if 'text' in tiddler:
                f.write('\n')
                f.write(tiddler['text'])

        # Open the file in the editor
        # Split the editor command in case it has arguments (e.g., "emacs -nw")
        editor_parts = editor.split()
        result = subprocess.run(editor_parts + [temp_path], check=False)

        if result.returncode != 0:
            print(f"Error: Editor exited with status {result.returncode}", file=sys.stderr)
            sys.exit(1)

        # Read the edited content
        with open(temp_path, 'r', encoding='utf-8') as f:
            edited_content = f.read()

        # Use replace_tiddler to save the changes
        replace_tiddler(wiki_path, edited_content)

    finally:
        # Clean up the temporary file
        try:
            os.unlink(temp_path)
        except OSError:
            pass

def get_tiddlywiki_timestamp():
    """Generate a TiddlyWiki timestamp in format YYYYMMDDhhmmssxxx (UTC)"""
    from datetime import datetime, timezone

    now = datetime.now(timezone.utc)
    # Format: YYYYMMDDhhmmssxxx where xxx is milliseconds
    timestamp = now.strftime('%Y%m%d%H%M%S') + f'{now.microsecond // 1000:03d}'
    return timestamp

def get_tiddler_field(wiki_path, tiddler_title, field_name):
    """Get the value of a specific field from a tiddler"""
    all_tiddlers = load_all_tiddlers(wiki_path)

    # Find the tiddler with matching title
    tiddler = None
    for t in all_tiddlers:
        if t.get('title') == tiddler_title:
            tiddler = t
            break

    if not tiddler:
        print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
        sys.exit(1)

    if field_name not in tiddler:
        print(f"Error: Field '{field_name}' not found in tiddler '{tiddler_title}'", file=sys.stderr)
        sys.exit(1)

    # Print the field value
    print(tiddler[field_name])

def json_tiddler(wiki_path, tiddler_title):
    """Output a tiddler as JSON"""
    import json

    all_tiddlers = load_all_tiddlers(wiki_path)

    # Find the tiddler with matching title
    tiddler = None
    for t in all_tiddlers:
        if t.get('title') == tiddler_title:
            tiddler = t
            break

    if not tiddler:
        print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
        sys.exit(1)

    # Print as formatted JSON
    print(json.dumps(tiddler, indent=2, ensure_ascii=False))

def set_tiddler_field(wiki_path, tiddler_title, field_name, field_value):
    """Set the value of a specific field in a tiddler"""
    import json

    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    stores = extract_tiddler_stores(content)

    if not stores:
        print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
        sys.exit(1)

    # Find the tiddler
    found_tiddler = None
    target_store = None
    for store in stores:
        for tiddler in store['tiddlers']:
            if tiddler.get('title') == tiddler_title:
                found_tiddler = tiddler
                target_store = store
                break
        if found_tiddler:
            break

    timestamp = get_tiddlywiki_timestamp()

    if not found_tiddler:
        # Create new tiddler if it doesn't exist
        found_tiddler = {
            "title": tiddler_title,
            "created": timestamp,
            "modified": timestamp
        }
        # Add to the first store
        stores[0]['tiddlers'].append(found_tiddler)
        print(f"Created tiddler: {tiddler_title}")

    # Set the field value
    found_tiddler[field_name] = field_value

    # Update modified timestamp if we're not setting it directly
    if field_name != 'modified':
        found_tiddler['modified'] = timestamp

    # Build replacements for all stores
    replacements = []
    for store in stores:
        # Sort tiddlers alphabetically by title
        sorted_tiddlers = sorted(store['tiddlers'], key=lambda t: t.get('title', ''))
        # Rebuild the script tag
        tiddler_jsons = [json.dumps(t, ensure_ascii=False, separators=(',', ':')) for t in sorted_tiddlers]
        new_json = '[\n' + ',\n'.join(tiddler_jsons) + '\n]'
        new_json = new_json.replace('<', '\\u003C')
        new_store = f'<script class="tiddlywiki-tiddler-store" type="application/json">{new_json}</script>'
        replacements.append((store['start'], store['end'], new_store))

    # Apply replacements in reverse order
    new_content = content
    for start, end, replacement in reversed(replacements):
        new_content = new_content[:start] + replacement + new_content[end:]

    # Write back
    with open(wiki_path, 'w', encoding='utf-8') as f:
        f.write(new_content)

    print(f"Set {field_name} = {field_value}")

def touch_tiddler(wiki_path, tiddler_title, text=""):
    """Create a new tiddler or update an existing one"""
    import json

    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    stores = extract_tiddler_stores(content)

    if not stores:
        print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
        sys.exit(1)

    timestamp = get_tiddlywiki_timestamp()

    # Check if tiddler already exists
    existing_tiddler = None
    for store in stores:
        for tiddler in store['tiddlers']:
            if tiddler.get('title') == tiddler_title:
                existing_tiddler = tiddler
                break
        if existing_tiddler:
            break

    if existing_tiddler:
        # Update existing tiddler's modified timestamp
        existing_tiddler['modified'] = timestamp
        if text:
            existing_tiddler['text'] = text
        print(f"Updated tiddler: {tiddler_title}")
    else:
        # Create new tiddler
        new_tiddler = {
            "title": tiddler_title,
            "created": timestamp,
            "modified": timestamp,
            "text": text
        }

        # Add to the first store
        stores[0]['tiddlers'].append(new_tiddler)
        print(f"Created tiddler: {tiddler_title}")

    # Build replacements for all stores
    replacements = []
    for store in stores:
        # Sort tiddlers alphabetically by title
        sorted_tiddlers = sorted(store['tiddlers'], key=lambda t: t.get('title', ''))
        # Rebuild the script tag
        tiddler_jsons = [json.dumps(t, ensure_ascii=False, separators=(',', ':')) for t in sorted_tiddlers]
        new_json = '[\n' + ',\n'.join(tiddler_jsons) + '\n]'
        new_json = new_json.replace('<', '\\u003C')
        new_store = f'<script class="tiddlywiki-tiddler-store" type="application/json">{new_json}</script>'
        replacements.append((store['start'], store['end'], new_store))

    # Apply replacements in reverse order
    new_content = content
    for start, end, replacement in reversed(replacements):
        new_content = new_content[:start] + replacement + new_content[end:]

    # Write back
    with open(wiki_path, 'w', encoding='utf-8') as f:
        f.write(new_content)

def remove_tiddler(wiki_path, tiddler_title):
    import json

    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    stores = extract_tiddler_stores(content)

    if not stores:
        print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
        sys.exit(1)

    found = False

    # Build list of replacements
    replacements = []
    for store in stores:
        original_count = len(store['tiddlers'])
        # Filter out the tiddler with matching title
        filtered_tiddlers = [t for t in store['tiddlers'] if t.get('title') != tiddler_title]

        if len(filtered_tiddlers) < original_count:
            found = True

        # Sort tiddlers alphabetically by title
        sorted_tiddlers = sorted(filtered_tiddlers, key=lambda t: t.get('title', ''))

        # Rebuild the script tag with filtered tiddlers
        # Use ensure_ascii=False to preserve Unicode characters like curly quotes
        # Format each tiddler on its own line
        tiddler_jsons = [json.dumps(t, ensure_ascii=False, separators=(',', ':')) for t in sorted_tiddlers]
        new_json = '[\n' + ',\n'.join(tiddler_jsons) + '\n]'

        # Escape only < (not >) as Unicode to match TiddlyWiki format
        new_json = new_json.replace('<', '\\u003C')

        new_store = f'<script class="tiddlywiki-tiddler-store" type="application/json">{new_json}</script>'

        replacements.append((store['start'], store['end'], new_store))

    # Apply replacements in reverse order to maintain correct positions
    new_content = content
    for start, end, replacement in reversed(replacements):
        new_content = new_content[:start] + replacement + new_content[end:]

    if not found:
        print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
        sys.exit(1)

    # Write the modified content back to the file
    with open(wiki_path, 'w', encoding='utf-8') as f:
        f.write(new_content)

    print(f"Removed tiddler: {tiddler_title}")

def replace_tiddler(wiki_path, markdown_content):
    """Replace a tiddler from cat-style format (YAML frontmatter + text)

    This is the inverse of cat_tiddler - it parses the same format that
    cat outputs and inserts it back into the wiki.
    """
    import json

    # Parse YAML frontmatter and text
    lines = markdown_content.split('\n')

    # Check if content is empty
    if not lines:
        print("Error: Empty content provided", file=sys.stderr)
        sys.exit(1)

    # Parse YAML-style frontmatter (key: value format)
    # Until we hit an empty line, then everything else is text
    tiddler = {}
    text_start_index = None

    for i, line in enumerate(lines):
        if line.strip() == '':
            # Empty line marks end of frontmatter
            text_start_index = i + 1
            break
        elif ':' in line:
            # Parse field: value
            key, value = line.split(':', 1)
            tiddler[key.strip()] = value.strip()
        else:
            # If we encounter a line without ':', treat as start of text
            text_start_index = i
            break

    # Everything after the empty line (or non-field line) is the text
    if text_start_index is not None and text_start_index < len(lines):
        text_content = '\n'.join(lines[text_start_index:])
        # Strip trailing newline for perfect roundtrip with cat
        if text_content:
            # Only strip if it's just whitespace, otherwise keep the content
            text_stripped = text_content.rstrip('\n')
            if text_stripped:  # Only add text field if there's content
                tiddler['text'] = text_stripped

    # Verify it has a title field
    if 'title' not in tiddler:
        print("Error: Tiddler must have a 'title' field", file=sys.stderr)
        sys.exit(1)

    # Add timestamps if missing
    timestamp = get_tiddlywiki_timestamp()

    if 'created' not in tiddler:
        tiddler['created'] = timestamp

    if 'modified' not in tiddler:
        tiddler['modified'] = timestamp

    # Use insert_tiddler to do the actual insertion
    tiddler_json = json.dumps(tiddler)
    insert_tiddler(wiki_path, tiddler_json)

def append_tiddler(wiki_path, tiddler_title):
    """Append text from stdin to a tiddler's text field"""
    import json

    # Read from stdin
    text_to_append = sys.stdin.read()

    all_tiddlers = load_all_tiddlers(wiki_path)

    # Find the tiddler with matching title
    tiddler = None
    for t in all_tiddlers:
        if t.get('title') == tiddler_title:
            tiddler = t
            break

    if not tiddler:
        print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
        sys.exit(1)

    # Append to existing text
    existing_text = tiddler.get('text', '')
    if existing_text:
        # Add newline between existing and new content if both have content
        tiddler['text'] = existing_text + '\n' + text_to_append
    else:
        tiddler['text'] = text_to_append

    # Update modified timestamp
    timestamp = get_tiddlywiki_timestamp()
    tiddler['modified'] = timestamp

    # Use insert_tiddler to save (it handles the full update)
    tiddler_json = json.dumps(tiddler)
    insert_tiddler(wiki_path, tiddler_json)

def insert_tiddler(wiki_path, tiddler_json):
    """Insert a tiddler from JSON, replacing if it already exists"""
    import json

    # Parse the input JSON
    try:
        new_tiddler = json.loads(tiddler_json)
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON: {e}", file=sys.stderr)
        sys.exit(1)

    # Verify it has a title field
    if 'title' not in new_tiddler:
        print("Error: Tiddler JSON must have a 'title' field", file=sys.stderr)
        sys.exit(1)

    # Add timestamps if missing
    timestamp = get_tiddlywiki_timestamp()

    if 'created' not in new_tiddler:
        new_tiddler['created'] = timestamp

    if 'modified' not in new_tiddler:
        new_tiddler['modified'] = timestamp

    tiddler_title = new_tiddler['title']

    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    stores = extract_tiddler_stores(content)

    if not stores:
        print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
        sys.exit(1)

    # Check if tiddler already exists and remove it from all stores
    found = False
    for store in stores:
        original_count = len(store['tiddlers'])
        store['tiddlers'] = [t for t in store['tiddlers'] if t.get('title') != tiddler_title]
        if len(store['tiddlers']) < original_count:
            found = True

    # Add the new tiddler to the first store
    stores[0]['tiddlers'].append(new_tiddler)

    # Build replacements for all stores
    replacements = []
    for store in stores:
        # Sort tiddlers alphabetically by title
        sorted_tiddlers = sorted(store['tiddlers'], key=lambda t: t.get('title', ''))
        # Rebuild the script tag
        tiddler_jsons = [json.dumps(t, ensure_ascii=False, separators=(',', ':')) for t in sorted_tiddlers]
        new_json = '[\n' + ',\n'.join(tiddler_jsons) + '\n]'
        new_json = new_json.replace('<', '\\u003C')
        new_store = f'<script class="tiddlywiki-tiddler-store" type="application/json">{new_json}</script>'
        replacements.append((store['start'], store['end'], new_store))

    # Apply replacements in reverse order
    new_content = content
    for start, end, replacement in reversed(replacements):
        new_content = new_content[:start] + replacement + new_content[end:]

    # Write back
    with open(wiki_path, 'w', encoding='utf-8') as f:
        f.write(new_content)

    if found:
        print(f"Replaced tiddler: {tiddler_title}")
    else:
        print(f"Inserted tiddler: {tiddler_title}")

def install_live_reload_plugin(wiki_path):
    """Install the live reload plugin into the wiki"""
    import json

    # The live reload plugin code
    plugin_code = """(function(){
  "use strict";

  exports.name = "live-reload";
  exports.platforms = ["browser"];
  exports.after = ["startup"];
  exports.synchronous = true;

  exports.startup = function() {
    // Only run in browser
    if($tw.browser) {
      checkForServer();
    }
  };

  function checkForServer() {
    var meta = document.querySelector('meta[name="tw-server"]');
    if (!meta || meta.getAttribute('content') !== 'enabled') {
      console.log('[LiveReload] Not running on tw server, aborting');
      return;
    }

    console.log('[LiveReload] Detected tw server, starting live reload');
    startPolling();
    enableWebDAVSaver();
  }

  function enableWebDAVSaver() {
    // Check if server supports WebDAV via OPTIONS request
    fetch('/', {method: 'OPTIONS'})
      .then(function(response) {
        var davHeader = response.headers.get('DAV');
        if (davHeader) {
          console.log('[LiveReload] WebDAV detected (DAV: ' + davHeader + '), enabling saver');

          // TiddlyWiki's WebDAV saver is already built-in and will auto-detect WebDAV support
          // We only need to set AutoSave config if it doesn't already exist or is different
          var existingTiddler = $tw.wiki.getTiddler('$:/config/AutoSave');
          var shouldUpdate = !existingTiddler || existingTiddler.fields.text !== 'yes';

          if (shouldUpdate) {
            $tw.wiki.addTiddler(new $tw.Tiddler({
              title: '$:/config/AutoSave',
              text: 'yes'
            }));
            console.log('[LiveReload] WebDAV saver enabled - you can now save changes!');
          } else {
            console.log('[LiveReload] WebDAV saver already enabled');
          }
        } else {
          console.log('[LiveReload] WebDAV not available on server');
        }
      })
      .catch(function(error) {
        console.log('[LiveReload] Could not check for WebDAV support:', error);
      });
  }

  var lastVersion = null;
  var lastSaveTime = 0;
  var SAVE_COOLDOWN = 5000; // 5 seconds cooldown after save
  var isReloading = false; // Flag to prevent marking as dirty during reload

  // Hook into TiddlyWiki's save mechanism to track when we initiate a save
  if ($tw.wiki) {
    var originalAddTiddler = $tw.wiki.addTiddler;
    $tw.wiki.addTiddler = function(tiddler) {
      var result = originalAddTiddler.apply(this, arguments);
      // If this is a user-initiated change (not from our plugin reload), update save time
      if (!isReloading && tiddler && tiddler.fields && tiddler.fields.title && !tiddler.fields['draft.of']) {
        lastSaveTime = Date.now();
        console.log('[LiveReload] User change detected, setting cooldown');
      }
      return result;
    };
  }

  function startPolling() {
    setInterval(function() {
      checkVersion();
    }, 3000); // Poll every 3 seconds
  }

  function checkVersion() {
    fetch('/_tw/version')
      .then(function(response) { return response.json(); })
      .then(function(data) {
        console.log('[LiveReload] Version check:', data.version);

        if (lastVersion === null) {
          // First check, just store the version
          lastVersion = data.version;
          console.log('[LiveReload] Initial version:', lastVersion);
          return;
        }

        if (data.version !== lastVersion) {
          var timeSinceLastSave = Date.now() - lastSaveTime;

          // Skip reload if we just saved (within cooldown period)
          if (timeSinceLastSave < SAVE_COOLDOWN) {
            console.log('[LiveReload] File changed but within save cooldown (' + timeSinceLastSave + 'ms), skipping reload');
            lastVersion = data.version;
            return;
          }

          console.log('[LiveReload] File changed! Old:', lastVersion, 'New:', data.version);
          lastVersion = data.version;
          reloadTiddlers();
        }
      })
      .catch(function(error) {
        console.error('[LiveReload] Error checking version:', error);
      });
  }

  function reloadTiddlers() {
    fetch('/_tw/tiddlers')
      .then(function(response) { return response.json(); })
      .then(function(data) {
        console.log('[LiveReload] Got', data.tiddlers.length, 'tiddlers from server');

        // Set flag to prevent marking wiki as dirty during reload
        isReloading = true;

        // Get current tiddler titles (all tiddlers from the store)
        var currentTitles = $tw.wiki.getTiddlers();

        var newTitles = data.tiddlers.map(function(t) { return t.title; });

        var updateCount = 0;
        var deleteCount = 0;
        var changedTiddlers = {};

        // Update/add tiddlers
        data.tiddlers.forEach(function(tiddlerData) {
          var currentTiddler = $tw.wiki.getTiddler(tiddlerData.title);

          // Only update if modified timestamp changed or tiddler is new
          if (!currentTiddler || currentTiddler.fields.modified !== tiddlerData.modified) {
            console.log('[LiveReload] Updating tiddler:', tiddlerData.title);
            $tw.wiki.addTiddler(new $tw.Tiddler(tiddlerData));
            changedTiddlers[tiddlerData.title] = true;
            updateCount++;
          }
        });

        // Delete removed tiddlers
        currentTitles.forEach(function(title) {
          if (newTitles.indexOf(title) === -1) {
            console.log('[LiveReload] Deleting tiddler:', title);
            $tw.wiki.deleteTiddler(title);
            changedTiddlers[title] = true;
            deleteCount++;
          }
        });

        // Refresh the UI if any changes were made
        if (updateCount > 0 || deleteCount > 0) {
          // Trigger a refresh of the root widget
          $tw.rootWidget.refresh(changedTiddlers);
          console.log('[LiveReload] Reload complete - updated:', updateCount, 'deleted:', deleteCount);

          // Mark the wiki as saved at current change count
          // This prevents the wiki from showing as "dirty" after a reload from server
          if ($tw.wiki.getChangeCount && $tw.syncer && $tw.syncer.wiki) {
            $tw.syncer.wiki.addTiddler(new $tw.Tiddler(
              $tw.wiki.getTiddler('$:/config/SaverStartupTime'),
              {text: '' + $tw.wiki.getChangeCount()}
            ));
            console.log('[LiveReload] Updated save marker to change count:', $tw.wiki.getChangeCount());
          }
        } else {
          console.log('[LiveReload] No changes detected');
        }

        // Clear the reloading flag AFTER refresh
        isReloading = false;
      })
      .catch(function(error) {
        console.error('[LiveReload] Error reloading tiddlers:', error);
        isReloading = false; // Clear flag even on error
      });
  }
})();
"""

    # Create the plugin tiddler
    plugin_tiddler = {
        "title": "$:/plugins/phajas/live-reload",
        "type": "application/javascript",
        "module-type": "startup",
        "text": plugin_code,
        "tags": "$:/tags/StartupModule",
        "description": "Live reload functionality with WebDAV save support for tw server",
        "version": "0.3.8"
    }

    # Convert to JSON and insert
    plugin_json = json.dumps(plugin_tiddler)
    insert_tiddler(wiki_path, plugin_json)

    print("Live reload plugin installed successfully")
    print("Start the server with: tw serve")

def init_wiki(dest_path):
    """Download an empty TiddlyWiki and save it to the specified path"""
    # Expand ~ to home directory
    dest_path = os.path.expanduser(dest_path)

    # Check if file already exists
    if os.path.exists(dest_path):
        print(f"Error: File already exists: {dest_path}", file=sys.stderr)
        sys.exit(1)

    # Check if parent directory exists
    parent_dir = os.path.dirname(dest_path)
    if parent_dir and not os.path.exists(parent_dir):
        print(f"Error: Parent directory does not exist: {parent_dir}", file=sys.stderr)
        sys.exit(1)

    try:
        print(f"Downloading empty wiki from tiddlywiki.com...")
        # Download the empty wiki
        url = 'https://tiddlywiki.com/empty.html'
        with urllib.request.urlopen(url, timeout=10) as response:
            wiki_content = response.read().decode('utf-8')
    except urllib.error.URLError as e:
        print(f"Error: Failed to download wiki: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

    # Verify the downloaded content has tiddler stores
    stores = extract_tiddler_stores(wiki_content)
    if not stores:
        print("Error: Downloaded wiki does not contain tiddler stores", file=sys.stderr)
        sys.exit(1)

    # Write to file atomically (temp file + rename)
    temp_path = dest_path + '.tmp'
    try:
        with open(temp_path, 'w', encoding='utf-8') as f:
            f.write(wiki_content)
        os.replace(temp_path, dest_path)
    except Exception as e:
        # Clean up temp file if it exists
        if os.path.exists(temp_path):
            try:
                os.remove(temp_path)
            except:
                pass
        print(f"Error: Failed to write wiki file: {e}", file=sys.stderr)
        sys.exit(1)

    print(f"Created wiki: {dest_path}")

def serve_wiki(wiki_path, host='localhost', port=8080):
    """Serve the TiddlyWiki file locally using Python's built-in HTTP server"""
    from http.server import HTTPServer, BaseHTTPRequestHandler
    import threading
    import time
    import json

    class WikiWatcher:
        """Watch the wiki file for changes and track version"""
        def __init__(self, wiki_path):
            self.wiki_path = wiki_path
            self.current_mtime = os.path.getmtime(wiki_path)
            self.lock = threading.Lock()

        def watch(self):
            """Background thread that polls for file changes"""
            while True:
                time.sleep(0.5)
                try:
                    mtime = os.path.getmtime(self.wiki_path)
                    if mtime != self.current_mtime:
                        with self.lock:
                            self.current_mtime = mtime
                        print(f"[File changed] {self.wiki_path} (mtime: {mtime})")
                except OSError as e:
                    print(f"[Warning] Could not check file: {e}")

        def get_version(self):
            """Get the current file modification time"""
            with self.lock:
                return self.current_mtime

    # Initialize the file watcher
    watcher = WikiWatcher(wiki_path)
    watcher_thread = threading.Thread(target=watcher.watch, daemon=True)
    watcher_thread.start()

    class WikiHandler(BaseHTTPRequestHandler):
        def send_webdav_headers(self):
            """Send WebDAV-specific headers"""
            self.send_header('DAV', '1,2')
            self.send_header('Allow', 'OPTIONS, GET, HEAD, PUT')
            self.send_header('Access-Control-Allow-Origin', '*')
            self.send_header('Access-Control-Allow-Methods', 'OPTIONS, GET, HEAD, PUT')
            self.send_header('Access-Control-Allow-Headers', 'Content-Type, X-Requested-With')

        def do_OPTIONS(self):
            """Handle OPTIONS requests for WebDAV discovery"""
            self.send_response(200)
            self.send_webdav_headers()
            self.send_header('Content-Length', '0')
            self.end_headers()

        def do_PUT(self):
            """Handle PUT requests to save the wiki file"""
            try:
                # Read the incoming HTML from request body
                content_length = int(self.headers.get('Content-Length', 0))
                if content_length == 0:
                    self.send_error(400, 'Empty request body')
                    return

                wiki_html = self.rfile.read(content_length)

                # Decode to string for validation
                try:
                    wiki_html_str = wiki_html.decode('utf-8')
                except UnicodeDecodeError as e:
                    self.send_error(400, f'Invalid UTF-8 encoding: {e}')
                    return

                # Validate that the HTML has tiddler stores
                stores = extract_tiddler_stores(wiki_html_str)
                if not stores:
                    self.send_error(400, 'Invalid wiki HTML: no tiddler stores found')
                    print(f"[WebDAV PUT] Rejected invalid HTML (no tiddler stores)", file=sys.stderr)
                    return

                # Write to temp file first (atomic operation)
                temp_path = wiki_path + '.tmp'
                with open(temp_path, 'wb') as f:
                    f.write(wiki_html)

                # Atomic replace
                os.replace(temp_path, wiki_path)

                print(f"[WebDAV PUT] Saved wiki file ({len(wiki_html)} bytes)")

                # Return success (204 No Content is standard for WebDAV PUT)
                self.send_response(204)
                self.send_webdav_headers()
                self.end_headers()

            except Exception as e:
                print(f"[WebDAV PUT] Error saving file: {e}", file=sys.stderr)
                self.send_error(500, f'Error saving file: {e}')

        def do_HEAD(self):
            """Handle HEAD requests - same as GET but without body"""
            # Just use do_GET, but the BaseHTTPRequestHandler will automatically
            # not send the body for HEAD requests
            self.do_GET()

        def do_GET(self):
            """Handle GET requests by serving the wiki file or API endpoints"""
            # API endpoint: version check
            if self.path == '/_tw/version':
                self.send_version_response()
                return

            # API endpoint: tiddlers JSON
            if self.path == '/_tw/tiddlers':
                self.send_tiddlers_response()
                return

            # Default: serve the wiki HTML
            self.send_wiki_html()

        def send_version_response(self):
            """Send current file version/mtime"""
            try:
                version = watcher.get_version()
                response_data = {
                    "version": version,
                    "mtime": version,
                    "server": "tw-python"
                }

                response_json = json.dumps(response_data).encode('utf-8')

                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.send_header('Content-Length', str(len(response_json)))
                self.end_headers()
                self.wfile.write(response_json)
            except Exception as e:
                self.send_error(500, f'Error getting version: {e}')

        def send_tiddlers_response(self):
            """Send the tiddler store JSON"""
            try:
                # Load all tiddlers from the wiki
                all_tiddlers = load_all_tiddlers(wiki_path)
                version = watcher.get_version()

                response_data = {
                    "version": version,
                    "tiddlers": all_tiddlers
                }

                response_json = json.dumps(response_data, ensure_ascii=False).encode('utf-8')

                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.send_header('Content-Length', str(len(response_json)))
                self.end_headers()
                self.wfile.write(response_json)
            except Exception as e:
                self.send_error(500, f'Error getting tiddlers: {e}')

        def send_wiki_html(self):
            """Serve the wiki HTML with injected meta tag"""
            try:
                with open(wiki_path, 'r', encoding='utf-8') as f:
                    content = f.read()

                # Inject meta tag after <head> or at the beginning if no head tag
                meta_tag = '<meta name="tw-server" content="enabled">'

                # Look for <head> tag (case insensitive)
                head_pos = content.lower().find('<head>')
                if head_pos != -1:
                    # Find the end of the <head> tag
                    insert_pos = content.find('>', head_pos) + 1
                    content = content[:insert_pos] + '\n' + meta_tag + content[insert_pos:]
                else:
                    # No head tag, insert at the beginning
                    content = meta_tag + '\n' + content

                content_bytes = content.encode('utf-8')

                self.send_response(200)
                self.send_header('Content-Type', 'text/html; charset=utf-8')
                self.send_header('Content-Length', str(len(content_bytes)))
                self.end_headers()
                self.wfile.write(content_bytes)
            except Exception as e:
                self.send_error(500, f'Error reading wiki file: {e}')

        def log_message(self, format, *args):
            """Override to provide cleaner log messages"""
            print(f"[{self.log_date_time_string()}] {format % args}")

    try:
        server = HTTPServer((host, port), WikiHandler)
        print(f"Serving TiddlyWiki at http://{host}:{port}")
        print(f"Wiki file: {wiki_path}")
        print("Press Ctrl+C to stop the server")
        server.serve_forever()
    except KeyboardInterrupt:
        print("\nServer stopped")
        sys.exit(0)
    except OSError as e:
        if e.errno == 48 or e.errno == 98:  # Address already in use
            print(f"Error: Port {port} is already in use", file=sys.stderr)
        else:
            print(f"Error starting server: {e}", file=sys.stderr)
        sys.exit(1)

def main():
    if len(sys.argv) < 2:
        print("Usage: tw [<wiki_path>] <command> [args]", file=sys.stderr)
        print("Commands:", file=sys.stderr)
        print("  init <dest_path>             Create a new empty wiki", file=sys.stderr)
        print("  ls                           List all tiddlers", file=sys.stderr)
        print("  cat <tiddler>                Display tiddler contents", file=sys.stderr)
        print("  edit <tiddler>               Edit tiddler in $EDITOR", file=sys.stderr)
        print("  json <tiddler>               Output tiddler as JSON", file=sys.stderr)
        print("  get <tiddler> <field>        Get a specific field value", file=sys.stderr)
        print("  set <tiddler> <field> <value> Set a field value", file=sys.stderr)
        print("  rm <tiddler>                 Remove a tiddler", file=sys.stderr)
        print("  touch <tiddler> [text]       Create or update a tiddler", file=sys.stderr)
        print("  insert <json>                Insert/replace a tiddler from JSON", file=sys.stderr)
        print("  replace <content>            Insert/replace from cat format", file=sys.stderr)
        print("  append <tiddler>             Append stdin text to tiddler", file=sys.stderr)
        print("  install_plugin               Install live reload plugin", file=sys.stderr)
        print("  serve [--host HOST] [--port PORT]  Serve wiki locally (default: localhost:8080)", file=sys.stderr)
        sys.exit(1)

    # Parse arguments: check if first arg is a wiki path or a command
    arg_idx = 1
    wiki_path_arg = None

    # If first arg looks like a file path (ends with .html or exists as a file), treat it as wiki path
    if len(sys.argv) > 2 and (sys.argv[1].endswith('.html') or os.path.exists(sys.argv[1])):
        wiki_path_arg = sys.argv[1]
        arg_idx = 2

    command = sys.argv[arg_idx] if arg_idx < len(sys.argv) else None

    if not command:
        print("Error: No command provided", file=sys.stderr)
        sys.exit(1)

    # Handle 'init' command separately since it doesn't need a wiki path parameter
    if command == "init":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: init command requires a destination path", file=sys.stderr)
            sys.exit(1)
        # init doesn't use wiki_path_arg - it creates a new wiki
        dest_path = sys.argv[arg_idx + 1]
        init_wiki(dest_path)
        return

    wiki_path = get_wiki_path(wiki_path_arg)

    if command == "ls":
        list_tiddlers(wiki_path)
    elif command == "cat":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: cat command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        cat_tiddler(wiki_path, tiddler_title)
    elif command == "edit":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: edit command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        edit_tiddler(wiki_path, tiddler_title)
    elif command == "json":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: json command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        json_tiddler(wiki_path, tiddler_title)
    elif command == "get":
        if arg_idx + 2 >= len(sys.argv):
            print("Error: get command requires a tiddler name and field name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        field_name = sys.argv[arg_idx + 2]
        get_tiddler_field(wiki_path, tiddler_title, field_name)
    elif command == "set":
        if arg_idx + 3 >= len(sys.argv):
            print("Error: set command requires a tiddler name, field name, and value", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        field_name = sys.argv[arg_idx + 2]
        field_value = sys.argv[arg_idx + 3]
        set_tiddler_field(wiki_path, tiddler_title, field_name, field_value)
    elif command == "rm":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: rm command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        remove_tiddler(wiki_path, tiddler_title)
    elif command == "touch":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: touch command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        text = sys.argv[arg_idx + 2] if arg_idx + 2 < len(sys.argv) else ""
        touch_tiddler(wiki_path, tiddler_title, text)
    elif command == "insert":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: insert command requires a JSON string", file=sys.stderr)
            sys.exit(1)
        tiddler_json = sys.argv[arg_idx + 1]
        insert_tiddler(wiki_path, tiddler_json)
    elif command == "replace":
        # Accept content from either command line argument or stdin
        if arg_idx + 1 < len(sys.argv):
            content = sys.argv[arg_idx + 1]
        else:
            # Read from stdin
            content = sys.stdin.read()
            if not content:
                print("Error: replace command requires content string or stdin input", file=sys.stderr)
                sys.exit(1)
        replace_tiddler(wiki_path, content)
    elif command == "append":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: append command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        append_tiddler(wiki_path, tiddler_title)
    elif command == "install_plugin":
        install_live_reload_plugin(wiki_path)
    elif command == "serve":
        # Parse optional --host and --port arguments
        host = 'localhost'
        port = 8080

        i = arg_idx + 1
        while i < len(sys.argv):
            if sys.argv[i] == '--host' and i + 1 < len(sys.argv):
                host = sys.argv[i + 1]
                i += 2
            elif sys.argv[i] == '--port' and i + 1 < len(sys.argv):
                try:
                    port = int(sys.argv[i + 1])
                except ValueError:
                    print(f"Error: Invalid port number '{sys.argv[i + 1]}'", file=sys.stderr)
                    sys.exit(1)
                i += 2
            else:
                print(f"Error: Unknown argument '{sys.argv[i]}'", file=sys.stderr)
                print("Usage: tw [<wiki_path>] serve [--host HOST] [--port PORT]", file=sys.stderr)
                sys.exit(1)

        serve_wiki(wiki_path, host, port)
    else:
        print(f"Error: Unknown command '{command}'", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
