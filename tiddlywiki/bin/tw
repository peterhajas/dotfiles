#!/usr/bin/env python3

import os
import sys
import subprocess
import tempfile
import urllib.request
import urllib.error
from collections import OrderedDict

# Global cache to store original field orders for tiddlers
# Key: (wiki_path, tiddler_title) -> List of field names in original order
_original_field_orders = {}

# Mapping of TiddlyWiki MIME types to Neovim filetypes
MIME_TO_VIM_FILETYPE = {
    # TiddlyWiki formats
    'text/vnd.tiddlywiki': 'markdown',
    'text/x-tiddlywiki': 'markdown',
    'text/vnd.tiddlywiki-multiple': 'markdown',

    # Markup formats
    'text/markdown': 'markdown',
    'text/html': 'html',
    'text/plain': 'text',

    # Stylesheet
    'text/css': 'css',

    # Programming languages
    'application/javascript': 'javascript',
    'application/json': 'json',
    'application/x-tiddler-dictionary': 'text',
    'text/x-python': 'python',
    'text/x-shellscript': 'sh',
    'text/xml': 'xml',
    'application/xml': 'xml',
    'text/x-yaml': 'yaml',
    'text/x-sql': 'sql',
}

def record_field_order(wiki_path, tiddler_title, field_order):
    """Record the original field order for a tiddler"""
    key = (wiki_path, tiddler_title)
    _original_field_orders[key] = field_order

def get_field_order(wiki_path, tiddler_title):
    """Get the original field order for a tiddler, or None if not recorded"""
    key = (wiki_path, tiddler_title)
    return _original_field_orders.get(key)

def reorder_tiddler_fields(tiddler, wiki_path, tiddler_title):
    """Reorder tiddler fields to match original order if available.

    If original order is known, reorder fields to match.
    New fields (not in original) are appended at the end.
    """
    original_order = get_field_order(wiki_path, tiddler_title)

    if not original_order:
        # No original order recorded, return as-is
        return tiddler

    # Create new dict with fields in original order
    reordered = OrderedDict()

    # Add fields in original order
    for field in original_order:
        if field in tiddler:
            reordered[field] = tiddler[field]

    # Add any new fields that weren't in original order
    for field, value in tiddler.items():
        if field not in reordered:
            reordered[field] = value

    return reordered

def get_wiki_path(wiki_path=None):
    """Get the wiki path from argument or environment variable.

    Args:
        wiki_path: Optional wiki path. If not provided, uses TIDDLYWIKI_WIKI_PATH env var.

    Returns:
        Absolute path to the wiki file.
    """
    if not wiki_path:
        wiki_path = os.environ.get('TIDDLYWIKI_WIKI_PATH')

    if not wiki_path:
        print("Error: Wiki path not provided and TIDDLYWIKI_WIKI_PATH environment variable is not set", file=sys.stderr)
        sys.exit(1)

    # Expand ~ to home directory
    wiki_path = os.path.expanduser(wiki_path)

    if not os.path.exists(wiki_path):
        print(f"Error: Wiki path does not exist: {wiki_path}", file=sys.stderr)
        sys.exit(1)

    return wiki_path

def extract_tiddler_stores(content):
    """Extract tiddler store JSON arrays from HTML content."""
    import json

    stores = []
    # Find the start of each tiddler store
    pattern = r'<script class="tiddlywiki-tiddler-store" type="application/json">'

    pos = 0
    while True:
        start_match = content.find(pattern, pos)
        if start_match == -1:
            break

        # Find the start of the JSON array
        json_start = content.find('[', start_match)
        if json_start == -1:
            break

        # Find the matching closing tag
        end_tag = '</script>'
        end_match = content.find(end_tag, json_start)
        if end_match == -1:
            break

        # Extract the JSON (trim whitespace)
        json_str = content[json_start:end_match].strip()

        try:
            # Use strict=False to allow control characters like tabs/newlines in strings
            tiddlers = json.loads(json_str, strict=False)
            stores.append({
                'start': start_match,
                'end': end_match + len(end_tag),
                'tiddlers': tiddlers
            })
        except json.JSONDecodeError as e:
            print(f"Warning: Failed to parse tiddler store: {e}", file=sys.stderr)

        pos = end_match + len(end_tag)

    return stores

def detect_wiki_format(content):
    """Detect whether a wiki uses modern (JSON) or legacy (div) format.

    Returns:
        'modern': Uses <script class="tiddlywiki-tiddler-store"> format
        'legacy': Uses <div id="storeArea"> format

    Raises:
        SystemExit if neither format is detected
    """
    has_modern = '<script class="tiddlywiki-tiddler-store"' in content
    has_legacy = '<div id="storeArea"' in content

    if has_modern:
        return 'modern'
    elif has_legacy:
        return 'legacy'
    else:
        print("Error: Could not detect wiki format (neither modern JSON stores nor legacy storeArea found)", file=sys.stderr)
        sys.exit(1)

def detect_format_streaming(filepath):
    """Detect wiki format by streaming file with early exit.

    This is more efficient than loading the entire file for large wikis.
    Returns as soon as either format marker is found.

    Args:
        filepath: Path to the wiki HTML file

    Returns:
        'modern': Uses <script class="tiddlywiki-tiddler-store"> format
        'legacy': Uses <div id="storeArea"> format

    Raises:
        SystemExit if file cannot be read or no format detected
    """
    CHUNK_SIZE = 1024 * 1024  # 1MB chunks
    OVERLAP = 1024  # Keep 1KB overlap for patterns split across chunks

    modern_marker = b'<script class="tiddlywiki-tiddler-store"'
    legacy_marker = b'<div id="storeArea"'

    try:
        with open(filepath, 'rb') as f:
            previous_chunk_end = b''

            while True:
                chunk = f.read(CHUNK_SIZE)
                if not chunk:
                    break

                # Check in overlap region + current chunk
                search_region = previous_chunk_end + chunk

                if modern_marker in search_region:
                    return 'modern'
                if legacy_marker in search_region:
                    return 'legacy'

                # Save end of chunk for overlap check
                previous_chunk_end = chunk[-OVERLAP:] if len(chunk) >= OVERLAP else chunk

        # Reached end of file without finding a format marker
        print("Error: Could not detect wiki format (neither modern JSON stores nor legacy storeArea found)", file=sys.stderr)
        sys.exit(1)

    except IOError as e:
        print(f"Error: Could not read file: {e}", file=sys.stderr)
        sys.exit(1)

def extract_legacy_tiddlers(content):
    """Extract tiddlers from legacy <div id="storeArea"> format.

    Returns a list of tiddler dictionaries in the same format as modern wikis.
    """
    import html
    import re

    # Find the storeArea div
    store_pattern = r'<div id="storeArea"[^>]*>'
    store_match = re.search(store_pattern, content)
    if not store_match:
        return []

    store_start = store_match.end()

    # Find all div open and close tags with their positions
    # This is much faster than character-by-character scanning
    div_open_pattern = re.compile(r'<div(?:\s+[^>]*)?>|</div>', re.DOTALL)

    # Find the closing </div> for storeArea
    div_count = 1
    store_end = None

    for match in div_open_pattern.finditer(content, store_start):
        tag = match.group()
        if tag.startswith('</'):
            div_count -= 1
            if div_count == 0:
                store_end = match.start()
                break
        else:
            div_count += 1

    if store_end is None:
        print("Error: Could not find closing tag for storeArea", file=sys.stderr)
        sys.exit(1)

    # Extract the store area content
    store_content = content[store_start:store_end]

    # Parse individual tiddler divs
    tiddlers = []

    # Find all tiddler divs - they have attributes (especially 'title')
    # Match pattern: <div ...attributes...>
    tiddler_div_pattern = re.compile(r'<div\s+([^>]+?)>', re.DOTALL)

    # Build list of all div positions (open and close) in store_content
    all_divs = []
    for match in div_open_pattern.finditer(store_content):
        tag = match.group()
        all_divs.append({
            'pos': match.start(),
            'end': match.end(),
            'is_close': tag.startswith('</')
        })

    # Find all tiddler start positions
    tiddler_starts = []
    for match in tiddler_div_pattern.finditer(store_content):
        tiddler_starts.append({
            'pos': match.start(),
            'end': match.end(),
            'attr_string': match.group(1)
        })

    # For each tiddler, find its closing tag
    for tidx, tiddler_info in enumerate(tiddler_starts):
        tiddler_start_pos = tiddler_info['pos']
        tiddler_content_start = tiddler_info['end']
        attr_string = tiddler_info['attr_string']

        # Parse attributes
        tiddler = {}
        attr_pattern = r'(\w+)=(["\'])([^\2]*?)\2'
        for attr_match in re.finditer(attr_pattern, attr_string):
            attr_name = attr_match.group(1)
            attr_value = attr_match.group(3)
            # Decode HTML entities in attribute values
            attr_value = html.unescape(attr_value)
            tiddler[attr_name] = attr_value

        # Only process tiddlers with a title
        if 'title' not in tiddler:
            continue

        # Find the matching closing </div> for this tiddler
        nest_count = 1
        tiddler_end_pos = None

        for div_info in all_divs:
            if div_info['pos'] <= tiddler_content_start:
                continue

            if div_info['is_close']:
                nest_count -= 1
                if nest_count == 0:
                    tiddler_end_pos = div_info['pos']
                    break
            else:
                nest_count += 1

        if tiddler_end_pos is None:
            # Couldn't find closing tag
            continue

        # Extract tiddler content
        tiddler_content_html = store_content[tiddler_content_start:tiddler_end_pos]

        # Extract text from <pre> tags if present
        pre_match = re.search(r'<pre>(.*?)</pre>', tiddler_content_html, re.DOTALL)
        if pre_match:
            text_content = pre_match.group(1)
            # Decode HTML entities in the text
            text_content = html.unescape(text_content)
            tiddler['text'] = text_content
        elif tiddler_content_html.strip():
            # If no <pre> tag, use the content directly (but this is rare)
            text_content = html.unescape(tiddler_content_html.strip())
            # Only set text if there's actual content and doesn't look like HTML tags
            if text_content and not text_content.startswith('<'):
                tiddler['text'] = text_content

        tiddlers.append(tiddler)

    return tiddlers

def load_all_tiddlers(wiki_path):
    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    # Detect format
    wiki_format = detect_wiki_format(content)

    if wiki_format == 'modern':
        stores = extract_tiddler_stores(content)

        if not stores:
            print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
            sys.exit(1)

        # Collect all tiddlers from all stores and record their field order
        all_tiddlers = []
        for store in stores:
            all_tiddlers.extend(store['tiddlers'])
            # Record the field order for each tiddler as it appears in the file
            for tiddler in store['tiddlers']:
                if 'title' in tiddler:
                    field_order = list(tiddler.keys())
                    record_field_order(wiki_path, tiddler['title'], field_order)

    elif wiki_format == 'legacy':
        all_tiddlers = extract_legacy_tiddlers(content)

        if not all_tiddlers:
            print("Error: Could not find any tiddlers in wiki", file=sys.stderr)
            sys.exit(1)

        # Record field order for legacy tiddlers too
        for tiddler in all_tiddlers:
            if 'title' in tiddler:
                field_order = list(tiddler.keys())
                record_field_order(wiki_path, tiddler['title'], field_order)

    if not all_tiddlers:
        print("Error: Could not find any tiddlers in wiki", file=sys.stderr)
        sys.exit(1)

    return all_tiddlers

def list_tiddlers(wiki_path):
    all_tiddlers = load_all_tiddlers(wiki_path)

    # Collect all titles and sort alphabetically
    titles = [tiddler['title'] for tiddler in all_tiddlers if 'title' in tiddler]
    titles.sort()

    # Print all tiddler titles
    for title in titles:
        print(title)

def cat_tiddler(wiki_path, tiddler_title):
    all_tiddlers = load_all_tiddlers(wiki_path)

    # Find the tiddler with matching title
    tiddler = None
    for t in all_tiddlers:
        if t.get('title') == tiddler_title:
            tiddler = t
            break

    if not tiddler:
        print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
        sys.exit(1)

    # Print title first
    if 'title' in tiddler:
        print(f"title: {tiddler['title']}")

    # Print all other fields except 'text' and 'title'
    for key, value in sorted(tiddler.items()):
        if key not in ('text', 'title'):
            print(f"{key}: {value}")

    # Print the text content after a newline
    if 'text' in tiddler:
        print()
        print(tiddler['text'])

def edit_tiddler(wiki_path, tiddler_title):
    """Open a tiddler in $EDITOR for editing in YAML-style format"""
    import threading
    import time

    # Check if EDITOR environment variable is set
    editor = os.environ.get('EDITOR')
    if not editor:
        # Fall back to common editors if EDITOR is not set
        for fallback_editor in ['nvim', 'vim', 'nano', 'emacs', 'vi']:
            import shutil
            if shutil.which(fallback_editor):
                editor = fallback_editor
                break

    if not editor:
        print("Error: $EDITOR environment variable is not set and no fallback editor found", file=sys.stderr)
        sys.exit(1)

    all_tiddlers = load_all_tiddlers(wiki_path)

    # Find the tiddler with matching title
    tiddler = None
    is_new_tiddler = False
    for t in all_tiddlers:
        if t.get('title') == tiddler_title:
            tiddler = t
            break

    # If tiddler doesn't exist, create a template
    if not tiddler:
        tiddler = {
            "title": tiddler_title,
            "created": get_tiddlywiki_timestamp(),
            "modified": get_tiddlywiki_timestamp()
        }
        is_new_tiddler = True

    # Store the original tiddler's meaningful content (excluding timestamps) for comparison
    def get_editable_fields(t):
        """Get tiddler fields excluding created/modified timestamps"""
        result = {}
        for key, value in t.items():
            if key not in ('created', 'modified'):
                result[key] = value
        return result

    original_editable = get_editable_fields(tiddler)

    # Create a temporary file to edit
    temp_fd, temp_path = tempfile.mkstemp(suffix='.txt', text=True)

    try:
        # Write tiddler in cat format to temp file
        # NOTE: We exclude 'created' and 'modified' so that replace_tiddler
        # can detect whether content changed and update the timestamp appropriately
        with os.fdopen(temp_fd, 'w', encoding='utf-8') as f:
            # Write title first
            if 'title' in tiddler:
                f.write(f"title: {tiddler['title']}\n")

            # Write all other fields except 'text', 'title', 'created', and 'modified'
            for key, value in sorted(tiddler.items()):
                if key not in ('text', 'title', 'created', 'modified'):
                    f.write(f"{key}: {value}\n")

            # Write the text content after a blank line
            if 'text' in tiddler:
                f.write('\n')
                f.write(tiddler['text'])

        # Start background watcher for live updates
        stop_watching = threading.Event()
        last_mtime = [os.path.getmtime(temp_path)]
        # Initialize with current content to avoid treating initial write-back as a change
        with open(temp_path, 'r', encoding='utf-8') as f:
            initial_content = f.read()
        last_content = [initial_content]

        def watch_and_update():
            """Background thread that watches for file changes and updates the tiddler"""
            import io
            import contextlib

            while not stop_watching.is_set():
                time.sleep(0.5)  # Poll every 0.5 seconds
                try:
                    current_mtime = os.path.getmtime(temp_path)
                    if current_mtime != last_mtime[0]:
                        last_mtime[0] = current_mtime

                        # Read the updated content
                        with open(temp_path, 'r', encoding='utf-8') as f:
                            updated_content = f.read()

                        # Check if content actually changed (not just mtime)
                        if updated_content == last_content[0]:
                            # Content is identical, skip update
                            continue

                        last_content[0] = updated_content

                        # Add timestamps and update the wiki
                        updated_content_lines = updated_content.split('\n')
                        # Find where to insert timestamps (before the empty line or text)
                        insert_pos = 0
                        for i, line in enumerate(updated_content_lines):
                            if line.strip() == '':
                                insert_pos = i
                                break

                        # Reconstruct content with timestamps
                        new_lines = updated_content_lines[:insert_pos]
                        # Always add created timestamp
                        new_lines.insert(insert_pos, f"created: {tiddler['created']}")
                        # replace_tiddler will update modified timestamp automatically
                        new_lines.extend(updated_content_lines[insert_pos:])
                        content_with_timestamps = '\n'.join(new_lines)

                        # Update the tiddler in the wiki (suppress output)
                        with contextlib.redirect_stdout(io.StringIO()):
                            replace_tiddler(wiki_path, content_with_timestamps, update_modified=True)
                except (FileNotFoundError, OSError):
                    # File was deleted or other OS error, stop watching
                    break

        watcher = threading.Thread(target=watch_and_update, daemon=True)
        watcher.start()

        # Open the file in the editor
        # Split the editor command in case it has arguments (e.g., "emacs -nw")
        editor_parts = editor.split()

        # Get the tiddler type and map to vim filetype
        tiddler_type = tiddler.get('type', 'text/vnd.tiddlywiki')
        vim_filetype = MIME_TO_VIM_FILETYPE.get(tiddler_type, 'text')

        # If using nvim/vim, add filetype command
        editor_base = editor_parts[0].lower() if editor_parts else ''
        if 'vim' in editor_base or 'nvim' in editor_base:
            # Add vim command to set filetype
            editor_parts = editor_parts + ['-c', f'set filetype={vim_filetype}']

        result = subprocess.run(editor_parts + [temp_path], check=False)

        # Stop the watcher
        stop_watching.set()
        watcher.join(timeout=2)

        if result.returncode != 0:
            print(f"Error: Editor exited with status {result.returncode}", file=sys.stderr)
            sys.exit(1)

        # Read the final edited content
        with open(temp_path, 'r', encoding='utf-8') as f:
            edited_content = f.read()

        # Parse the edited content to check what actually changed
        edited_lines = edited_content.split('\n')
        edited_tiddler = {}
        text_start_index = None

        for i, line in enumerate(edited_lines):
            if line.strip() == '':
                text_start_index = i + 1
                break
            elif ':' in line:
                key, value = line.split(':', 1)
                edited_tiddler[key.strip()] = value.strip()
            else:
                text_start_index = i
                break

        if text_start_index is not None and text_start_index < len(edited_lines):
            text_content = '\n'.join(edited_lines[text_start_index:])
            if text_content:
                text_stripped = text_content.rstrip('\n')
                if text_stripped:
                    edited_tiddler['text'] = text_stripped

        # Compare the editable fields
        edited_editable = get_editable_fields(edited_tiddler)
        content_changed = (edited_editable != original_editable)

        # Check if tiddler is missing timestamps
        missing_timestamps = 'created' not in tiddler or 'modified' not in tiddler

        # Save if: content changed, new tiddler, or missing timestamps
        if is_new_tiddler or content_changed or missing_timestamps:
            # For new tiddlers, always update modified. For existing tiddlers, only update if changed.
            should_update_modified = is_new_tiddler or content_changed

            # Ensure timestamps exist for both new and existing tiddlers
            if 'created' not in tiddler:
                tiddler['created'] = get_tiddlywiki_timestamp()
            if 'modified' not in tiddler:
                tiddler['modified'] = get_tiddlywiki_timestamp()

            # Add timestamps to edited_content before saving
            edited_content_lines = edited_content.split('\n')
            # Find where to insert timestamps (before the empty line or text)
            insert_pos = 0
            for i, line in enumerate(edited_content_lines):
                if line.strip() == '':
                    insert_pos = i
                    break

            # Reconstruct content with timestamps
            new_lines = edited_content_lines[:insert_pos]
            # Always add created timestamp
            new_lines.insert(insert_pos, f"created: {tiddler['created']}")
            # Only add modified if content didn't change (otherwise replace_tiddler will update it)
            if not content_changed:
                new_lines.insert(insert_pos + 1, f"modified: {tiddler['modified']}")
            new_lines.extend(edited_content_lines[insert_pos:])
            edited_content = '\n'.join(new_lines)

            # Use replace_tiddler to save the changes (final save when editor closes)
            replace_tiddler(wiki_path, edited_content, update_modified=should_update_modified)

    finally:
        # Clean up the temporary file
        try:
            os.unlink(temp_path)
        except OSError:
            pass

def get_tiddlywiki_timestamp():
    """Generate a TiddlyWiki timestamp in format YYYYMMDDhhmmssxxx (UTC)"""
    from datetime import datetime, timezone

    now = datetime.now(timezone.utc)
    # Format: YYYYMMDDhhmmssxxx where xxx is milliseconds
    timestamp = now.strftime('%Y%m%d%H%M%S') + f'{now.microsecond // 1000:03d}'
    return timestamp

def ensure_timestamps(tiddler, is_modification=True):
    """Ensure a tiddler has created and modified timestamps.

    Args:
        tiddler: The tiddler dict to update
        is_modification: If True, update modified timestamp. If False, only ensure created exists.

    Returns:
        The timestamp used (for consistency across the tiddler)
    """
    timestamp = get_tiddlywiki_timestamp()

    # Always ensure created exists
    if 'created' not in tiddler:
        tiddler['created'] = timestamp

    # Update modified if this is a modification
    if is_modification:
        tiddler['modified'] = timestamp

    return timestamp

def get_tiddler_field(wiki_path, tiddler_title, field_name):
    """Get the value of a specific field from a tiddler"""
    all_tiddlers = load_all_tiddlers(wiki_path)

    # Find the tiddler with matching title
    tiddler = None
    for t in all_tiddlers:
        if t.get('title') == tiddler_title:
            tiddler = t
            break

    if not tiddler:
        print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
        sys.exit(1)

    if field_name not in tiddler:
        print(f"Error: Field '{field_name}' not found in tiddler '{tiddler_title}'", file=sys.stderr)
        sys.exit(1)

    # Print the field value
    print(tiddler[field_name])

def json_tiddler(wiki_path, *tiddler_titles):
    """Output tiddler(s) as JSON.

    If one tiddler is specified, outputs a JSON object.
    If multiple tiddlers are specified, outputs a JSON array.
    """
    import json

    if not tiddler_titles:
        print("Error: At least one tiddler title is required", file=sys.stderr)
        sys.exit(1)

    all_tiddlers = load_all_tiddlers(wiki_path)

    # Find all requested tiddlers
    found_tiddlers = []
    for title in tiddler_titles:
        tiddler = None
        for t in all_tiddlers:
            if t.get('title') == title:
                tiddler = t
                break

        if not tiddler:
            print(f"Error: Tiddler '{title}' not found", file=sys.stderr)
            sys.exit(1)

        found_tiddlers.append(tiddler)

    # Output format depends on number of tiddlers
    if len(found_tiddlers) == 1:
        # Single tiddler - output as object (backward compatible)
        print(json.dumps(found_tiddlers[0], indent=2, ensure_ascii=False))
    else:
        # Multiple tiddlers - output as array
        print(json.dumps(found_tiddlers, indent=2, ensure_ascii=False))

def set_tiddler_field(wiki_path, tiddler_title, field_name, field_value):
    """Set the value of a specific field in a tiddler. Works with both modern and legacy formats."""
    import json

    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    wiki_format = detect_wiki_format(content)

    if wiki_format == 'modern':
        stores = extract_tiddler_stores(content)
        if not stores:
            print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
            sys.exit(1)

        # Find the tiddler in any store
        found_tiddler = None
        for store in stores:
            for tiddler in store['tiddlers']:
                if tiddler.get('title') == tiddler_title:
                    found_tiddler = tiddler
                    break
            if found_tiddler:
                break

        is_new_tiddler = False
        if not found_tiddler:
            # Create new tiddler if it doesn't exist
            found_tiddler = {
                "title": tiddler_title
            }
            is_new_tiddler = True
            # Add to the first store
            stores[0]['tiddlers'].append(found_tiddler)
            print(f"Created tiddler: {tiddler_title}")

        # Check if the field value actually changed
        old_value = found_tiddler.get(field_name)
        field_changed = (old_value != field_value)

        # Set the field value
        found_tiddler[field_name] = field_value

        # Update timestamps if:
        # 1. This is a new tiddler, OR
        # 2. The field changed AND we're not setting timestamps directly
        if is_new_tiddler or (field_changed and field_name not in ('modified', 'created')):
            ensure_timestamps(found_tiddler, is_modification=True)
        elif not is_new_tiddler:
            # For existing tiddlers, ensure created exists even if nothing changed
            ensure_timestamps(found_tiddler, is_modification=False)

        # Build replacements for all stores
        replacements = []
        for store in stores:
            sorted_tiddlers = sorted(store['tiddlers'], key=lambda t: t.get('title', ''))
            tiddler_jsons = [json.dumps(reorder_tiddler_fields(t, wiki_path, t.get('title', '')), ensure_ascii=False, separators=(',', ':')) for t in sorted_tiddlers]
            new_json = '[\n' + ',\n'.join(tiddler_jsons) + '\n]'
            new_json = new_json.replace('<', '\\u003C')
            new_store = f'<script class="tiddlywiki-tiddler-store" type="application/json">{new_json}</script>'
            replacements.append((store['start'], store['end'], new_store))

        new_content = content
        for start, end, replacement in reversed(replacements):
            new_content = new_content[:start] + replacement + new_content[end:]

        with open(wiki_path, 'w', encoding='utf-8') as f:
            f.write(new_content)

    elif wiki_format == 'legacy':
        # Load all tiddlers
        all_tiddlers = load_all_tiddlers(wiki_path)

        # Find the tiddler
        found_tiddler = None
        for tiddler in all_tiddlers:
            if tiddler.get('title') == tiddler_title:
                found_tiddler = tiddler
                break

        is_new_tiddler = False
        if not found_tiddler:
            # Create new tiddler if it doesn't exist
            found_tiddler = {
                "title": tiddler_title
            }
            is_new_tiddler = True
            all_tiddlers.append(found_tiddler)
            print(f"Created tiddler: {tiddler_title}")

        # Check if the field value actually changed
        old_value = found_tiddler.get(field_name)
        field_changed = (old_value != field_value)

        # Set the field value
        found_tiddler[field_name] = field_value

        # Update timestamps
        if is_new_tiddler or (field_changed and field_name not in ('modified', 'created')):
            ensure_timestamps(found_tiddler, is_modification=True)
        elif not is_new_tiddler:
            ensure_timestamps(found_tiddler, is_modification=False)

        write_legacy_wiki(wiki_path, all_tiddlers)

    print(f"Set {field_name} = {field_value}")

def touch_tiddler(wiki_path, tiddler_title, text=""):
    """Create a new tiddler or update an existing one. Works with both modern and legacy formats."""
    import json

    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    wiki_format = detect_wiki_format(content)

    if wiki_format == 'modern':
        stores = extract_tiddler_stores(content)
        if not stores:
            print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
            sys.exit(1)

        # Check if tiddler already exists
        existing_tiddler = None
        for store in stores:
            for tiddler in store['tiddlers']:
                if tiddler.get('title') == tiddler_title:
                    existing_tiddler = tiddler
                    break
            if existing_tiddler:
                break

        if existing_tiddler:
            # Update existing tiddler's modified timestamp and ensure created exists
            ensure_timestamps(existing_tiddler, is_modification=True)
            if text:
                existing_tiddler['text'] = text
            print(f"Updated tiddler: {tiddler_title}")
        else:
            # Create new tiddler
            new_tiddler = {
                "title": tiddler_title,
                "text": text
            }
            ensure_timestamps(new_tiddler, is_modification=True)

            # Add to the first store
            stores[0]['tiddlers'].append(new_tiddler)
            print(f"Created tiddler: {tiddler_title}")

        # Build replacements for all stores
        replacements = []
        for store in stores:
            sorted_tiddlers = sorted(store['tiddlers'], key=lambda t: t.get('title', ''))
            tiddler_jsons = [json.dumps(reorder_tiddler_fields(t, wiki_path, t.get('title', '')), ensure_ascii=False, separators=(',', ':')) for t in sorted_tiddlers]
            new_json = '[\n' + ',\n'.join(tiddler_jsons) + '\n]'
            new_json = new_json.replace('<', '\\u003C')
            new_store = f'<script class="tiddlywiki-tiddler-store" type="application/json">{new_json}</script>'
            replacements.append((store['start'], store['end'], new_store))

        new_content = content
        for start, end, replacement in reversed(replacements):
            new_content = new_content[:start] + replacement + new_content[end:]

        with open(wiki_path, 'w', encoding='utf-8') as f:
            f.write(new_content)

    elif wiki_format == 'legacy':
        # Load all tiddlers
        all_tiddlers = load_all_tiddlers(wiki_path)

        # Check if tiddler already exists
        existing_tiddler = None
        for tiddler in all_tiddlers:
            if tiddler.get('title') == tiddler_title:
                existing_tiddler = tiddler
                break

        if existing_tiddler:
            # Update existing tiddler's modified timestamp and ensure created exists
            ensure_timestamps(existing_tiddler, is_modification=True)
            if text:
                existing_tiddler['text'] = text
            print(f"Updated tiddler: {tiddler_title}")
        else:
            # Create new tiddler
            new_tiddler = {
                "title": tiddler_title,
                "text": text
            }
            ensure_timestamps(new_tiddler, is_modification=True)
            all_tiddlers.append(new_tiddler)
            print(f"Created tiddler: {tiddler_title}")

        write_legacy_wiki(wiki_path, all_tiddlers)

def remove_tiddler(wiki_path, tiddler_title):
    """Remove a tiddler from the wiki. Works with both modern and legacy formats."""
    import json

    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    wiki_format = detect_wiki_format(content)

    if wiki_format == 'modern':
        stores = extract_tiddler_stores(content)
        if not stores:
            print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
            sys.exit(1)

        found = False

        # Build list of replacements, removing from each store
        replacements = []
        for store in stores:
            original_count = len(store['tiddlers'])
            # Filter out the tiddler with matching title
            filtered_tiddlers = [t for t in store['tiddlers'] if t.get('title') != tiddler_title]

            if len(filtered_tiddlers) < original_count:
                found = True

            # Sort tiddlers alphabetically by title
            sorted_tiddlers = sorted(filtered_tiddlers, key=lambda t: t.get('title', ''))

            # Rebuild the script tag with filtered tiddlers
            tiddler_jsons = [json.dumps(reorder_tiddler_fields(t, wiki_path, t.get('title', '')), ensure_ascii=False, separators=(',', ':')) for t in sorted_tiddlers]
            new_json = '[\n' + ',\n'.join(tiddler_jsons) + '\n]'
            new_json = new_json.replace('<', '\\u003C')
            new_store = f'<script class="tiddlywiki-tiddler-store" type="application/json">{new_json}</script>'
            replacements.append((store['start'], store['end'], new_store))

        if not found:
            print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
            sys.exit(1)

        # Apply replacements in reverse order
        new_content = content
        for start, end, replacement in reversed(replacements):
            new_content = new_content[:start] + replacement + new_content[end:]

        # Write back
        with open(wiki_path, 'w', encoding='utf-8') as f:
            f.write(new_content)

    elif wiki_format == 'legacy':
        # Load all tiddlers
        all_tiddlers = load_all_tiddlers(wiki_path)

        # Filter out the tiddler to remove
        original_count = len(all_tiddlers)
        filtered_tiddlers = [t for t in all_tiddlers if t.get('title') != tiddler_title]

        if len(filtered_tiddlers) == original_count:
            print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
            sys.exit(1)

        write_legacy_wiki(wiki_path, filtered_tiddlers)

    print(f"Removed tiddler: {tiddler_title}")

def replace_tiddler(wiki_path, markdown_content, update_modified=True):
    """Replace a tiddler from cat-style format (YAML frontmatter + text)

    This is the inverse of cat_tiddler - it parses the same format that
    cat outputs and inserts it back into the wiki.

    Args:
        wiki_path: Path to the wiki file
        markdown_content: Content in cat format (YAML frontmatter + text)
        update_modified: If True, update the modified timestamp. If False, preserve existing timestamp.
    """
    import json

    # Parse YAML frontmatter and text
    lines = markdown_content.split('\n')

    # Check if content is empty
    if not lines:
        print("Error: Empty content provided", file=sys.stderr)
        sys.exit(1)

    # Parse YAML-style frontmatter (key: value format)
    # Until we hit an empty line, then everything else is text
    tiddler = {}
    text_start_index = None
    user_provided_modified = False

    for i, line in enumerate(lines):
        if line.strip() == '':
            # Empty line marks end of frontmatter
            text_start_index = i + 1
            break
        elif ':' in line:
            # Parse field: value
            key, value = line.split(':', 1)
            key_stripped = key.strip()
            if key_stripped == 'modified':
                user_provided_modified = True
            tiddler[key_stripped] = value.strip()
        else:
            # If we encounter a line without ':', treat as start of text
            text_start_index = i
            break

    # Everything after the empty line (or non-field line) is the text
    if text_start_index is not None and text_start_index < len(lines):
        text_content = '\n'.join(lines[text_start_index:])
        # Strip trailing newline for perfect roundtrip with cat
        if text_content:
            # Only strip if it's just whitespace, otherwise keep the content
            text_stripped = text_content.rstrip('\n')
            if text_stripped:  # Only add text field if there's content
                tiddler['text'] = text_stripped

    # Verify it has a title field
    if 'title' not in tiddler:
        print("Error: Tiddler must have a 'title' field", file=sys.stderr)
        sys.exit(1)

    # Ensure created timestamp exists
    if 'created' not in tiddler:
        tiddler['created'] = get_tiddlywiki_timestamp()

    # Handle modified timestamp
    if 'modified' not in tiddler:
        # No modified field provided - add one
        tiddler['modified'] = get_tiddlywiki_timestamp()
    elif update_modified and not user_provided_modified:
        # Update modified timestamp only if:
        # 1. update_modified=True (requested), AND
        # 2. The user didn't explicitly provide the modified field in the input
        tiddler['modified'] = get_tiddlywiki_timestamp()

    # Use insert_tiddler to do the actual insertion
    tiddler_json = json.dumps(tiddler)
    insert_tiddler(wiki_path, tiddler_json)

def append_tiddler(wiki_path, tiddler_title, text_to_append=None):
    """Append text to a tiddler's text field

    Args:
        wiki_path: Path to the wiki file
        tiddler_title: Title of the tiddler to append to
        text_to_append: Text to append (if None, read from stdin)
    """
    import json

    # Read from stdin if no text provided
    if text_to_append is None:
        text_to_append = sys.stdin.read()

    all_tiddlers = load_all_tiddlers(wiki_path)

    # Find the tiddler with matching title
    tiddler = None
    for t in all_tiddlers:
        if t.get('title') == tiddler_title:
            tiddler = t
            break

    if not tiddler:
        print(f"Error: Tiddler '{tiddler_title}' not found", file=sys.stderr)
        sys.exit(1)

    # Append to existing text
    existing_text = tiddler.get('text', '')
    if existing_text:
        # Add newline between existing and new content if both have content
        tiddler['text'] = existing_text + '\n' + text_to_append
    else:
        tiddler['text'] = text_to_append

    # Update modified timestamp and ensure created exists
    ensure_timestamps(tiddler, is_modification=True)

    # Use insert_tiddler to save (it handles the full update)
    tiddler_json = json.dumps(tiddler)
    insert_tiddler(wiki_path, tiddler_json)

def serialize_legacy_tiddler(tiddler):
    """Convert a tiddler dictionary to legacy div format.

    Args:
        tiddler: Dictionary with tiddler fields

    Returns:
        HTML string representing the tiddler as a div
    """
    import html

    # Standard attribute order for consistency
    attr_order = ['created', 'creator', 'modified', 'modifier', 'revision', 'tags', 'title']

    # Build attributes string
    attrs = []
    for attr_name in attr_order:
        if attr_name in tiddler:
            attr_value = str(tiddler[attr_name])
            # Escape HTML entities in attribute values
            attr_value = html.escape(attr_value, quote=True)
            attrs.append(f'{attr_name}="{attr_value}"')

    # Add any other attributes not in the standard order
    for attr_name, attr_value in tiddler.items():
        if attr_name not in attr_order and attr_name != 'text':
            attr_value = html.escape(str(attr_value), quote=True)
            attrs.append(f'{attr_name}="{attr_value}"')

    attrs_str = ' '.join(attrs)

    # Build the div
    div_parts = [f'<div {attrs_str}>']

    # Add text content wrapped in <pre> tag if present
    if 'text' in tiddler:
        text_content = tiddler['text']
        # Escape HTML entities in text
        text_content = html.escape(text_content, quote=False)
        div_parts.append(f'<pre>{text_content}</pre>')

    div_parts.append('</div>')

    return '\n'.join(div_parts)

def build_legacy_store(tiddlers):
    """Build a complete legacy storeArea from a list of tiddlers.

    Args:
        tiddlers: List of tiddler dictionaries

    Returns:
        HTML string with <div id="storeArea"> containing all tiddlers
    """
    # Sort tiddlers by title
    sorted_tiddlers = sorted(tiddlers, key=lambda t: t.get('title', ''))

    store_parts = ['<div id="storeArea" style="display:none;">']

    for tiddler in sorted_tiddlers:
        tiddler_html = serialize_legacy_tiddler(tiddler)
        store_parts.append(tiddler_html)

    store_parts.append('</div>')

    return '\n'.join(store_parts)

def write_legacy_wiki(wiki_path, tiddlers):
    """Write tiddlers back to a legacy format wiki.

    Args:
        wiki_path: Path to the wiki file
        tiddlers: List of tiddler dictionaries to write
    """
    import re

    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    # Find the storeArea location
    store_pattern = r'<div id="storeArea"[^>]*>'
    store_match = re.search(store_pattern, content)
    if not store_match:
        print("Error: Could not find storeArea in wiki", file=sys.stderr)
        sys.exit(1)

    store_start = store_match.start()

    # Find the closing </div> for storeArea
    div_open_pattern = re.compile(r'<div(?:\s+[^>]*)?>|</div>', re.DOTALL)
    div_count = 1
    store_end = None

    for match in div_open_pattern.finditer(content, store_match.end()):
        tag = match.group()
        if tag.startswith('</'):
            div_count -= 1
            if div_count == 0:
                store_end = match.end()
                break
        else:
            div_count += 1

    if store_end is None:
        print("Error: Could not find closing tag for storeArea", file=sys.stderr)
        sys.exit(1)

    # Build new store area
    new_store = build_legacy_store(tiddlers)

    # Replace the old store with the new one
    new_content = content[:store_start] + new_store + content[store_end:]

    # Write back
    with open(wiki_path, 'w', encoding='utf-8') as f:
        f.write(new_content)

def insert_tiddler(wiki_path, tiddler_json):
    """Insert tiddler(s) from JSON, replacing if they already exist.

    Accepts either a single tiddler as a JSON object or multiple tiddlers as a JSON array.
    Works with both modern and legacy wiki formats.
    """
    import json

    # Parse the input JSON
    try:
        parsed_json = json.loads(tiddler_json)
    except json.JSONDecodeError as e:
        print(f"Error: Invalid JSON: {e}", file=sys.stderr)
        sys.exit(1)

    # Determine if we have a single tiddler (dict) or multiple tiddlers (list)
    if isinstance(parsed_json, dict):
        # Single tiddler - use existing logic
        tiddlers_to_insert = [parsed_json]
    elif isinstance(parsed_json, list):
        # Multiple tiddlers
        tiddlers_to_insert = parsed_json
    else:
        print("Error: JSON must be either an object (single tiddler) or an array (multiple tiddlers)", file=sys.stderr)
        sys.exit(1)

    # Validate all tiddlers before inserting any
    for i, tiddler in enumerate(tiddlers_to_insert):
        if not isinstance(tiddler, dict):
            print(f"Error: Array element {i} is not a valid tiddler object", file=sys.stderr)
            sys.exit(1)
        if 'title' not in tiddler:
            print(f"Error: Array element {i} is missing required 'title' field", file=sys.stderr)
            sys.exit(1)

    # Load the wiki and detect format
    with open(wiki_path, 'r', encoding='utf-8') as f:
        content = f.read()

    wiki_format = detect_wiki_format(content)

    # Track which tiddlers were replaced vs inserted
    replaced_titles = []
    inserted_titles = []

    if wiki_format == 'modern':
        # Use modern format - maintain separate stores
        stores = extract_tiddler_stores(content)
        if not stores:
            print("Error: Could not find any tiddler stores in wiki", file=sys.stderr)
            sys.exit(1)

        # Process each tiddler to insert
        for new_tiddler in tiddlers_to_insert:
            # Ensure timestamps exist
            if 'created' not in new_tiddler:
                new_tiddler['created'] = get_tiddlywiki_timestamp()
            if 'modified' not in new_tiddler:
                new_tiddler['modified'] = get_tiddlywiki_timestamp()

            tiddler_title = new_tiddler['title']

            # Check if tiddler already exists in any store and remove it
            found = False
            for store in stores:
                original_count = len(store['tiddlers'])
                store['tiddlers'] = [t for t in store['tiddlers'] if t.get('title') != tiddler_title]
                if len(store['tiddlers']) < original_count:
                    found = True

            # Add the new tiddler to the first store
            stores[0]['tiddlers'].append(new_tiddler)

            # Track what happened
            if found:
                replaced_titles.append(tiddler_title)
            else:
                inserted_titles.append(tiddler_title)

        # Build replacements for all stores
        replacements = []
        for store in stores:
            sorted_tiddlers = sorted(store['tiddlers'], key=lambda t: t.get('title', ''))
            tiddler_jsons = [json.dumps(reorder_tiddler_fields(t, wiki_path, t.get('title', '')), ensure_ascii=False, separators=(',', ':')) for t in sorted_tiddlers]
            new_json = '[\n' + ',\n'.join(tiddler_jsons) + '\n]'
            new_json = new_json.replace('<', '\\u003C')
            new_store = f'<script class="tiddlywiki-tiddler-store" type="application/json">{new_json}</script>'
            replacements.append((store['start'], store['end'], new_store))

        # Apply replacements in reverse order
        new_content = content
        for start, end, replacement in reversed(replacements):
            new_content = new_content[:start] + replacement + new_content[end:]

        # Write back
        with open(wiki_path, 'w', encoding='utf-8') as f:
            f.write(new_content)

    elif wiki_format == 'legacy':
        # Load all existing tiddlers
        all_tiddlers = load_all_tiddlers(wiki_path)

        # Process each tiddler to insert
        for new_tiddler in tiddlers_to_insert:
            # Ensure timestamps exist
            if 'created' not in new_tiddler:
                new_tiddler['created'] = get_tiddlywiki_timestamp()
            if 'modified' not in new_tiddler:
                new_tiddler['modified'] = get_tiddlywiki_timestamp()

            tiddler_title = new_tiddler['title']

            # Check if tiddler already exists
            found = False
            for i, existing in enumerate(all_tiddlers):
                if existing.get('title') == tiddler_title:
                    all_tiddlers[i] = new_tiddler
                    found = True
                    break

            if not found:
                all_tiddlers.append(new_tiddler)

            # Track what happened
            if found:
                replaced_titles.append(tiddler_title)
            else:
                inserted_titles.append(tiddler_title)

        # Use legacy format writing
        write_legacy_wiki(wiki_path, all_tiddlers)

    # Print summary
    for title in replaced_titles:
        print(f"Replaced tiddler: {title}")
    for title in inserted_titles:
        print(f"Inserted tiddler: {title}")

def install_live_reload_plugin(wiki_path):
    """Install the live reload plugin into the wiki"""
    import json

    # The live reload plugin code
    plugin_code = """(function(){
  "use strict";

  exports.name = "live-reload";
  exports.platforms = ["browser"];
  exports.after = ["startup"];
  exports.synchronous = true;

  exports.startup = function() {
    // Only run in browser
    if($tw.browser) {
      checkForServer();
    }
  };

  function checkForServer() {
    var meta = document.querySelector('meta[name="tw-server"]');
    if (!meta || meta.getAttribute('content') !== 'enabled') {
      console.log('[LiveReload] Not running on tw server, aborting');
      return;
    }

    console.log('[LiveReload] Detected tw server, starting live reload');
    startPolling();
    enableWebDAVSaver();
  }

  function enableWebDAVSaver() {
    // Check if server supports WebDAV via OPTIONS request
    fetch('/', {method: 'OPTIONS'})
      .then(function(response) {
        var davHeader = response.headers.get('DAV');
        if (davHeader) {
          console.log('[LiveReload] WebDAV detected (DAV: ' + davHeader + '), enabling saver');

          // TiddlyWiki's WebDAV saver is already built-in and will auto-detect WebDAV support
          // We only need to set AutoSave config if it doesn't already exist or is different
          var existingTiddler = $tw.wiki.getTiddler('$:/config/AutoSave');
          var shouldUpdate = !existingTiddler || existingTiddler.fields.text !== 'yes';

          if (shouldUpdate) {
            $tw.wiki.addTiddler(new $tw.Tiddler({
              title: '$:/config/AutoSave',
              text: 'yes'
            }));
            console.log('[LiveReload] WebDAV saver enabled - you can now save changes!');
          } else {
            console.log('[LiveReload] WebDAV saver already enabled');
          }
        } else {
          console.log('[LiveReload] WebDAV not available on server');
        }
      })
      .catch(function(error) {
        console.log('[LiveReload] Could not check for WebDAV support:', error);
      });
  }

  var lastVersion = null;
  var savedVersions = {}; // Track versions we saved: {version: timestamp}
  var VERSION_SKIP_DURATION = 10000; // Skip reloading versions we saved for 10 seconds
  var isReloading = false; // Flag to prevent marking as dirty during reload
  var isSaving = false; // Flag to track when a save is in progress

  // Hook into TiddlyWiki's save mechanism to track when we initiate a save
  if ($tw.wiki) {
    var originalAddTiddler = $tw.wiki.addTiddler;
    $tw.wiki.addTiddler = function(tiddler) {
      var result = originalAddTiddler.apply(this, arguments);
      // If this is a user-initiated change (not from our plugin reload), mark as saving
      // Ignore: reloads and temporary tiddlers
      if (!isReloading &&
          tiddler &&
          tiddler.fields &&
          tiddler.fields.title &&
          !tiddler.fields.title.startsWith('$:/temp')) {

        // Debounce: only mark as saving if we're not already saving
        if (!isSaving) {
          isSaving = true;
          console.log('[LiveReload] User change detected:', tiddler.fields.title);

          // Clear the saving flag after a short delay to capture the version after save
          setTimeout(function() {
            if (isSaving) {
              // Fetch current version and mark it as saved by us
              fetch('/_tw/version')
                .then(function(response) { return response.json(); })
                .then(function(data) {
                  savedVersions[data.version] = Date.now();
                  console.log('[LiveReload] Marked version as saved:', data.version);
                  isSaving = false;
                })
                .catch(function(error) {
                  console.error('[LiveReload] Error fetching version after save:', error);
                  isSaving = false;
                });
            }
          }, 1000); // Wait 1 second for the save to complete
        }
      }
      return result;
    };
  }

  function startPolling() {
    setInterval(function() {
      checkVersion();
      cleanupOldSavedVersions();
    }, 3000); // Poll every 3 seconds
  }

  function cleanupOldSavedVersions() {
    // Remove saved versions older than VERSION_SKIP_DURATION
    var now = Date.now();
    for (var version in savedVersions) {
      if (now - savedVersions[version] > VERSION_SKIP_DURATION) {
        delete savedVersions[version];
      }
    }
  }

  function checkVersion() {
    fetch('/_tw/version')
      .then(function(response) { return response.json(); })
      .then(function(data) {
        console.log('[LiveReload] Version check:', data.version);

        if (lastVersion === null) {
          // First check, just store the version
          lastVersion = data.version;
          console.log('[LiveReload] Initial version:', lastVersion);
          return;
        }

        if (data.version !== lastVersion) {
          // Check if this version was saved by us
          if (savedVersions[data.version]) {
            var timeSinceSave = Date.now() - savedVersions[data.version];
            console.log('[LiveReload] File changed to version we just saved (' + timeSinceSave + 'ms ago), skipping reload');
            lastVersion = data.version;
            return;
          }

          console.log('[LiveReload] File changed! Old:', lastVersion, 'New:', data.version);
          lastVersion = data.version;
          reloadTiddlers();
        }
      })
      .catch(function(error) {
        console.error('[LiveReload] Error checking version:', error);
      });
  }

  function reloadTiddlers() {
    fetch('/_tw/tiddlers')
      .then(function(response) { return response.json(); })
      .then(function(data) {
        console.log('[LiveReload] Got', data.tiddlers.length, 'tiddlers from server');

        // Set flag to prevent marking wiki as dirty during reload
        isReloading = true;

        // Get current tiddler titles (all tiddlers from the store)
        var currentTitles = $tw.wiki.getTiddlers();

        var newTitles = data.tiddlers.map(function(t) { return t.title; });

        var updateCount = 0;
        var deleteCount = 0;
        var changedTiddlers = {};

        // Update/add tiddlers
        data.tiddlers.forEach(function(tiddlerData) {
          var browserTiddler = $tw.wiki.getTiddler(tiddlerData.title);

          if (!browserTiddler) {
            // New tiddler - not in browser
            console.log('[LiveReload] Adding new tiddler:', tiddlerData.title);
            $tw.wiki.addTiddler(new $tw.Tiddler(tiddlerData));
            changedTiddlers[tiddlerData.title] = true;
            updateCount++;
          } else {
            // Compare canonical serialized representations instead of field-by-field
            // This handles all data types uniformly without special cases

            // Fields to ignore when comparing (metadata/computed fields)
            var ignoreFields = {
              'modified': true,
              'created': true,
              'revision': true,
              'bag': true
            };

            // Create normalized copies without ignored fields
            var serverNormalized = {};
            var browserNormalized = {};

            // Copy server fields (except ignored)
            for (var field in tiddlerData) {
              if (!ignoreFields[field]) {
                serverNormalized[field] = tiddlerData[field];
              }
            }

            // Copy browser fields (except ignored)
            // Convert arrays to TiddlyWiki string format to match server
            for (var field in browserTiddler.fields) {
              if (!ignoreFields[field]) {
                var value = browserTiddler.fields[field];
                // TiddlyWiki represents tags/lists as arrays in browser but strings in files
                // Use TiddlyWiki's stringifyList to convert arrays to proper format
                if (Array.isArray(value) && $tw.utils.stringifyList) {
                  browserNormalized[field] = $tw.utils.stringifyList(value);
                } else {
                  browserNormalized[field] = value;
                }
              }
            }

            // Serialize both to JSON with sorted keys for consistent comparison
            var serverJson = JSON.stringify(serverNormalized, Object.keys(serverNormalized).sort());
            var browserJson = JSON.stringify(browserNormalized, Object.keys(browserNormalized).sort());

            if (serverJson !== browserJson) {
              console.log('[DEBUG] ' + tiddlerData.title + ' content changed');
              console.log('  Server JSON: ' + serverJson.substring(0, 200));
              console.log('  Browser JSON: ' + browserJson.substring(0, 200));

              $tw.wiki.addTiddler(new $tw.Tiddler(tiddlerData));
              changedTiddlers[tiddlerData.title] = true;
              updateCount++;
            }
          }
        });

        // Delete removed tiddlers
        currentTitles.forEach(function(title) {
          if (newTitles.indexOf(title) === -1) {
            console.log('[LiveReload] Deleting tiddler:', title);
            $tw.wiki.deleteTiddler(title);
            changedTiddlers[title] = true;
            deleteCount++;
          }
        });

        // Refresh the UI if any changes were made
        if (updateCount > 0 || deleteCount > 0) {
          // Trigger a refresh of the root widget
          $tw.rootWidget.refresh(changedTiddlers);
          console.log('[LiveReload] Reload complete - updated:', updateCount, 'deleted:', deleteCount);

          // Mark the wiki as saved at current change count
          // This prevents the wiki from showing as "dirty" after a reload from server
          if ($tw.wiki.getChangeCount && $tw.syncer && $tw.syncer.wiki) {
            $tw.syncer.wiki.addTiddler(new $tw.Tiddler(
              $tw.wiki.getTiddler('$:/config/SaverStartupTime'),
              {text: '' + $tw.wiki.getChangeCount()}
            ));
            console.log('[LiveReload] Updated save marker to change count:', $tw.wiki.getChangeCount());
          }
        } else {
          console.log('[LiveReload] No changes detected');
        }

        // Clear the reloading flag after a delay to let TiddlyWiki's reactive updates settle
        setTimeout(function() {
          isReloading = false;
          console.log('[LiveReload] Reload flag cleared');
        }, 500);
      })
      .catch(function(error) {
        console.error('[LiveReload] Error reloading tiddlers:', error);
        // Clear flag even on error, with delay for consistency
        setTimeout(function() {
          isReloading = false;
        }, 500);
      });
  }
})();
"""

    # Create the plugin tiddler
    plugin_tiddler = {
        "title": "$:/plugins/phajas/live-reload",
        "type": "application/javascript",
        "module-type": "startup",
        "text": plugin_code,
        "tags": "$:/tags/StartupModule",
        "description": "Live reload functionality with WebDAV save support for tw server",
        "version": "0.8.1"
    }

    # Convert to JSON and insert
    plugin_json = json.dumps(plugin_tiddler)
    insert_tiddler(wiki_path, plugin_json)

    print("Live reload plugin installed successfully")
    print("Start the server with: tw serve")

def init_wiki(dest_path):
    """Download an empty TiddlyWiki and save it to the specified path"""
    # Expand ~ to home directory
    dest_path = os.path.expanduser(dest_path)

    # Check if file already exists
    if os.path.exists(dest_path):
        print(f"Error: File already exists: {dest_path}", file=sys.stderr)
        sys.exit(1)

    # Check if parent directory exists
    parent_dir = os.path.dirname(dest_path)
    if parent_dir and not os.path.exists(parent_dir):
        print(f"Error: Parent directory does not exist: {parent_dir}", file=sys.stderr)
        sys.exit(1)

    try:
        print(f"Downloading empty wiki from tiddlywiki.com...")
        # Download the empty wiki
        url = 'https://tiddlywiki.com/empty.html'
        with urllib.request.urlopen(url, timeout=10) as response:
            wiki_content = response.read().decode('utf-8')
    except urllib.error.URLError as e:
        print(f"Error: Failed to download wiki: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)

    # Verify the downloaded content has tiddler stores
    stores = extract_tiddler_stores(wiki_content)
    if not stores:
        print("Error: Downloaded wiki does not contain tiddler stores", file=sys.stderr)
        sys.exit(1)

    # Write to file atomically (temp file + rename)
    temp_path = dest_path + '.tmp'
    try:
        with open(temp_path, 'w', encoding='utf-8') as f:
            f.write(wiki_content)
        os.replace(temp_path, dest_path)
    except Exception as e:
        # Clean up temp file if it exists
        if os.path.exists(temp_path):
            try:
                os.remove(temp_path)
            except:
                pass
        print(f"Error: Failed to write wiki file: {e}", file=sys.stderr)
        sys.exit(1)

    print(f"Created wiki: {dest_path}")

def serve_wiki(wiki_path, host='localhost', port=8080, readonly=False):
    """Serve the TiddlyWiki file locally using Python's built-in HTTP server

    Args:
        wiki_path: Path to the wiki HTML file
        host: Host to bind to (default: localhost)
        port: Port to bind to (default: 8080)
        readonly: If True, disable saving via PUT requests (default: False)
    """
    from http.server import HTTPServer, BaseHTTPRequestHandler
    import threading
    import time
    import json
    import mimetypes

    class WikiWatcher:
        """Watch the wiki file for changes and track version"""
        def __init__(self, wiki_path):
            self.wiki_path = wiki_path
            self.current_mtime = os.path.getmtime(wiki_path)
            self.lock = threading.Lock()

        def watch(self):
            """Background thread that polls for file changes"""
            while True:
                time.sleep(0.5)
                try:
                    mtime = os.path.getmtime(self.wiki_path)
                    if mtime != self.current_mtime:
                        with self.lock:
                            self.current_mtime = mtime
                        print(f"[File changed] {self.wiki_path} (mtime: {mtime})")
                except OSError as e:
                    print(f"[Warning] Could not check file: {e}")

        def get_version(self):
            """Get the current file modification time"""
            with self.lock:
                return self.current_mtime

    # Initialize the file watcher
    watcher = WikiWatcher(wiki_path)
    watcher_thread = threading.Thread(target=watcher.watch, daemon=True)
    watcher_thread.start()

    class WikiHandler(BaseHTTPRequestHandler):
        def send_webdav_headers(self):
            """Send WebDAV-specific headers"""
            self.send_header('DAV', '1,2')
            self.send_header('Allow', 'OPTIONS, GET, HEAD, PUT')
            self.send_header('Access-Control-Allow-Origin', '*')
            self.send_header('Access-Control-Allow-Methods', 'OPTIONS, GET, HEAD, PUT')
            self.send_header('Access-Control-Allow-Headers', 'Content-Type, X-Requested-With')

        def do_OPTIONS(self):
            """Handle OPTIONS requests for WebDAV discovery"""
            self.send_response(200)
            self.send_webdav_headers()
            self.send_header('Content-Length', '0')
            self.end_headers()

        def do_PUT(self):
            """Handle PUT requests to save the wiki file"""
            # Reject all save attempts in readonly mode
            if readonly:
                self.send_error(403, 'Server is in readonly mode')
                print(f"[WebDAV PUT] Rejected save attempt (readonly mode)", file=sys.stderr)
                return

            try:
                # Read the incoming HTML from request body
                content_length = int(self.headers.get('Content-Length', 0))
                if content_length == 0:
                    self.send_error(400, 'Empty request body')
                    return

                wiki_html = self.rfile.read(content_length)

                # Decode to string for validation
                try:
                    wiki_html_str = wiki_html.decode('utf-8')
                except UnicodeDecodeError as e:
                    self.send_error(400, f'Invalid UTF-8 encoding: {e}')
                    return

                # Validate that the HTML has tiddler stores
                stores = extract_tiddler_stores(wiki_html_str)
                if not stores:
                    self.send_error(400, 'Invalid wiki HTML: no tiddler stores found')
                    print(f"[WebDAV PUT] Rejected invalid HTML (no tiddler stores)", file=sys.stderr)
                    return

                # Write to temp file first (atomic operation)
                temp_path = wiki_path + '.tmp'
                with open(temp_path, 'wb') as f:
                    f.write(wiki_html)

                # Atomic replace
                os.replace(temp_path, wiki_path)

                print(f"[WebDAV PUT] Saved wiki file ({len(wiki_html)} bytes)")

                # Return success (204 No Content is standard for WebDAV PUT)
                self.send_response(204)
                self.send_webdav_headers()
                self.end_headers()

            except Exception as e:
                print(f"[WebDAV PUT] Error saving file: {e}", file=sys.stderr)
                self.send_error(500, f'Error saving file: {e}')

        def do_HEAD(self):
            """Handle HEAD requests - same as GET but without body"""
            # Just use do_GET, but the BaseHTTPRequestHandler will automatically
            # not send the body for HEAD requests
            self.do_GET()

        def do_GET(self):
            """Handle GET requests by serving the wiki file or API endpoints"""
            # API endpoint: version check
            if self.path == '/_tw/version':
                self.send_version_response()
                return

            # API endpoint: tiddlers JSON
            if self.path == '/_tw/tiddlers':
                self.send_tiddlers_response()
                return

            # Root path: serve the wiki HTML
            if self.path == '/' or self.path == '':
                self.send_wiki_html()
                return

            # For any other path, try to serve as a file (for _canonical_uri support)
            self.send_file()

        def send_version_response(self):
            """Send current file version/mtime"""
            try:
                version = watcher.get_version()
                response_data = {
                    "version": version,
                    "mtime": version,
                    "server": "tw-python"
                }

                response_json = json.dumps(response_data).encode('utf-8')

                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.send_header('Content-Length', str(len(response_json)))
                self.end_headers()
                self.wfile.write(response_json)
            except Exception as e:
                self.send_error(500, f'Error getting version: {e}')

        def send_tiddlers_response(self):
            """Send the tiddler store JSON"""
            try:
                # Load all tiddlers from the wiki
                all_tiddlers = load_all_tiddlers(wiki_path)
                version = watcher.get_version()

                response_data = {
                    "version": version,
                    "tiddlers": all_tiddlers
                }

                response_json = json.dumps(response_data, ensure_ascii=False).encode('utf-8')

                self.send_response(200)
                self.send_header('Content-Type', 'application/json')
                self.send_header('Content-Length', str(len(response_json)))
                self.end_headers()
                self.wfile.write(response_json)
            except Exception as e:
                self.send_error(500, f'Error getting tiddlers: {e}')

        def send_wiki_html(self):
            """Serve the wiki HTML with injected meta tag"""
            try:
                with open(wiki_path, 'r', encoding='utf-8') as f:
                    content = f.read()

                # Inject meta tag after <head> or at the beginning if no head tag
                meta_tag = '<meta name="tw-server" content="enabled">'

                # Look for <head> tag (case insensitive)
                head_pos = content.lower().find('<head>')
                if head_pos != -1:
                    # Find the end of the <head> tag
                    insert_pos = content.find('>', head_pos) + 1
                    content = content[:insert_pos] + '\n' + meta_tag + content[insert_pos:]
                else:
                    # No head tag, insert at the beginning
                    content = meta_tag + '\n' + content

                content_bytes = content.encode('utf-8')

                self.send_response(200)
                self.send_header('Content-Type', 'text/html; charset=utf-8')
                self.send_header('Content-Length', str(len(content_bytes)))
                self.end_headers()
                self.wfile.write(content_bytes)
            except (ConnectionResetError, BrokenPipeError) as e:
                # Client closed connection - this is normal, just log it
                print(f"[Client disconnected] {e.__class__.__name__}")
            except Exception as e:
                try:
                    self.send_error(500, f'Error reading wiki file: {e}')
                except (ConnectionResetError, BrokenPipeError):
                    # Can't send error if connection is already broken
                    print(f"[Client disconnected during error handling]")

        def send_file(self):
            """Serve a file from the filesystem (for _canonical_uri support)"""
            try:
                # Parse the request path, removing query parameters and fragments
                from urllib.parse import urlparse, unquote
                parsed_path = urlparse(self.path)
                # Decode URL encoding (e.g., %20 -> space)
                file_path = unquote(parsed_path.path)

                # Remove leading slash
                if file_path.startswith('/'):
                    file_path = file_path[1:]

                # Prevent directory traversal attacks
                if '..' in file_path or file_path.startswith('/'):
                    self.send_error(403, 'Access denied')
                    return

                # Resolve path relative to wiki file's directory
                wiki_dir = os.path.dirname(os.path.abspath(wiki_path))
                full_path = os.path.join(wiki_dir, file_path)

                # Normalize the path to resolve any .. or . components
                full_path = os.path.normpath(full_path)

                # Ensure the resolved path is still within wiki_dir
                if not full_path.startswith(wiki_dir):
                    self.send_error(403, 'Access denied')
                    return

                # Check if file exists and is a file (not a directory)
                if not os.path.isfile(full_path):
                    self.send_error(404, 'File not found')
                    return

                # Determine MIME type
                mime_type, _ = mimetypes.guess_type(full_path)
                if mime_type is None:
                    mime_type = 'application/octet-stream'

                # Read and serve the file
                with open(full_path, 'rb') as f:
                    content = f.read()

                self.send_response(200)
                self.send_header('Content-Type', mime_type)
                self.send_header('Content-Length', str(len(content)))
                # Add CORS headers to allow cross-origin requests
                self.send_header('Access-Control-Allow-Origin', '*')
                self.end_headers()
                self.wfile.write(content)

                print(f"[File served] {file_path} ({mime_type}, {len(content)} bytes)")

            except (ConnectionResetError, BrokenPipeError) as e:
                # Client closed connection - this is normal
                print(f"[Client disconnected] {e.__class__.__name__}")
            except Exception as e:
                print(f"[Error serving file] {e}", file=sys.stderr)
                try:
                    self.send_error(500, f'Error serving file: {e}')
                except (ConnectionResetError, BrokenPipeError):
                    print(f"[Client disconnected during error handling]")

        def log_message(self, format, *args):
            """Override to provide cleaner log messages"""
            print(f"[{self.log_date_time_string()}] {format % args}")

    try:
        server = HTTPServer((host, port), WikiHandler)
        if readonly:
            print(f"Serving TiddlyWiki at http://{host}:{port} (READONLY MODE)")
        else:
            print(f"Serving TiddlyWiki at http://{host}:{port}")
        print(f"Wiki file: {wiki_path}")
        if readonly:
            print("Mode: READONLY - save attempts will be rejected")
        print("Press Ctrl+C to stop the server")
        server.serve_forever()
    except KeyboardInterrupt:
        print("\nServer stopped")
        sys.exit(0)
    except OSError as e:
        if e.errno == 48 or e.errno == 98:  # Address already in use
            print(f"Error: Port {port} is already in use", file=sys.stderr)
        else:
            print(f"Error starting server: {e}", file=sys.stderr)
        sys.exit(1)

def main():
    if len(sys.argv) < 2:
        print("Usage: tw [<wiki_path>] <command> [args]", file=sys.stderr)
        print("", file=sys.stderr)
        print("Commands:", file=sys.stderr)
        print("", file=sys.stderr)
        print("  init <dest_path>", file=sys.stderr)
        print("    Create a new empty wiki", file=sys.stderr)
        print("    Example: tw init ~/my-wiki.html", file=sys.stderr)
        print("", file=sys.stderr)
        print("  ls", file=sys.stderr)
        print("    List all tiddlers", file=sys.stderr)
        print("    Example: tw ls", file=sys.stderr)
        print("             tw ~/my-wiki.html ls", file=sys.stderr)
        print("", file=sys.stderr)
        print("  cat <tiddler>", file=sys.stderr)
        print("    Display tiddler contents", file=sys.stderr)
        print("    Example: tw cat \"My Tiddler\"", file=sys.stderr)
        print("             tw ~/my-wiki.html cat Index", file=sys.stderr)
        print("", file=sys.stderr)
        print("  edit <tiddler>", file=sys.stderr)
        print("    Edit tiddler in $EDITOR", file=sys.stderr)
        print("    Example: tw edit \"My Tiddler\"", file=sys.stderr)
        print("             EDITOR=vim tw edit Index", file=sys.stderr)
        print("", file=sys.stderr)
        print("  json <tiddler> [<tiddler2> ...]", file=sys.stderr)
        print("    Output tiddler(s) as JSON", file=sys.stderr)
        print("    Single tiddler returns object, multiple return array", file=sys.stderr)
        print("    Example: tw json \"My Tiddler\"", file=sys.stderr)
        print("             tw json Index | jq .text", file=sys.stderr)
        print("             tw json Tiddler1 Tiddler2 Tiddler3", file=sys.stderr)
        print("", file=sys.stderr)
        print("  get <tiddler> <field>", file=sys.stderr)
        print("    Get a specific field value", file=sys.stderr)
        print("    Example: tw get \"My Tiddler\" text", file=sys.stderr)
        print("             tw get \"My Tiddler\" created", file=sys.stderr)
        print("", file=sys.stderr)
        print("  set <tiddler> <field> <value>", file=sys.stderr)
        print("    Set a field value", file=sys.stderr)
        print("    Example: tw set \"My Tiddler\" text \"New content\"", file=sys.stderr)
        print("             tw set \"My Tiddler\" tags \"tag1 tag2\"", file=sys.stderr)
        print("", file=sys.stderr)
        print("  rm <tiddler>", file=sys.stderr)
        print("    Remove a tiddler", file=sys.stderr)
        print("    Example: tw rm \"My Tiddler\"", file=sys.stderr)
        print("             tw rm \"Temporary Note\"", file=sys.stderr)
        print("", file=sys.stderr)
        print("  touch <tiddler> [text]", file=sys.stderr)
        print("    Create or update a tiddler", file=sys.stderr)
        print("    Example: tw touch \"New Tiddler\"", file=sys.stderr)
        print("             tw touch \"My Note\" \"Initial content\"", file=sys.stderr)
        print("", file=sys.stderr)
        print("  insert <json>", file=sys.stderr)
        print("    Insert/replace tiddler(s) from JSON", file=sys.stderr)
        print("    Accepts single object or array of objects", file=sys.stderr)
        print("    Example: tw insert '{\"title\":\"MyTiddler\",\"text\":\"content\"}'", file=sys.stderr)
        print("             tw json Source | tw insert", file=sys.stderr)
        print("             tw insert '[{\"title\":\"T1\",\"text\":\"a\"},{\"title\":\"T2\",\"text\":\"b\"}]'", file=sys.stderr)
        print("             tw json Tiddler1 Tiddler2 | tw insert  # roundtrip multiple tiddlers", file=sys.stderr)
        print("", file=sys.stderr)
        print("  replace <content>", file=sys.stderr)
        print("    Insert/replace from cat format", file=sys.stderr)
        print("    Example: tw replace \"title: MyTitle\\ntext: content\"", file=sys.stderr)
        print("             tw cat MyTiddler | tw replace", file=sys.stderr)
        print("", file=sys.stderr)
        print("  append <tiddler> [text]", file=sys.stderr)
        print("    Append text to tiddler (from args or stdin)", file=sys.stderr)
        print("    Example: tw append \"My Tiddler\" \"More content\"", file=sys.stderr)
        print("             tw append MyLog some text here", file=sys.stderr)
        print("             echo \"More content\" | tw append \"My Tiddler\"", file=sys.stderr)
        print("", file=sys.stderr)
        print("  detect", file=sys.stderr)
        print("    Detect wiki format (modern or legacy)", file=sys.stderr)
        print("    Example: tw detect", file=sys.stderr)
        print("             tw ~/my-wiki.html detect", file=sys.stderr)
        print("", file=sys.stderr)
        print("  install_plugin", file=sys.stderr)
        print("    Install live reload plugin", file=sys.stderr)
        print("    Example: tw install_plugin", file=sys.stderr)
        print("", file=sys.stderr)
        print("  serve [--host HOST] [--port PORT] [--readonly]", file=sys.stderr)
        print("    Serve wiki locally (default: localhost:8080)", file=sys.stderr)
        print("    --readonly: Disable saving (read-only mode)", file=sys.stderr)
        print("    Example: tw serve", file=sys.stderr)
        print("             tw serve --port 3000", file=sys.stderr)
        print("             tw serve --host 0.0.0.0 --port 8000", file=sys.stderr)
        print("             tw serve --readonly", file=sys.stderr)
        sys.exit(1)

    # Parse arguments: check if first arg is a wiki path or a command
    arg_idx = 1
    wiki_path_arg = None

    # If first arg looks like a file path (ends with .html or exists as a file), treat it as wiki path
    if len(sys.argv) > 2 and (sys.argv[1].endswith('.html') or os.path.exists(sys.argv[1])):
        wiki_path_arg = sys.argv[1]
        arg_idx = 2

    command = sys.argv[arg_idx] if arg_idx < len(sys.argv) else None

    if not command:
        print("Error: No command provided", file=sys.stderr)
        sys.exit(1)

    # Handle 'init' command separately since it doesn't need a wiki path parameter
    if command == "init":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: init command requires a destination path", file=sys.stderr)
            sys.exit(1)
        # init doesn't use wiki_path_arg - it creates a new wiki
        dest_path = sys.argv[arg_idx + 1]
        init_wiki(dest_path)
        return

    wiki_path = get_wiki_path(wiki_path_arg)

    if command == "ls":
        list_tiddlers(wiki_path)
    elif command == "cat":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: cat command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        cat_tiddler(wiki_path, tiddler_title)
    elif command == "edit":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: edit command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        edit_tiddler(wiki_path, tiddler_title)
    elif command == "json":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: json command requires at least one tiddler name", file=sys.stderr)
            sys.exit(1)
        # Collect all remaining arguments as tiddler titles
        tiddler_titles = sys.argv[arg_idx + 1:]
        json_tiddler(wiki_path, *tiddler_titles)
    elif command == "get":
        if arg_idx + 2 >= len(sys.argv):
            print("Error: get command requires a tiddler name and field name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        field_name = sys.argv[arg_idx + 2]
        get_tiddler_field(wiki_path, tiddler_title, field_name)
    elif command == "set":
        if arg_idx + 3 >= len(sys.argv):
            print("Error: set command requires a tiddler name, field name, and value", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        field_name = sys.argv[arg_idx + 2]
        field_value = sys.argv[arg_idx + 3]
        set_tiddler_field(wiki_path, tiddler_title, field_name, field_value)
    elif command == "rm":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: rm command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        remove_tiddler(wiki_path, tiddler_title)
    elif command == "touch":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: touch command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        text = sys.argv[arg_idx + 2] if arg_idx + 2 < len(sys.argv) else ""
        touch_tiddler(wiki_path, tiddler_title, text)
    elif command == "insert":
        # Accept JSON from either command line argument or stdin
        if arg_idx + 1 < len(sys.argv):
            tiddler_json = sys.argv[arg_idx + 1]
        else:
            # Read from stdin
            tiddler_json = sys.stdin.read()
            if not tiddler_json:
                print("Error: insert command requires JSON string or stdin input", file=sys.stderr)
                sys.exit(1)
        insert_tiddler(wiki_path, tiddler_json)
    elif command == "replace":
        # Accept content from either command line argument or stdin
        if arg_idx + 1 < len(sys.argv):
            content = sys.argv[arg_idx + 1]
        else:
            # Read from stdin
            content = sys.stdin.read()
            if not content:
                print("Error: replace command requires content string or stdin input", file=sys.stderr)
                sys.exit(1)
        replace_tiddler(wiki_path, content)
    elif command == "append":
        if arg_idx + 1 >= len(sys.argv):
            print("Error: append command requires a tiddler name", file=sys.stderr)
            sys.exit(1)
        tiddler_title = sys.argv[arg_idx + 1]
        # Check if there are additional arguments for text to append
        if arg_idx + 2 < len(sys.argv):
            # Join all remaining arguments as the text
            text_to_append = ' '.join(sys.argv[arg_idx + 2:])
            append_tiddler(wiki_path, tiddler_title, text_to_append)
        else:
            # No text argument, will read from stdin
            append_tiddler(wiki_path, tiddler_title)
    elif command == "detect":
        # Use streaming detection for efficiency
        format_type = detect_format_streaming(wiki_path)
        print(format_type)
    elif command == "install_plugin":
        install_live_reload_plugin(wiki_path)
    elif command == "serve":
        # Parse optional --host, --port, and --readonly arguments
        host = 'localhost'
        port = 8080
        readonly = False

        i = arg_idx + 1
        while i < len(sys.argv):
            if sys.argv[i] == '--host' and i + 1 < len(sys.argv):
                host = sys.argv[i + 1]
                i += 2
            elif sys.argv[i] == '--port' and i + 1 < len(sys.argv):
                try:
                    port = int(sys.argv[i + 1])
                except ValueError:
                    print(f"Error: Invalid port number '{sys.argv[i + 1]}'", file=sys.stderr)
                    sys.exit(1)
                i += 2
            elif sys.argv[i] == '--readonly':
                readonly = True
                i += 1
            else:
                print(f"Error: Unknown argument '{sys.argv[i]}'", file=sys.stderr)
                print("Usage: tw [<wiki_path>] serve [--host HOST] [--port PORT] [--readonly]", file=sys.stderr)
                sys.exit(1)

        serve_wiki(wiki_path, host, port, readonly)
    else:
        print(f"Error: Unknown command '{command}'", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
