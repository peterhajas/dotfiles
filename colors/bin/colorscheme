#!/usr/bin/env python3
"""
Unified colorscheme management CLI.

Automatically picks light/dark variant based on macOS appearance.
Rebuilds theme files and reloads supporting applications.

Commands:
  colorscheme              # Show current theme
  colorscheme list         # List available families
  colorscheme modus        # Switch to Modus family
  colorscheme ef_melissa   # Switch to Ef Melissa family
  colorscheme catppuccin   # Switch to Catppuccin family
  colorscheme switch       # Interactive picker for theme families

To toggle light/dark mode, use macOS System Settings → Appearance.
Applications will auto-update within 3 seconds.
"""

import sys
import os
import json
import subprocess
from pathlib import Path
from typing import Optional, Dict, Any
import time

# Load the build.py module for palette parsing
DOTFILES = Path(__file__).resolve().parent.parent.parent
sys.path.insert(0, str(DOTFILES / "colors" / ".config" / "colors"))
from build import load_palette, apply_host_override

STATE_FILE = Path.home() / ".config" / "colorscheme" / "current"
PALETTE_FILE = DOTFILES / "colors" / ".config" / "colors" / "palette.toml"

class ColorschemeManager:
    def __init__(self):
        self.palette = apply_host_override(load_palette())
        self.state = self.load_state()

    def load_state(self) -> Dict[str, Any]:
        """Load current theme family from file."""
        if STATE_FILE.exists():
            data = json.loads(STATE_FILE.read_text())
            # Backward compat: accept old format with 'variant', extract family
            return {
                "family": data.get("family", self.palette.get("default_family", "modus"))
            }

        # Default to palette default
        return {
            "family": self.palette.get("default_family", "modus")
        }

    def save_state(self):
        """Save current theme family."""
        STATE_FILE.parent.mkdir(parents=True, exist_ok=True)
        STATE_FILE.write_text(json.dumps(self.state, indent=2))

    def get_macos_appearance(self) -> str:
        """Query macOS for current appearance (light/dark)."""
        try:
            result = subprocess.run(
                ["defaults", "read", "-g", "AppleInterfaceStyle"],
                capture_output=True,
                text=True,
                timeout=1
            )
            if "Dark" in result.stdout:
                return "dark"
        except:
            pass
        return "light"

    def get_current_variant(self) -> Dict[str, Any]:
        """Get current variant based on family + macOS appearance."""
        family = self.state["family"]
        flavor = self.get_macos_appearance()
        variant_name = self.find_variant_by_family_and_flavor(family, flavor)

        if variant_name:
            return self.palette["variants"].get(variant_name, {})

        # Fallback to default variant
        default_variant = self.palette["default_variant"]
        return self.palette["variants"].get(default_variant, {})

    def find_variant_by_family_and_flavor(self, family: str, flavor: str) -> Optional[str]:
        """Find variant name for given family and flavor (light/dark)."""
        family_data = self.palette["families"].get(family)
        if not family_data:
            return None

        if flavor == "light":
            return family_data.get("light_variant")
        elif flavor == "dark":
            return family_data.get("dark_variant")
        return None

    def switch_family(self, family_name: str):
        """Switch to a different theme family."""
        if family_name not in self.palette["families"]:
            print(f"Error: Unknown family '{family_name}'", file=sys.stderr)
            print(f"Available: {', '.join(self.palette['families'].keys())}", file=sys.stderr)
            sys.exit(1)

        self.state["family"] = family_name
        self.save_state()

        # Rebuild theme files and reload applications
        self.rebuild_themes()
        self.reload_all()

    def rebuild_themes(self):
        """Run build.py to regenerate theme files."""
        print("Rebuilding theme files...")
        result = subprocess.run(
            [sys.executable, str(DOTFILES / "colors" / ".config" / "colors" / "build.py")],
            capture_output=True,
            text=True,
            timeout=10
        )
        if result.returncode != 0:
            print(f"Error rebuilding themes:\n{result.stderr}", file=sys.stderr)
            sys.exit(1)
        print(result.stdout.strip())

    def reload_all(self):
        """Reload all applications to apply new theme."""
        variant = self.get_current_variant()
        flavor = variant.get("flavor", "light")
        variant_name = self.find_variant_by_family_and_flavor(self.state["family"], flavor)

        print(f"\nApplying {self.state['family']} family ({flavor} mode: {variant_name})...")

        # 1. Neovim
        self.reload_neovim()

        # 2. Hammerspoon
        self.reload_hammerspoon()

        # 3. Ghostty (reload via SIGUSR2)
        self.reload_ghostty()

        # 4. Zellij (inherits from terminal)
        print("  ✓ Zellij (inherits from terminal)")

        # 5. Ranger (no reload needed, reads on launch)
        print("  ✓ Ranger (will apply on next launch)")

        # 6. Sketchybar
        self.reload_sketchybar()

        print("\n✨ Theme files updated!")

    def reload_neovim(self):
        """Reload Neovim instances."""
        # Neovim watches the state file and auto-reloads via theme.lua
        print("  ✓ Neovim (auto-reloading)")

    def update_ghostty_config(self):
        """Update Ghostty config to use the current theme family."""
        ghostty_config = Path.home() / ".config" / "ghostty" / "config"
        if not ghostty_config.exists():
            return

        family = self.state["family"]
        # Read current config
        lines = ghostty_config.read_text().splitlines()

        # Update theme line
        new_theme_line = f"theme = dark:{family}_dark,light:{family}_light"
        updated = False

        for i, line in enumerate(lines):
            if line.strip().startswith("theme ="):
                lines[i] = new_theme_line
                updated = True
                break

        # If no theme line found, add it
        if not updated:
            lines.append(new_theme_line)

        # Write back
        ghostty_config.write_text("\n".join(lines) + "\n")

    def reload_ghostty(self):
        """Reload Ghostty config via SIGUSR2 signal."""
        # Update the config file first
        self.update_ghostty_config()

        # SIGUSR2 triggers config reload in Ghostty without interrupting the terminal
        result = subprocess.run(["killall", "-SIGUSR2", "ghostty"],
                              stdout=subprocess.DEVNULL,
                              stderr=subprocess.DEVNULL,
                              timeout=2)
        if result.returncode == 0:
            print("  ✓ Ghostty")
        else:
            print("  ⊘ Ghostty (not running)")

    def reload_hammerspoon(self):
        """Reload Hammerspoon colors without full reload."""
        hs_path = "/usr/local/bin/hs"
        if not Path(hs_path).exists():
            hs_path = "/opt/homebrew/bin/hs"
        if Path(hs_path).exists():
            # Trigger color update only, not full reload
            try:
                subprocess.run(
                    [hs_path, "-c", "if colors and colors.checkAndUpdateColors then colors.checkAndUpdateColors() end"],
                    check=False,
                    stderr=subprocess.DEVNULL,
                    timeout=2
                )
                print("  ✓ Hammerspoon (colors updated)")
            except subprocess.TimeoutExpired:
                print("  ⊘ Hammerspoon (timeout)")
        else:
            print("  ⊘ Hammerspoon (not found)")

    def hs_path(self) -> Optional[str]:
        """Return Hammerspoon CLI path if available."""
        hs_path = "/usr/local/bin/hs"
        if not Path(hs_path).exists():
            hs_path = "/opt/homebrew/bin/hs"
        if Path(hs_path).exists():
            return hs_path
        return None

    def reload_sketchybar(self):
        """Reload Sketchybar."""
        sketchybar_path = "/opt/homebrew/bin/sketchybar"
        if Path(sketchybar_path).exists():
            subprocess.run([sketchybar_path, "--reload"], check=False, stderr=subprocess.DEVNULL, timeout=2)
            print("  ✓ Sketchybar")
        else:
            print("  ⊘ Sketchybar (not installed)")

    def show_status(self):
        """Display current theme information."""
        family_name = self.state["family"]
        family_data = self.palette["families"].get(family_name, {})
        flavor = self.get_macos_appearance()

        variant_name = self.find_variant_by_family_and_flavor(family_name, flavor)
        current = self.palette["variants"].get(variant_name, {})

        print(f"Current theme:")
        print(f"  Family:      {family_name} ({family_data.get('name', 'Unknown')})")
        print(f"  macOS Mode:  {flavor}")
        print(f"  Variant:     {variant_name} (auto-selected)")
        print(f"  License:     {family_data.get('license', 'Unknown')}")

    def list_families(self):
        """List all available theme families."""
        current_family = self.state["family"]
        flavor = self.get_macos_appearance()

        print("Available theme families:")
        print()

        for family_name, family_data in sorted(self.palette["families"].items()):
            is_current = " (current)" if family_name == current_family else ""
            print(f"  {family_name}{is_current}")
            print(f"    Name:    {family_data.get('name', 'Unknown')}")
            print(f"    License: {family_data.get('license', 'Unknown')}")

            # Show which variants would be used
            light_variant = family_data.get('light_variant')
            dark_variant = family_data.get('dark_variant')
            print(f"    Light:   {light_variant}")
            print(f"    Dark:    {dark_variant}")
            print()

    def switch_interactive(self):
        """Interactively pick a theme family using the chooser."""
        hs_path = self.hs_path()
        if not hs_path:
            print("Error: Hammerspoon CLI not found (hs).", file=sys.stderr)
            sys.exit(1)

        items = []
        current_family = self.state.get("family")
        flavor = self.get_macos_appearance()

        for family_name, family_data in sorted(self.palette["families"].items()):
            label = family_data.get("name", "Unknown")
            license_name = family_data.get("license", "Unknown")
            light_variant = family_data.get("light_variant", "unknown")
            dark_variant = family_data.get("dark_variant", "unknown")
            variant_name = self.find_variant_by_family_and_flavor(family_name, flavor)
            variant = self.palette["variants"].get(variant_name, {})
            extended = variant.get("extended", {})

            color = extended.get("blue") or variant.get("foreground") or "#000000"
            subcolor = extended.get("fg_dim") or extended.get("fg_alt") or variant.get("foreground") or "#666666"

            text = f"{family_name} — {label}"
            subtext = f"{license_name} • light={light_variant} • dark={dark_variant}"
            items.append(
                {
                    "family": family_name,
                    "text": text,
                    "subtext": subtext,
                    "color": color,
                    "subcolor": subcolor,
                }
            )

        if not items:
            print("No theme families found.", file=sys.stderr)
            sys.exit(1)

        selected_index = None
        if current_family:
            for idx, item in enumerate(items, start=1):
                if item["family"] == current_family:
                    selected_index = idx
                    break

        payload = {
            "items": items,
            "selected_index": selected_index,
        }
        payload_json = json.dumps(payload).replace("\\", "\\\\").replace("'", "\\'")

        lua = (
            "local hs = hs\n"
            "local data = hs.json.decode('" + payload_json + "')\n"
            "local choices = {}\n"
            "for i, item in ipairs(data.items) do\n"
            "  local text = hs.styledtext.new(item.text, { color = { hex = item.color }, font = { name = 'Menlo', size = 16 } })\n"
            "  local sub = hs.styledtext.new(item.subtext, { color = { hex = item.subcolor }, font = { name = 'Menlo', size = 12 } })\n"
            "  table.insert(choices, { text = text, subText = sub, family = item.family })\n"
            "end\n"
            "if _G.colorschemeChooser == nil then\n"
            "  _G.colorschemeChooser = hs.chooser.new(function(choice)\n"
            "    if choice and choice.family then\n"
            "      _G.colorschemeChooserChoice = choice.family\n"
            "    else\n"
            "      _G.colorschemeChooserChoice = 'NOTHING_PICKED_IN_CHOOSER'\n"
            "    end\n"
            "  end)\n"
            "  _G.colorschemeChooser:searchSubText(true)\n"
            "end\n"
            "_G.colorschemeChooserChoice = nil\n"
            "_G.colorschemeChooser:choices(choices)\n"
            "if data.selected_index then _G.colorschemeChooser:selectedRow(data.selected_index) end\n"
            "_G.colorschemeChooser:show()\n"
        )

        subprocess.run([hs_path, "-c", lua], check=False, stderr=subprocess.DEVNULL)

        choice = None
        for _ in range(400):  # ~20s
            out = subprocess.run(
                [hs_path, "-c", "if _G.colorschemeChooserChoice then return _G.colorschemeChooserChoice else return nil end"],
                capture_output=True,
                text=True,
                check=False,
            ).stdout.strip()
            if out and out != "nil":
                choice = out
                break
            time.sleep(0.05)

        if not choice or choice == "NOTHING_PICKED_IN_CHOOSER":
            return

        self.switch_family(choice)


def main():
    if len(sys.argv) == 1:
        # No arguments: show status
        manager = ColorschemeManager()
        manager.show_status()
        return

    command = sys.argv[1]
    manager = ColorschemeManager()

    if command == "list":
        # List available families
        manager.list_families()
    elif command == "switch":
        manager.switch_interactive()
    elif command in manager.palette["families"]:
        # Switch to family (e.g., "modus" or "catppuccin")
        manager.switch_family(command)
    else:
        print(f"Unknown command: {command}", file=sys.stderr)
        print("Usage: colorscheme [list|<family>]", file=sys.stderr)
        print(f"Available families: {', '.join(manager.palette['families'].keys())}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
