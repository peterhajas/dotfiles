#!/usr/bin/env python3
"""
Unified colorscheme management CLI.

Automatically picks light/dark variant based on macOS appearance.
Rebuilds theme files and reloads supporting applications.

Commands:
  colorscheme                    # Show current theme
  colorscheme list               # List available families
  colorscheme modus              # Switch to Modus family
  colorscheme ef_melissa         # Switch to Ef Melissa family
  colorscheme catppuccin         # Switch to Catppuccin family
  colorscheme switch             # Interactive picker for theme families
  colorscheme wallpaper <image>  # Extract colors from image and set as wallpaper

To toggle light/dark mode, use macOS System Settings → Appearance.
Applications will auto-update within 3 seconds.
"""

import sys
import os
import json
import subprocess
from pathlib import Path
from typing import Optional, Dict, Any
import time

# Auto-detect if we need to run via uv for wallpaper dependencies
# This allows the script to work both with and without uv
if len(sys.argv) > 1 and sys.argv[1] == "wallpaper":
    # Check if we're already running via uv (by checking if imports work)
    if "UV_RUN" not in os.environ:
        try:
            import cv2
            import colorgram
        except ImportError:
            # Need to re-exec via uv
            script_path = Path(__file__).resolve()
            config_dir = script_path.parent.parent / ".config" / "colors"
            os.chdir(str(config_dir))
            os.environ["UV_RUN"] = "1"
            os.execvp("uv", ["uv", "run", "python", str(script_path)] + sys.argv[1:])

# Load the build.py module for palette parsing
DOTFILES = Path(__file__).resolve().parent.parent.parent
CONFIG_DIR = DOTFILES / "colors" / ".config" / "colors"
sys.path.insert(0, str(CONFIG_DIR))

from build import load_palette, apply_host_override

# Note: wallpaper functions are imported lazily in methods that use them
# to avoid requiring dependencies for basic colorscheme operations

STATE_FILE = Path.home() / ".config" / "colorscheme" / "current"
PALETTE_FILE = DOTFILES / "colors" / ".config" / "colors" / "palette.toml"

class ColorschemeManager:
    def __init__(self):
        self.palette = apply_host_override(load_palette())
        self.state = self.load_state()

    def load_state(self) -> Dict[str, Any]:
        """Load current theme family from file."""
        if STATE_FILE.exists():
            data = json.loads(STATE_FILE.read_text())
            # Backward compat: accept old format with 'variant', extract family
            return {
                "family": data.get("family", self.palette.get("default_family", "modus"))
            }

        # Default to palette default
        return {
            "family": self.palette.get("default_family", "modus")
        }

    def save_state(self):
        """Save current theme family."""
        STATE_FILE.parent.mkdir(parents=True, exist_ok=True)
        STATE_FILE.write_text(json.dumps(self.state, indent=2))

    def get_macos_appearance(self) -> str:
        """Query macOS for current appearance (light/dark)."""
        try:
            result = subprocess.run(
                ["defaults", "read", "-g", "AppleInterfaceStyle"],
                capture_output=True,
                text=True,
                timeout=1
            )
            if "Dark" in result.stdout:
                return "dark"
        except:
            pass
        return "light"

    def get_current_variant(self) -> Dict[str, Any]:
        """Get current variant based on family + macOS appearance."""
        family = self.state["family"]
        flavor = self.get_macos_appearance()
        variant_name = self.find_variant_by_family_and_flavor(family, flavor)

        if variant_name:
            return self.palette["variants"].get(variant_name, {})

        # Fallback to default variant
        default_variant = self.palette["default_variant"]
        return self.palette["variants"].get(default_variant, {})

    def find_variant_by_family_and_flavor(self, family: str, flavor: str) -> Optional[str]:
        """Find variant name for given family and flavor (light/dark)."""
        family_data = self.palette["families"].get(family)
        if not family_data:
            return None

        if flavor == "light":
            return family_data.get("light_variant")
        elif flavor == "dark":
            return family_data.get("dark_variant")
        return None

    def switch_family(self, family_name: str):
        """Switch to a different theme family."""
        if family_name not in self.palette["families"]:
            print(f"Error: Unknown family '{family_name}'", file=sys.stderr)
            print(f"Available: {', '.join(self.palette['families'].keys())}", file=sys.stderr)
            sys.exit(1)

        self.state["family"] = family_name
        self.save_state()

        # Rebuild theme files and reload applications
        self.rebuild_themes()
        self.reload_all()

    def rebuild_themes(self):
        """Run build.py to regenerate theme files."""
        print("Rebuilding theme files...")
        result = subprocess.run(
            [sys.executable, str(DOTFILES / "colors" / ".config" / "colors" / "build.py")],
            capture_output=True,
            text=True,
            timeout=10
        )
        if result.returncode != 0:
            print(f"Error rebuilding themes:\n{result.stderr}", file=sys.stderr)
            sys.exit(1)
        print(result.stdout.strip())

    def reload_all(self):
        """Reload all applications to apply new theme."""
        variant = self.get_current_variant()
        flavor = variant.get("flavor", "light")
        variant_name = self.find_variant_by_family_and_flavor(self.state["family"], flavor)

        print(f"\nApplying {self.state['family']} family ({flavor} mode: {variant_name})...")

        # 1. Neovim
        self.reload_neovim()

        # 2. Hammerspoon
        self.reload_hammerspoon()

        # 3. Ghostty (reload via SIGUSR2)
        self.reload_ghostty()

        # 4. Zellij (inherits from terminal)
        print("  ✓ Zellij (inherits from terminal)")

        # 5. Ranger (no reload needed, reads on launch)
        print("  ✓ Ranger (will apply on next launch)")

        # 6. Sketchybar
        self.reload_sketchybar()

        print("\n✨ Theme files updated!")

    def reload_neovim(self):
        """Reload Neovim instances."""
        # Neovim watches the state file and auto-reloads via theme.lua
        print("  ✓ Neovim (auto-reloading)")

    def update_ghostty_config(self):
        """Update Ghostty config to use the current theme family."""
        ghostty_config = Path.home() / ".config" / "ghostty" / "config"
        if not ghostty_config.exists():
            return

        family = self.state["family"]
        # Read current config
        lines = ghostty_config.read_text().splitlines()

        # Update theme line
        new_theme_line = f"theme = dark:{family}_dark,light:{family}_light"
        updated = False

        for i, line in enumerate(lines):
            if line.strip().startswith("theme ="):
                lines[i] = new_theme_line
                updated = True
                break

        # If no theme line found, add it
        if not updated:
            lines.append(new_theme_line)

        # Write back
        ghostty_config.write_text("\n".join(lines) + "\n")

    def reload_ghostty(self):
        """Reload Ghostty config via SIGUSR2 signal."""
        # Note: Ghostty does not currently support per-window colorschemes.
        # Theme changes apply globally to all windows.
        # Monitor https://github.com/ghostty-org/ghostty for future support.

        # Update the config file first
        self.update_ghostty_config()

        # SIGUSR2 triggers config reload in Ghostty without interrupting the terminal
        result = subprocess.run(["killall", "-SIGUSR2", "ghostty"],
                              stdout=subprocess.DEVNULL,
                              stderr=subprocess.DEVNULL,
                              timeout=2)
        if result.returncode == 0:
            print("  ✓ Ghostty")
        else:
            print("  ⊘ Ghostty (not running)")

    def reload_hammerspoon(self):
        """Reload Hammerspoon colors without full reload."""
        hs_path = "/usr/local/bin/hs"
        if not Path(hs_path).exists():
            hs_path = "/opt/homebrew/bin/hs"
        if Path(hs_path).exists():
            # Trigger color update only, not full reload
            try:
                subprocess.run(
                    [hs_path, "-c", "if colors and colors.checkAndUpdateColors then colors.checkAndUpdateColors() end"],
                    check=False,
                    stderr=subprocess.DEVNULL,
                    timeout=2
                )
                print("  ✓ Hammerspoon (colors updated)")
            except subprocess.TimeoutExpired:
                print("  ⊘ Hammerspoon (timeout)")
        else:
            print("  ⊘ Hammerspoon (not found)")

    def hs_path(self) -> Optional[str]:
        """Return Hammerspoon CLI path if available."""
        hs_path = "/usr/local/bin/hs"
        if not Path(hs_path).exists():
            hs_path = "/opt/homebrew/bin/hs"
        if Path(hs_path).exists():
            return hs_path
        return None

    def reload_sketchybar(self):
        """Reload Sketchybar."""
        sketchybar_path = "/opt/homebrew/bin/sketchybar"
        if Path(sketchybar_path).exists():
            subprocess.run([sketchybar_path, "--reload"], check=False, stderr=subprocess.DEVNULL, timeout=2)
            print("  ✓ Sketchybar")
        else:
            print("  ⊘ Sketchybar (not installed)")

    def wallpaper_from_image(self, image_path: str):
        """Extract colorscheme from image and set as wallpaper."""
        from datetime import datetime

        # Lazy import wallpaper functions
        try:
            from wallpaper import extract_color_palette, set_wallpaper, should_tile, upscale_to_4k
        except ImportError as e:
            print(f"Error: Wallpaper features require dependencies.", file=sys.stderr)
            print(f"Run: cd {CONFIG_DIR} && uv sync", file=sys.stderr)
            print(f"Then run via: cd {CONFIG_DIR} && uv run python {Path(__file__).resolve()} wallpaper {image_path}", file=sys.stderr)
            sys.exit(1)

        img_path = Path(image_path).expanduser().resolve()
        if not img_path.exists():
            print(f"Error: Image not found: {image_path}", file=sys.stderr)
            sys.exit(1)

        print(f"Extracting colors from {img_path.name}...")

        # Generate family and variant names
        generated_at = datetime.now().isoformat()
        family_name = "from_wallpaper"
        variant_light = f"{family_name}_light"
        variant_dark = f"{family_name}_dark"

        # Extract color palette
        try:
            palette_data = extract_color_palette(img_path, variant_light, variant_dark)
        except Exception as e:
            print(f"Error extracting colors: {e}", file=sys.stderr)
            sys.exit(1)

        # Clean up old from_wallpaper palettes
        palettes_dir = DOTFILES / "colors" / ".config" / "colors" / "palettes"
        for old_palette in palettes_dir.glob("from_wallpaper_*.toml"):
            old_palette.unlink()
            print(f"Removed old palette: {old_palette.name}")

        ghostty_themes_dir = DOTFILES / "ghostty" / ".config" / "ghostty" / "themes"
        if ghostty_themes_dir.exists():
            for old_theme in ghostty_themes_dir.glob("from_wallpaper_*"):
                if old_theme.name in {"from_wallpaper_dark", "from_wallpaper_light"}:
                    continue
                old_theme.unlink()
                print(f"Removed old Ghostty theme: {old_theme.name}")

        # Create TOML file
        toml_file = palettes_dir / f"{family_name}.toml"

        toml_content = f"""# Generated from {img_path.name} on {generated_at}

[families.{family_name}]
name = 'From Wallpaper'
license = 'Custom'
light_variant = '{variant_light}'
dark_variant = '{variant_dark}'

[variants.{variant_light}]
family = '{family_name}'
flavor = 'light'
{palette_data['light_toml']}
{palette_data['light_extended']}
[variants.{variant_dark}]
family = '{family_name}'
flavor = 'dark'
{palette_data['dark_toml']}
{palette_data['dark_extended']}
"""

        toml_file.write_text(toml_content)
        print(f"Created palette: {toml_file.name}")

        # Reload palette
        self.palette = apply_host_override(load_palette())

        # Switch to new family
        self.state["family"] = family_name
        self.save_state()

        # Rebuild themes
        self.rebuild_themes()

        # Handle wallpaper: tile if small, otherwise upscale to 4K
        tile = should_tile(img_path)
        wallpapers_dir = DOTFILES / "colors" / "wallpapers" / "generated"
        wallpapers_dir.mkdir(parents=True, exist_ok=True)

        if tile:
            # Small pattern - just set it to tile
            set_wallpaper(img_path, tile=True)
            print(f"  ✓ Wallpaper (tiled pattern)")
        else:
            # Large image - upscale to 4K if needed
            for old_wallpaper in wallpapers_dir.glob("from_wallpaper_*.png"):
                old_wallpaper.unlink()
                print(f"Removed old wallpaper: {old_wallpaper.name}")
            upscaled_path = wallpapers_dir / "from_wallpaper_4k.png"
            upscale_to_4k(img_path, upscaled_path)
            set_wallpaper(upscaled_path, tile=False)
            print(f"  ✓ Wallpaper (upscaled to 4K)")

        # Reload apps
        self.reload_all()

    def show_status(self):
        """Display current theme information."""
        family_name = self.state["family"]
        family_data = self.palette["families"].get(family_name, {})
        flavor = self.get_macos_appearance()

        variant_name = self.find_variant_by_family_and_flavor(family_name, flavor)
        current = self.palette["variants"].get(variant_name, {})

        print(f"Current theme:")
        print(f"  Family:      {family_name} ({family_data.get('name', 'Unknown')})")
        print(f"  macOS Mode:  {flavor}")
        print(f"  Variant:     {variant_name} (auto-selected)")
        print(f"  License:     {family_data.get('license', 'Unknown')}")

    def list_families(self):
        """List all available theme families."""
        current_family = self.state["family"]
        flavor = self.get_macos_appearance()

        print("Available theme families:")
        print()

        for family_name, family_data in sorted(self.palette["families"].items()):
            is_current = " (current)" if family_name == current_family else ""
            print(f"  {family_name}{is_current}")
            print(f"    Name:    {family_data.get('name', 'Unknown')}")
            print(f"    License: {family_data.get('license', 'Unknown')}")

            # Show which variants would be used
            light_variant = family_data.get('light_variant')
            dark_variant = family_data.get('dark_variant')
            print(f"    Light:   {light_variant}")
            print(f"    Dark:    {dark_variant}")
            print()

    def switch_interactive(self):
        """Interactively pick a theme family using the chooser."""
        hs_path = self.hs_path()
        if not hs_path:
            print("Error: Hammerspoon CLI not found (hs).", file=sys.stderr)
            sys.exit(1)

        items = []
        current_family = self.state.get("family")
        flavor = self.get_macos_appearance()

        for family_name, family_data in sorted(self.palette["families"].items()):
            label = family_data.get("name", "Unknown")
            license_name = family_data.get("license", "Unknown")
            light_variant = family_data.get("light_variant", "unknown")
            dark_variant = family_data.get("dark_variant", "unknown")
            variant_name = self.find_variant_by_family_and_flavor(family_name, flavor)
            variant = self.palette["variants"].get(variant_name, {})
            extended = variant.get("extended", {})

            color = extended.get("blue") or variant.get("foreground") or "#000000"
            subcolor = extended.get("fg_dim") or extended.get("fg_alt") or variant.get("foreground") or "#666666"

            text = f"{family_name} — {label}"
            subtext = f"{license_name} • light={light_variant} • dark={dark_variant}"
            items.append(
                {
                    "family": family_name,
                    "text": text,
                    "subtext": subtext,
                    "color": color,
                    "subcolor": subcolor,
                }
            )

        if not items:
            print("No theme families found.", file=sys.stderr)
            sys.exit(1)

        selected_index = None
        if current_family:
            for idx, item in enumerate(items, start=1):
                if item["family"] == current_family:
                    selected_index = idx
                    break

        payload = {
            "items": items,
            "selected_index": selected_index,
        }
        payload_json = json.dumps(payload).replace("\\", "\\\\").replace("'", "\\'")

        lua = (
            "local hs = hs\n"
            "local data = hs.json.decode('" + payload_json + "')\n"
            "local choices = {}\n"
            "for i, item in ipairs(data.items) do\n"
            "  local text = hs.styledtext.new(item.text, { color = { hex = item.color }, font = { name = 'Menlo', size = 16 } })\n"
            "  local sub = hs.styledtext.new(item.subtext, { color = { hex = item.subcolor }, font = { name = 'Menlo', size = 12 } })\n"
            "  table.insert(choices, { text = text, subText = sub, family = item.family })\n"
            "end\n"
            "if _G.colorschemeChooser == nil then\n"
            "  _G.colorschemeChooser = hs.chooser.new(function(choice)\n"
            "    if choice and choice.family then\n"
            "      _G.colorschemeChooserChoice = choice.family\n"
            "    else\n"
            "      _G.colorschemeChooserChoice = 'NOTHING_PICKED_IN_CHOOSER'\n"
            "    end\n"
            "  end)\n"
            "  _G.colorschemeChooser:searchSubText(true)\n"
            "end\n"
            "_G.colorschemeChooserChoice = nil\n"
            "_G.colorschemeChooser:choices(choices)\n"
            "if data.selected_index then _G.colorschemeChooser:selectedRow(data.selected_index) end\n"
            "_G.colorschemeChooser:show()\n"
        )

        subprocess.run([hs_path, "-c", lua], check=False, stderr=subprocess.DEVNULL)

        choice = None
        for _ in range(400):  # ~20s
            out = subprocess.run(
                [hs_path, "-c", "if _G.colorschemeChooserChoice then return _G.colorschemeChooserChoice else return nil end"],
                capture_output=True,
                text=True,
                check=False,
            ).stdout.strip()
            if out and out != "nil":
                choice = out
                break
            time.sleep(0.05)

        if not choice or choice == "NOTHING_PICKED_IN_CHOOSER":
            return

        self.switch_family(choice)


def main():
    if len(sys.argv) == 1:
        # No arguments: show status
        manager = ColorschemeManager()
        manager.show_status()
        return

    command = sys.argv[1]
    manager = ColorschemeManager()

    if command == "list":
        # List available families
        manager.list_families()
    elif command == "switch":
        manager.switch_interactive()
    elif command == "wallpaper":
        if len(sys.argv) < 3:
            print("Usage: colorscheme wallpaper <image_path>", file=sys.stderr)
            sys.exit(1)
        manager.wallpaper_from_image(sys.argv[2])
    elif command in manager.palette["families"]:
        # Switch to family (e.g., "modus" or "catppuccin")
        manager.switch_family(command)
    else:
        print(f"Unknown command: {command}", file=sys.stderr)
        print("Usage: colorscheme [list|switch|wallpaper <image>|<family>]", file=sys.stderr)
        print(f"Available families: {', '.join(manager.palette['families'].keys())}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
