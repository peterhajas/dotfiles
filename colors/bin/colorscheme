#!/usr/bin/env python3
"""
Unified colorscheme management CLI.

Automatically picks light/dark variant based on macOS appearance.
Rebuilds theme files and reloads supporting applications.

Commands:
  colorscheme              # Show current theme
  colorscheme list         # List available families
  colorscheme modus        # Switch to Modus family
  colorscheme catppuccin   # Switch to Catppuccin family

To toggle light/dark mode, use macOS System Settings → Appearance.
Applications will auto-update within 3 seconds.
"""

import sys
import os
import json
import subprocess
from pathlib import Path
from typing import Optional, Dict, Any

# Load the build.py module for palette parsing
DOTFILES = Path(__file__).resolve().parent.parent.parent
sys.path.insert(0, str(DOTFILES / "colors" / ".config" / "colors"))
from build import load_palette, apply_host_override

STATE_FILE = Path.home() / ".config" / "colorscheme" / "current"
PALETTE_FILE = DOTFILES / "colors" / ".config" / "colors" / "palette.toml"

class ColorschemeManager:
    def __init__(self):
        self.palette = apply_host_override(load_palette())
        self.state = self.load_state()

    def load_state(self) -> Dict[str, Any]:
        """Load current theme family from file."""
        if STATE_FILE.exists():
            data = json.loads(STATE_FILE.read_text())
            # Backward compat: accept old format with 'variant', extract family
            return {
                "family": data.get("family", self.palette.get("default_family", "modus"))
            }

        # Default to palette default
        return {
            "family": self.palette.get("default_family", "modus")
        }

    def save_state(self):
        """Save current theme family."""
        STATE_FILE.parent.mkdir(parents=True, exist_ok=True)
        STATE_FILE.write_text(json.dumps(self.state, indent=2))

    def get_macos_appearance(self) -> str:
        """Query macOS for current appearance (light/dark)."""
        try:
            result = subprocess.run(
                ["defaults", "read", "-g", "AppleInterfaceStyle"],
                capture_output=True,
                text=True,
                timeout=1
            )
            if "Dark" in result.stdout:
                return "dark"
        except:
            pass
        return "light"

    def get_current_variant(self) -> Dict[str, Any]:
        """Get current variant based on family + macOS appearance."""
        family = self.state["family"]
        flavor = self.get_macos_appearance()
        variant_name = self.find_variant_by_family_and_flavor(family, flavor)

        if variant_name:
            return self.palette["variants"].get(variant_name, {})

        # Fallback to default variant
        default_variant = self.palette["default_variant"]
        return self.palette["variants"].get(default_variant, {})

    def find_variant_by_family_and_flavor(self, family: str, flavor: str) -> Optional[str]:
        """Find variant name for given family and flavor (light/dark)."""
        family_data = self.palette["families"].get(family)
        if not family_data:
            return None

        if flavor == "light":
            return family_data.get("light_variant")
        elif flavor == "dark":
            return family_data.get("dark_variant")
        return None

    def switch_family(self, family_name: str):
        """Switch to a different theme family."""
        if family_name not in self.palette["families"]:
            print(f"Error: Unknown family '{family_name}'", file=sys.stderr)
            print(f"Available: {', '.join(self.palette['families'].keys())}", file=sys.stderr)
            sys.exit(1)

        self.state["family"] = family_name
        self.save_state()

        # Rebuild theme files and reload applications
        self.rebuild_themes()
        self.reload_all()

    def rebuild_themes(self):
        """Run build.py to regenerate theme files."""
        print("Rebuilding theme files...")
        result = subprocess.run(
            [sys.executable, str(DOTFILES / "colors" / ".config" / "colors" / "build.py")],
            capture_output=True,
            text=True,
            timeout=10
        )
        if result.returncode != 0:
            print(f"Error rebuilding themes:\n{result.stderr}", file=sys.stderr)
            sys.exit(1)
        print(result.stdout.strip())

    def reload_all(self):
        """Reload all applications to apply new theme."""
        variant = self.get_current_variant()
        flavor = variant.get("flavor", "light")
        variant_name = self.find_variant_by_family_and_flavor(self.state["family"], flavor)

        print(f"\nApplying {self.state['family']} family ({flavor} mode: {variant_name})...")

        # 1. Neovim
        self.reload_neovim()

        # 2. Hammerspoon
        self.reload_hammerspoon()

        # 3. Ghostty (reload via SIGUSR2)
        self.reload_ghostty()

        # 4. Zellij (inherits from terminal)
        print("  ✓ Zellij (inherits from terminal)")

        # 5. Ranger (no reload needed, reads on launch)
        print("  ✓ Ranger (will apply on next launch)")

        # 6. Sketchybar
        self.reload_sketchybar()

        print("\n✨ Theme files updated!")

    def reload_neovim(self):
        """Reload Neovim instances."""
        # Neovim watches the state file and auto-reloads via theme.lua
        print("  ✓ Neovim (auto-reloading)")

    def update_ghostty_config(self):
        """Update Ghostty config to use the current theme family."""
        ghostty_config = Path.home() / ".config" / "ghostty" / "config"
        if not ghostty_config.exists():
            return

        family = self.state["family"]
        # Read current config
        lines = ghostty_config.read_text().splitlines()

        # Update theme line
        new_theme_line = f"theme = dark:{family}_dark,light:{family}_light"
        updated = False

        for i, line in enumerate(lines):
            if line.strip().startswith("theme ="):
                lines[i] = new_theme_line
                updated = True
                break

        # If no theme line found, add it
        if not updated:
            lines.append(new_theme_line)

        # Write back
        ghostty_config.write_text("\n".join(lines) + "\n")

    def reload_ghostty(self):
        """Reload Ghostty config via SIGUSR2 signal."""
        # Update the config file first
        self.update_ghostty_config()

        # SIGUSR2 triggers config reload in Ghostty without interrupting the terminal
        result = subprocess.run(["killall", "-SIGUSR2", "ghostty"],
                              stdout=subprocess.DEVNULL,
                              stderr=subprocess.DEVNULL,
                              timeout=2)
        if result.returncode == 0:
            print("  ✓ Ghostty")
        else:
            print("  ⊘ Ghostty (not running)")

    def reload_hammerspoon(self):
        """Reload Hammerspoon colors without full reload."""
        hs_path = "/usr/local/bin/hs"
        if not Path(hs_path).exists():
            hs_path = "/opt/homebrew/bin/hs"
        if Path(hs_path).exists():
            # Trigger color update only, not full reload
            try:
                subprocess.run(
                    [hs_path, "-c", "if colors and colors.checkAndUpdateColors then colors.checkAndUpdateColors() end"],
                    check=False,
                    stderr=subprocess.DEVNULL,
                    timeout=2
                )
                print("  ✓ Hammerspoon (colors updated)")
            except subprocess.TimeoutExpired:
                print("  ⊘ Hammerspoon (timeout)")
        else:
            print("  ⊘ Hammerspoon (not found)")


    def reload_sketchybar(self):
        """Reload Sketchybar."""
        sketchybar_path = "/opt/homebrew/bin/sketchybar"
        if Path(sketchybar_path).exists():
            subprocess.run([sketchybar_path, "--reload"], check=False, stderr=subprocess.DEVNULL, timeout=2)
            print("  ✓ Sketchybar")
        else:
            print("  ⊘ Sketchybar (not installed)")

    def show_status(self):
        """Display current theme information."""
        family_name = self.state["family"]
        family_data = self.palette["families"].get(family_name, {})
        flavor = self.get_macos_appearance()

        variant_name = self.find_variant_by_family_and_flavor(family_name, flavor)
        current = self.palette["variants"].get(variant_name, {})

        print(f"Current theme:")
        print(f"  Family:      {family_name} ({family_data.get('name', 'Unknown')})")
        print(f"  macOS Mode:  {flavor}")
        print(f"  Variant:     {variant_name} (auto-selected)")
        print(f"  License:     {family_data.get('license', 'Unknown')}")

    def list_families(self):
        """List all available theme families."""
        current_family = self.state["family"]
        flavor = self.get_macos_appearance()

        print("Available theme families:")
        print()

        for family_name, family_data in sorted(self.palette["families"].items()):
            is_current = " (current)" if family_name == current_family else ""
            print(f"  {family_name}{is_current}")
            print(f"    Name:    {family_data.get('name', 'Unknown')}")
            print(f"    License: {family_data.get('license', 'Unknown')}")

            # Show which variants would be used
            light_variant = family_data.get('light_variant')
            dark_variant = family_data.get('dark_variant')
            print(f"    Light:   {light_variant}")
            print(f"    Dark:    {dark_variant}")
            print()


def main():
    if len(sys.argv) == 1:
        # No arguments: show status
        manager = ColorschemeManager()
        manager.show_status()
        return

    command = sys.argv[1]
    manager = ColorschemeManager()

    if command == "list":
        # List available families
        manager.list_families()
    elif command in manager.palette["families"]:
        # Switch to family (e.g., "modus" or "catppuccin")
        manager.switch_family(command)
    else:
        print(f"Unknown command: {command}", file=sys.stderr)
        print("Usage: colorscheme [list|<family>]", file=sys.stderr)
        print(f"Available families: {', '.join(manager.palette['families'].keys())}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
