#!/usr/bin/env python3

import json
import subprocess
import sys
from typing import Any, Dict, List, Optional

# Constants
EDGE_PADDING = 14
PADDING = 20
WIDGET_PADDING = 194 + EDGE_PADDING
ULTRAWIDE_THRESHOLD = 2000  # plh-evil

# Layout tuning
BUCKET_WEIGHTS = {"left": 1.0, "center": 2.0, "right": 1.0}  # Adjust to change relative widths
SIDE_MAX_WIDTH_PX: Optional[int] = 1080  # Cap left/right widths in pixels (when present with center); set to None to disable
GRID_COLUMNS = 100  # Grid resolution for column calculations (higher -> finer control)


def run_json(cmd: List[str]) -> Optional[Any]:
    try:
        out = subprocess.check_output(cmd, stderr=subprocess.DEVNULL)
        return json.loads(out)
    except Exception:
        return None


def run_cmd(cmd: List[str]) -> None:
    subprocess.run(cmd, check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)


def get_display_by_index(displays: List[Dict[str, Any]], idx: int) -> Optional[Dict[str, Any]]:
    for d in displays:
        if d.get("index") == idx:
            return d
    return None


def move_window_to_display(win_id: int, target_display: int) -> None:
    if target_display is None:
        return
    try:
        win_json = run_json(["yabai", "-m", "query", "--windows", "--window", str(win_id)])
        if not win_json:
            return
        if win_json.get("display") == target_display:
            return
    except Exception:
        return
    run_cmd(["yabai", "-m", "window", str(win_id), "--display", str(target_display)])


def apply_grid(win_id: int, rows: int, col: int, row: int, span: int) -> None:
    run_cmd(["yabai", "-m", "window", str(win_id), "--grid", f"{rows}:{GRID_COLUMNS}:{col}:{row}:{span}:1"])


def apply_bucket(windows: List[int], col: int, span: int) -> None:
    rows = max(1, len(windows))
    for idx, win in enumerate(windows):
        apply_grid(win, rows, col, idx, span)


def overlap_region(windows: List[int], col: int, span: int) -> None:
    for win in windows:
        apply_grid(win, 1, col, 0, span)


def compute_bucket_widths(buckets_present: List[str], display_width: float) -> Dict[str, float]:
    if not buckets_present or display_width <= 0:
        return {}

    total_weight = sum(BUCKET_WEIGHTS.get(bucket, 1.0) for bucket in buckets_present)
    widths = {
        bucket: display_width * (BUCKET_WEIGHTS.get(bucket, 1.0) / total_weight)
        for bucket in buckets_present
    }

    if SIDE_MAX_WIDTH_PX is not None and "center" in buckets_present:
        max_width = float(SIDE_MAX_WIDTH_PX)
        for side in ("left", "right"):
            if side in widths:
                widths[side] = min(widths[side], max_width)

        side_total = sum(widths[bucket] for bucket in ("left", "right") if bucket in widths)
        if side_total >= display_width:
            # sides eat the whole space; scale them down evenly
            scale = display_width / max(side_total, 1.0)
            for side in ("left", "right"):
                if side in widths:
                    widths[side] *= scale
            widths["center"] = 0.0
        else:
            widths["center"] = display_width - side_total

    total_after = sum(widths.values())
    if "center" not in buckets_present and total_after > 0:
        # scale to fill the available space when only sides are present
        scale = display_width / total_after
        for bucket in widths:
            widths[bucket] *= scale

    return widths


def bucket_layout(buckets_present: List[str], display_width: float) -> Dict[str, Dict[str, int]]:
    widths = compute_bucket_widths(buckets_present, display_width)
    order = [bucket for bucket in ("left", "center", "right") if bucket in widths]
    if not order or display_width <= 0:
        return {}

    raw_spans = [
        (widths[bucket] / display_width) * GRID_COLUMNS
        for bucket in order
    ]
    spans = [max(1, int(value)) for value in raw_spans]
    diff = GRID_COLUMNS - sum(spans)

    remainders = [value - int(value) for value in raw_spans]
    while diff != 0:
        if diff > 0:
            idx = max(range(len(order)), key=lambda i: remainders[i])
            spans[idx] += 1
            diff -= 1
        else:
            candidates = [i for i, span in enumerate(spans) if span > 1]
            if not candidates:
                break
            idx = max(candidates, key=lambda i: spans[i])
            spans[idx] -= 1
            diff += 1

    final_layout: Dict[str, Dict[str, int]] = {}
    col = 0
    for bucket, span in zip(order, spans):
        final_layout[bucket] = {"col": col, "span": span}
        col += span

    # ensure total columns are consumed
    total_assigned = sum(span for span in spans)
    if total_assigned != GRID_COLUMNS and order:
        adjust_bucket = "center" if "center" in final_layout else order[-1]
        adjustment = GRID_COLUMNS - total_assigned
        final_layout[adjust_bucket]["span"] = max(1, final_layout[adjust_bucket]["span"] + adjustment)

    return final_layout


def is_special_sysmon(win: Dict[str, Any]) -> bool:
    title = win.get("title", "")
    return "sysmon" in title.lower()


def is_special_ai(win: Dict[str, Any]) -> bool:
    app = win.get("app", "")
    title = win.get("title", "")
    low_app = app.lower()
    low_title = title.lower()
    if any(
        key in low_app
        for key in ["claude", "chatgpt", "codex", "openai"]
    ):
        return True
    return low_title.startswith("claude") or low_title.startswith("codex") or low_title.startswith("chatgpt")


def ensure_managed(win_id: int) -> None:
    info = run_json(["yabai", "-m", "query", "--windows", "--window", str(win_id)]) or {}
    if info.get("floating") == 1:
        # toggle to managed so grid placement works
        run_cmd(["yabai", "-m", "window", str(win_id), "--toggle", "float"])


def main() -> None:
    displays = run_json(["yabai", "-m", "query", "--displays"])
    spaces = run_json(["yabai", "-m", "query", "--spaces"])
    windows = run_json(["yabai", "-m", "query", "--windows"])

    if not displays or not spaces or windows is None:
        sys.exit(0)

    # Set geometry
    run_cmd(["yabai", "-m", "config", "window_gap", str(PADDING)])

    # Find widest display over threshold
    ultra_display = None
    widest = max(displays, key=lambda d: d.get("frame", {}).get("w", 0))
    if widest.get("frame", {}).get("w", 0) >= ULTRAWIDE_THRESHOLD:
        ultra_display = widest

    ultra_index = ultra_display.get("index") if ultra_display else None

    # Space layouts/padding
    for space in spaces:
        space_index = space.get("index")
        space_display = space.get("display")
        pad_right = WIDGET_PADDING if space_index == 1 else 0
        layout = "stack" if space_index == 1 else "bsp"
        # For ultrawide spaces, float layout so manual 25/50/25 grids are not retiled by bsp/stack
        if ultra_index is not None and space_display == ultra_index:
            layout = "float"

        run_cmd(
            [
                "yabai",
                "-m",
                "config",
                "--space",
                str(space_index),
                "layout",
                layout,
                "top_padding",
                "0",
                "bottom_padding",
                "0",
                "left_padding",
                "0",
                "right_padding",
                str(pad_right),
            ]
        )

    # apply all rules
    run_cmd(["yabai", "-m", "rule", "--apply"])

    # Special windows
    rightmost_display = sorted(displays, key=lambda d: d.get("frame", {}).get("x", 0))[-1].get("index")
    leftmost_display = sorted(displays, key=lambda d: d.get("frame", {}).get("x", 0))[0].get("index")
    num_displays = len(displays)

    sysmon_windows = [w for w in windows if is_special_sysmon(w)]
    ai_windows = [w for w in windows if is_special_ai(w)]

    if ultra_index is not None:
        for win in sysmon_windows + ai_windows:
            wid = win.get("id")
            move_window_to_display(wid, ultra_index)
            ensure_managed(wid)
    elif num_displays > 1:
        for win in sysmon_windows:
            wid = win.get("id")
            move_window_to_display(wid, rightmost_display)
            apply_grid(wid, 1, 0, 0, max(1, GRID_COLUMNS // 4))
        for win in ai_windows:
            wid = win.get("id")
            move_window_to_display(wid, leftmost_display)

    # Refresh windows after special moves
    windows = run_json(["yabai", "-m", "query", "--windows"]) or []

    # 25/50/25 tiling for ultrawide
    if ultra_index is not None:
        ultra_frame = ultra_display.get("frame", {})
        ultra_x = ultra_frame.get("x", 0)
        ultra_w = ultra_frame.get("w", 1)
        left_boundary = ultra_x + (ultra_w * 0.25)
        right_boundary = ultra_x + (ultra_w * 0.75)

        ultra_space_ids = [s.get("index") for s in spaces if s.get("display") == ultra_index]

        for space_id in ultra_space_ids:
            space_windows: List[Dict[str, Any]] = []
            left_bucket: List[Dict[str, Any]] = []
            center_bucket: List[Dict[str, Any]] = []
            right_bucket: List[Dict[str, Any]] = []

            for win in windows:
                if win.get("display") != ultra_index or win.get("space") != space_id:
                    continue
                is_sysmon = is_special_sysmon(win)
                is_ai = is_special_ai(win)
                if win.get("minimized") == 1:
                    continue
                if win.get("floating") == 1:
                    # Make sure floating windows get managed so grid placement works
                    ensure_managed(win.get("id"))
                if win.get("is-visible") is False or win.get("is-hidden") is True:
                    # Ignore windows that are hidden/invisible so they don't reserve space
                    continue
                space_windows.append(win)

            if not space_windows:
                continue

            # Bucket by region with special pinning
            for win in space_windows:
                is_sysmon = is_special_sysmon(win)
                is_ai = is_special_ai(win)
                # Hard-assign buckets by type; everything else goes center
                if is_ai:
                    left_bucket.append(win)
                elif is_sysmon:
                    right_bucket.append(win)
                else:
                    center_bucket.append(win)

            if left_bucket:
                # AI prioritized then alphabetical within this space
                left_sorted = sorted(
                    left_bucket,
                    key=lambda w: (
                        0 if is_special_ai(w) else 1,
                        (w.get("title") or w.get("app") or "").lower(),
                        w.get("id", 0),
                    ),
                )
            right_sorted = sorted(
                right_bucket,
                key=lambda w: (
                    0 if is_special_sysmon(w) else 1,
                    (w.get("title") or w.get("app") or "").lower(),
                    w.get("id", 0),
                ),
            )

            present_buckets = [
                name
                for name, bucket in (
                    ("left", left_bucket),
                    ("center", center_bucket),
                    ("right", right_bucket),
                )
                if bucket
            ]

            layout = bucket_layout(present_buckets, ultra_w)
            if not layout:
                continue

            if left_bucket and "left" in layout:
                apply_bucket(
                    [w.get("id") for w in left_sorted],
                    layout["left"]["col"],
                    layout["left"]["span"],
                )
            if center_bucket and "center" in layout:
                overlap_region(
                    [w.get("id") for w in center_bucket],
                    layout["center"]["col"],
                    layout["center"]["span"],
                )
            if right_bucket and "right" in layout:
                apply_bucket(
                    [w.get("id") for w in right_sorted],
                    layout["right"]["col"],
                    layout["right"]["span"],
                )


if __name__ == "__main__":
    main()
