#!/usr/bin/env python3

import argparse
import atexit
import fcntl
import json
import os
import subprocess
import sys
import time
from typing import Any, Dict, List, Optional, Tuple
import re
import math

# Verbose logging flag (set via command line)
VERBOSE = False


def log(message: str) -> None:
    """Print a log message if verbose mode is enabled."""
    if VERBOSE:
        print(f"[yabai_update_tiling] {message}")

# Constants
SUBPROCESS_TIMEOUT = 5.0
ULTRAWIDE_THRESHOLD = 2000  # plh-evil
WORKSPACE_WIDTH_THRESHOLD = 5000  # Switch to 5-bucket layout when total width exceeds this
LOCK_ENV_SKIP = "YABAI_UPDATE_TILING_SKIP_LOCK"


def query_yabai_config(key: str, default: int) -> int:
    """Query a yabai config value."""
    try:
        result = subprocess.run(
            ["yabai", "-m", "config", key],
            capture_output=True,
            text=True,
            timeout=SUBPROCESS_TIMEOUT,
            check=True
        )
        return int(result.stdout.strip())
    except (subprocess.CalledProcessError, subprocess.TimeoutExpired, ValueError):
        return default

# Padding configuration - query from yabai and environment
EDGE_PADDING = int(os.environ.get('YABAI_EDGE_PADDING', '14'))
PADDING = query_yabai_config('window_gap', 20)
# Right-side reserved area (e.g., TiddlyWiki HUD). Subtracted from the usable
# width on the display that hosts widgets/HUD.
DEFAULT_WIDGET_PADDING_PX = 192
WIDGET_PADDING = int(os.environ.get('YABAI_WIDGET_PADDING', str(DEFAULT_WIDGET_PADDING_PX)))
CONFIG_EVENTS = {
    "display_added",
    "display_changed",
    "display_removed",
    "display_resized",
    "system_woke",
}

MANAGE_OFF_RULES: List[Dict[str, Any]] = []
MANAGE_OFF_APPS: set = set()  # Extracted app names for fast lookup

# Layout tuning
BUCKET_ORDER = ["far_left", "left", "center", "right", "far_right"]
BUCKET_WEIGHTS = {
    "far_left": 1.0,
    "left": 1.0,
    "center": 2.0,
    "right": 1.0,
    "far_right": 1.0,
}  # Adjust to change relative widths
# Cap non-center widths in pixels (when present with center). This directly
# controls side bucket width on the center display in 3-display 5-bucket mode,
# and on single-display 5-bucket ultrawide mode.
SIDE_MAX_WIDTH_PX: Optional[int] = 800  # Set to None to disable
# When a right-side cutout is present (HUD/widgets), you have two sensible
# choices for centering:
# - full display: visually centered on the physical panel (default). This makes
#   the left side effectively larger than the right by the cutout width.
# - usable width: centered between x=0 and the cutout edge. This makes left/right
#   symmetric, but shifts the "center" left on the physical panel.
CENTER_BUCKET_ON_FULL_DISPLAY = True
GRID_COLUMNS = 100  # Grid resolution for column calculations (higher -> finer control)


# Abstraction layers for testability
class YabaiDataProvider:
    """Base class for yabai data acquisition."""
    def query_displays(self) -> Optional[List[Dict[str, Any]]]:
        raise NotImplementedError

    def query_spaces(self) -> Optional[List[Dict[str, Any]]]:
        raise NotImplementedError

    def query_windows(self) -> Optional[List[Dict[str, Any]]]:
        raise NotImplementedError

    def query_rules(self) -> Optional[List[Dict[str, Any]]]:
        raise NotImplementedError

    def query_window(self, win_id: int) -> Optional[Dict[str, Any]]:
        raise NotImplementedError


class RealYabaiProvider(YabaiDataProvider):
    """Production provider - calls real yabai commands."""
    def query_displays(self) -> Optional[List[Dict[str, Any]]]:
        return run_json(["yabai", "-m", "query", "--displays"])

    def query_spaces(self) -> Optional[List[Dict[str, Any]]]:
        return run_json(["yabai", "-m", "query", "--spaces"])

    def query_windows(self) -> Optional[List[Dict[str, Any]]]:
        return run_json(["yabai", "-m", "query", "--windows"])

    def query_rules(self) -> Optional[List[Dict[str, Any]]]:
        return run_json(["yabai", "-m", "rule", "--list"])

    def query_window(self, win_id: int) -> Optional[Dict[str, Any]]:
        return run_json(["yabai", "-m", "query", "--windows", "--window", str(win_id)])


class MockYabaiProvider(YabaiDataProvider):
    """Test provider - loads data from JSON file."""
    def __init__(self, test_data: Dict[str, Any]):
        self.data = test_data
        self.displays = test_data.get("displays", [])
        self.spaces = test_data.get("spaces", [])
        self.windows = test_data.get("windows", [])
        self.rules = test_data.get("rules", [])

    def query_displays(self) -> Optional[List[Dict[str, Any]]]:
        log(f"MockProvider: returning {len(self.displays)} display(s)")
        return self.displays if self.displays else None

    def query_spaces(self) -> Optional[List[Dict[str, Any]]]:
        log(f"MockProvider: returning {len(self.spaces)} space(s)")
        return self.spaces if self.spaces else None

    def query_windows(self) -> Optional[List[Dict[str, Any]]]:
        log(f"MockProvider: returning {len(self.windows)} window(s)")
        return self.windows

    def query_rules(self) -> Optional[List[Dict[str, Any]]]:
        log(f"MockProvider: returning {len(self.rules)} rule(s)")
        return self.rules if self.rules else None

    def query_window(self, win_id: int) -> Optional[Dict[str, Any]]:
        log(f"MockProvider: looking up window {win_id}")
        for win in self.windows:
            if win.get("id") == win_id:
                return win
        return None


class YabaiCommandExecutor:
    """Abstraction for yabai command execution with dry-run support."""
    def __init__(self, dry_run: bool = False):
        self.dry_run = dry_run
        self.executed_commands: List[List[str]] = []

    def execute(self, cmd: List[str]) -> None:
        """Execute or log command based on mode."""
        if self.dry_run:
            print(f"[DRY-RUN] {' '.join(cmd)}")
            self.executed_commands.append(cmd)
        else:
            run_cmd(cmd)
            self.executed_commands.append(cmd)


def run_json(cmd: List[str]) -> Optional[Any]:
    log(f"run_json: {' '.join(cmd)}")
    try:
        out = subprocess.check_output(cmd, stderr=subprocess.DEVNULL, timeout=SUBPROCESS_TIMEOUT)
        return json.loads(out)
    except subprocess.TimeoutExpired:
        log(f"  -> timeout after {SUBPROCESS_TIMEOUT}s")
        return None
    except Exception as e:
        log(f"  -> error: {e}")
        return None


def run_cmd(cmd: List[str]) -> None:
    log(f"run_cmd: {' '.join(cmd)}")
    try:
        subprocess.run(
            cmd,
            check=False,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            timeout=SUBPROCESS_TIMEOUT,
        )
    except subprocess.TimeoutExpired:
        log(f"  -> timeout after {SUBPROCESS_TIMEOUT}s")


def acquire_lock(path: str) -> Optional[int]:
    """Acquire a single-instance lock on an existing file; return fd or None."""
    try:
        fd = os.open(path, os.O_RDONLY)
    except OSError as e:
        log(f"Failed to open lock target {path}: {e}")
        return None

    try:
        fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
        return fd
    except (BlockingIOError, OSError):
        os.close(fd)
        return None


def release_lock(fd: int) -> None:
    try:
        fcntl.flock(fd, fcntl.LOCK_UN)
    except OSError:
        pass
    try:
        os.close(fd)
    except OSError:
        pass


def has_newer_script_invocation(script_name: str, my_pid: int) -> bool:
    """Return True when a newer process appears to be running this script."""
    pattern = re.compile(rf"(^|[\s/]){re.escape(script_name)}(\s|$)")
    try:
        result = subprocess.run(
            ["ps", "-axo", "pid=,command="],
            capture_output=True,
            text=True,
            timeout=SUBPROCESS_TIMEOUT,
            check=True,
        )
    except (subprocess.CalledProcessError, subprocess.TimeoutExpired, OSError):
        return False

    for line in result.stdout.splitlines():
        parts = line.strip().split(None, 1)
        if len(parts) != 2:
            continue
        try:
            pid = int(parts[0])
        except ValueError:
            continue
        if pid <= my_pid:
            continue
        cmdline = parts[1]
        if pattern.search(cmdline):
            return True

    return False


def get_display_by_index(displays: List[Dict[str, Any]], idx: int) -> Optional[Dict[str, Any]]:
    for d in displays:
        if d.get("index") == idx:
            return d
    return None


def resolve_display_identifier(displays: List[Dict[str, Any]], identifier: str) -> Optional[int]:
    """Return the display index matching the given identifier (index/id/uuid/serial/name)."""
    if not identifier:
        return None
    identifier = identifier.strip()
    if not identifier:
        return None

    # Exact numeric match against index or id
    try:
        num = int(identifier)
        for d in displays:
            if d.get("index") == num or d.get("id") == num:
                return d.get("index")
    except ValueError:
        pass

    # String matches against common identifiers
    lowered = identifier.lower()
    for key in ("uuid", "serial", "name"):
        for d in displays:
            value = str(d.get(key) or "").lower()
            if value and value == lowered:
                return d.get("index")

    return None


def explicit_display_override(displays: List[Dict[str, Any]], env_vars: List[str]) -> Optional[int]:
    """Check a list of env vars and return the first matching display index."""
    for env_var in env_vars:
        env_value = os.environ.get(env_var)
        if not env_value:
            continue
        idx = resolve_display_identifier(displays, env_value)
        if idx is not None:
            return idx
    return None


def move_window_to_display(
    win_id: int,
    target_display: int,
    displays: Optional[List[Dict[str, Any]]],
    provider: YabaiDataProvider,
    executor: YabaiCommandExecutor,
) -> None:
    if target_display is None:
        return
    try:
        win_json = provider.query_window(win_id)
        if not win_json:
            return
        if win_json.get("display") == target_display:
            log(f"Window {win_id} already on display {target_display}")
            return
    except Exception:
        return
    log(f"Moving window {win_id} to display {target_display}")
    executor.execute(["yabai", "-m", "window", str(win_id), "--display", str(target_display)])

    # If move failed (common when scripting addition commands are blocked), fall back to a direct move
    updated = provider.query_window(win_id) or {}
    if updated.get("display") == target_display:
        return
    if not displays:
        return
    log(f"Move failed for window {win_id}, using fallback absolute positioning")

    target_disp = get_display_by_index(displays, target_display) or {}
    frame = target_disp.get("frame", {})
    win_frame = updated.get("frame", {}) if updated else win_json.get("frame", {})
    win_w = float(win_frame.get("w", 0) or 0)
    win_h = float(win_frame.get("h", 0) or 0)
    dst_x = float(frame.get("x", 0) or 0) + EDGE_PADDING
    dst_y = float(frame.get("y", 0) or 0) + EDGE_PADDING

    # Keep window inside the target display bounds
    max_x = float(frame.get("x", 0) or 0) + float(frame.get("w", 0) or 0) - win_w
    max_y = float(frame.get("y", 0) or 0) + float(frame.get("h", 0) or 0) - win_h
    if win_w and frame.get("w", 0):
        dst_x = min(dst_x, max_x)
    if win_h and frame.get("h", 0):
        dst_y = min(dst_y, max_y)

    executor.execute(["yabai", "-m", "window", str(win_id), "--move", f"abs:{int(dst_x)}:{int(dst_y)}"])


def apply_grid(win_id: int, rows: int, col: int, row: int, span: int, executor: YabaiCommandExecutor) -> None:
    grid = f"{rows}:{GRID_COLUMNS}:{col}:{row}:{span}:1"
    log(f"Applying grid {grid} to window {win_id}")
    executor.execute(["yabai", "-m", "window", str(win_id), "--grid", grid])


def position_journal_window(win_id: int, display: Dict[str, Any], provider: YabaiDataProvider, executor: YabaiCommandExecutor) -> None:
    """Position journal window in upper-right corner with fixed dimensions."""
    frame = display.get("frame", {})
    disp_x = float(frame.get("x", 0) or 0)
    disp_y = float(frame.get("y", 0) or 0)
    disp_w = float(frame.get("w", 0) or 0)

    # Journal window dimensions (192px to avoid overlapping main content area)
    width = 192
    height = 400
    margin = 12

    # Account for window decorations - Ghostty may have borders/padding
    # Position flush against right edge (no margin) and just below menu bar
    x = int(disp_x + disp_w - width)
    y = int(disp_y + margin)  # Keep top margin for menu bar clearance

    log(f"Positioning journal window {win_id} at ({x}, {y}) with size ({width}x{height})")

    # Resize first, then move (resize can change position, so move last to ensure right-alignment)
    executor.execute(["yabai", "-m", "window", str(win_id), "--resize", f"abs:{width}:{height}"])
    executor.execute(["yabai", "-m", "window", str(win_id), "--move", f"abs:{x}:{y}"])


def apply_bucket(windows: List[int], col: int, span: int, executor: YabaiCommandExecutor, horizontal: bool = False) -> None:
    """
    Apply grid layout to windows in a bucket.

    Args:
        windows: List of window IDs to tile
        col: Starting column in grid
        span: Column span for the bucket
        executor: Command executor
        horizontal: If True, tile side-by-side; if False, tile vertically (stacked)
    """
    if not windows:
        return

    num_windows = len(windows)

    if horizontal:
        # Horizontal tiling: windows side-by-side
        # Each window gets a portion of the bucket's column span
        window_span = max(1, span // num_windows)
        remainder = span - (window_span * num_windows)

        for idx, win in enumerate(windows):
            # Distribute remainder pixels to first windows
            current_span = window_span + (1 if idx < remainder else 0)
            window_col = col + sum(
                window_span + (1 if i < remainder else 0)
                for i in range(idx)
            )
            # Use 1 row, place all windows at row 0, each spans full height
            apply_grid(win, 1, window_col, 0, current_span, executor)
    else:
        # Vertical tiling: windows stacked
        rows = max(1, num_windows)
        for idx, win in enumerate(windows):
            apply_grid(win, rows, col, idx, span, executor)


def should_tile_horizontal(
    bucket_name: Optional[str],
    bucket_width: float,
    bucket_height: float,
    display_width: float,
) -> bool:
    """Return True when a bucket should tile horizontally."""
    if bucket_name == "center":
        return True
    if bucket_name is None:
        return bucket_width > bucket_height
    return False


def compute_bucket_widths(buckets_present: List[str], display_width: float) -> Dict[str, float]:
    if not buckets_present or display_width <= 0:
        return {}

    total_weight = sum(BUCKET_WEIGHTS.get(bucket, 1.0) for bucket in buckets_present)
    widths = {
        bucket: display_width * (BUCKET_WEIGHTS.get(bucket, 1.0) / total_weight)
        for bucket in buckets_present
    }

    if SIDE_MAX_WIDTH_PX is not None and "center" in buckets_present:
        max_width = float(SIDE_MAX_WIDTH_PX)
        for bucket in buckets_present:
            if bucket != "center":
                widths[bucket] = min(widths[bucket], max_width)

        non_center_total = sum(widths[bucket] for bucket in widths if bucket != "center")
        if non_center_total >= display_width:
            # sides eat the whole space; scale them down evenly
            scale = display_width / max(non_center_total, 1.0)
            for bucket in widths:
                if bucket != "center":
                    widths[bucket] *= scale
            widths["center"] = 0.0
        else:
            widths["center"] = max(0.0, display_width - non_center_total)

    total_after = sum(widths.values())
    if "center" not in buckets_present and total_after > 0:
        # scale to fill the available space when only sides are present
        scale = display_width / total_after
        for bucket in widths:
            widths[bucket] *= scale

    return widths


def bucket_layout(
    buckets_present: List[str],
    display_width: float,
    center_bucket: bool = False,
    right_cutout_px: float = 0.0,
) -> Dict[str, Dict[str, int]]:
    # Compute bucket widths based on available space (excluding right cutout)
    effective_width = display_width - right_cutout_px
    widths = compute_bucket_widths(buckets_present, effective_width)
    order = [bucket for bucket in BUCKET_ORDER if bucket in widths]
    if not order or display_width <= 0:
        return {}

    # Calculate target grid columns (accounts for right cutout)
    right_cutout_cols = 0
    if right_cutout_px > 0 and display_width > 0:
        right_cutout_cols = int(math.ceil((right_cutout_px / display_width) * GRID_COLUMNS))
    target_cols = GRID_COLUMNS - right_cutout_cols

    # Special case: when centering on the full display AND a right-side cutout exists, we
    # want the center bucket visually centered on the physical panel while keeping buckets
    # contiguous and not overlapping the cutout.
    #
    # To achieve this, we subtract the cutout width from the RIGHT side bucket total
    # (starting from the rightmost bucket) and give that space to the center bucket.
    # This results in:
    # - left side buckets staying at their target widths (e.g., 800px)
    # - the rightmost bucket being reduced by the cutout width (e.g., 800 - 192)
    # - center bucket expanding so it remains visually centered on the full display.
    if (
        center_bucket
        and right_cutout_px > 0
        and CENTER_BUCKET_ON_FULL_DISPLAY
        and "center" in widths
        and len(order) > 1
    ):
        center_idx = order.index("center")
        right_buckets = order[center_idx + 1 :]
        if right_buckets:
            remaining = float(right_cutout_px)
            for bucket in reversed(right_buckets):
                if remaining <= 0:
                    break
                current = float(widths.get(bucket, 0.0))
                take = min(current, remaining)
                widths[bucket] = max(0.0, current - take)
                remaining -= take

            # Give the removed width back to center so we still fill effective_width.
            non_center_total = sum(
                float(widths.get(b, 0.0)) for b in widths.keys() if b != "center"
            )
            widths["center"] = max(0.0, effective_width - non_center_total)

        # Convert widths to column spans based on the usable space (target_cols).
        raw_spans = [
            (float(widths[bucket]) / max(effective_width, 1.0)) * target_cols
            for bucket in order
        ]
        # Use round() instead of floor+remainders to avoid systematic tie bias
        # (e.g., left/right with identical remainders).
        spans = [max(1, int(round(value))) for value in raw_spans]
        diff = target_cols - sum(spans)
        if diff != 0 and "center" in order:
            center_i = order.index("center")
            spans[center_i] = max(1, spans[center_i] + diff)
            diff = target_cols - sum(spans)
        if diff != 0 and spans:
            spans[-1] = max(1, spans[-1] + diff)

        final_layout: Dict[str, Dict[str, int]] = {}
        col = 0
        for bucket, span in zip(order, spans):
            final_layout[bucket] = {"col": col, "span": span}
            col += span

        # Ensure right edge hugs the cutout boundary.
        total_assigned = sum(span for span in spans)
        if total_assigned != target_cols and order:
            adjust_bucket = "center" if "center" in final_layout else order[-1]
            adjustment = target_cols - total_assigned
            final_layout[adjust_bucket]["span"] = max(
                1, final_layout[adjust_bucket]["span"] + adjustment
            )

        return final_layout

    # Convert widths to column spans based on available space
    raw_spans = [
        (widths[bucket] / effective_width) * target_cols
        for bucket in order
    ]
    spans = [max(1, int(value)) for value in raw_spans]
    diff = target_cols - sum(spans)

    remainders = [value - int(value) for value in raw_spans]
    while diff != 0:
        if diff > 0:
            idx = max(range(len(order)), key=lambda i: remainders[i])
            spans[idx] += 1
            diff -= 1
        else:
            candidates = [i for i, span in enumerate(spans) if span > 1]
            if not candidates:
                break
            idx = max(candidates, key=lambda i: spans[i])
            spans[idx] -= 1
            diff += 1

    final_layout: Dict[str, Dict[str, int]] = {}
    col = 0
    for bucket, span in zip(order, spans):
        final_layout[bucket] = {"col": col, "span": span}
        col += span

    # ensure target columns are consumed (may be less than GRID_COLUMNS if there's a cutout)
    total_assigned = sum(span for span in spans)
    if total_assigned != target_cols and order:
        adjust_bucket = "center" if "center" in final_layout else order[-1]
        adjustment = target_cols - total_assigned
        final_layout[adjust_bucket]["span"] = max(1, final_layout[adjust_bucket]["span"] + adjustment)

    if center_bucket and "center" in final_layout and len(order) > 1:
        center_idx = order.index("center")
        center_span = final_layout["center"]["span"]
        if CENTER_BUCKET_ON_FULL_DISPLAY:
            # Center on the full screen (including the cutout area on right).
            # This makes the center bucket visually centered on the display.
            desired_center_col = max(0, round((GRID_COLUMNS - center_span) / 2))
        else:
            # Center within the usable area (excluding the right cutout).
            desired_center_col = max(0, round((target_cols - center_span) / 2))

        left_buckets = order[:center_idx]
        right_buckets = order[center_idx + 1:]

        # Build symmetric centered layout
        centered_layout: Dict[str, Dict[str, int]] = {}

        # Place center bucket at desired position
        centered_layout["center"] = {"col": desired_center_col, "span": center_span}
        center_right_edge = desired_center_col + center_span

        # Redistribute LEFT buckets to fill space from 0 to desired_center_col
        if left_buckets and desired_center_col > 0:
            total_left_span = sum(final_layout[b]["span"] for b in left_buckets)
            left_col = 0
            for i, bucket in enumerate(left_buckets):
                original_span = final_layout[bucket]["span"]
                if i < len(left_buckets) - 1:
                    # Intermediate buckets: scale proportionally
                    scaled_span = max(1, int((original_span / total_left_span) * desired_center_col))
                    centered_layout[bucket] = {"col": left_col, "span": scaled_span}
                    left_col += scaled_span
                else:
                    # Last left bucket: fill remaining space to center
                    remaining = desired_center_col - left_col
                    centered_layout[bucket] = {"col": left_col, "span": max(1, remaining)}
        elif left_buckets:
            # No space for left buckets - place them at 0 with minimal span
            left_col = 0
            for bucket in left_buckets:
                centered_layout[bucket] = {"col": left_col, "span": 1}
                left_col += 1

        # Redistribute RIGHT buckets to fill space from center_right_edge to target_cols
        available_right_space = target_cols - center_right_edge
        if right_buckets and available_right_space > 0:
            total_right_span = sum(final_layout[b]["span"] for b in right_buckets)
            right_col = center_right_edge
            for i, bucket in enumerate(right_buckets):
                original_span = final_layout[bucket]["span"]
                if i < len(right_buckets) - 1:
                    # Intermediate buckets: scale proportionally
                    scaled_span = max(1, int((original_span / total_right_span) * available_right_space))
                    centered_layout[bucket] = {"col": right_col, "span": scaled_span}
                    right_col += scaled_span
                else:
                    # Last right bucket: fill remaining space to target_cols
                    remaining = target_cols - right_col
                    centered_layout[bucket] = {"col": right_col, "span": max(1, remaining)}
        elif right_buckets:
            # No space for right buckets - place them at target_cols with minimal span
            for bucket in right_buckets:
                centered_layout[bucket] = {"col": target_cols - 1, "span": 1}

        # Always use the layout with cutout applied
        final_layout = {
            bucket: centered_layout[bucket]
            for bucket in order
        }

    return final_layout


def workspace_width(displays: List[Dict[str, Any]]) -> float:
    return float(sum(d.get("frame", {}).get("w", 0) for d in displays))


def get_main_horizontal_row(displays: List[Dict[str, Any]], y_tolerance: float = 200.0) -> List[Dict[str, Any]]:
    """
    Filter displays to get only those in the main horizontal row.

    Displays are grouped by Y position. The main row is the one with the
    largest total horizontal width (most likely the primary work area).

    Args:
        displays: List of display dictionaries
        y_tolerance: Max Y difference to consider displays in the same row

    Returns:
        List of displays in the main horizontal row
    """
    if not displays:
        return []

    if len(displays) == 1:
        return displays

    # Group displays by Y position (using tolerance for alignment variations)
    rows: Dict[int, List[Dict[str, Any]]] = {}
    for d in displays:
        y = d.get("frame", {}).get("y", 0)
        # Round Y to nearest tolerance bucket
        y_bucket = int(y / y_tolerance)
        rows.setdefault(y_bucket, []).append(d)

    # Find the row with the largest total width
    best_row = max(rows.values(), key=lambda row: sum(
        d.get("frame", {}).get("w", 0) for d in row
    ))

    return best_row


def bucket_display_map(displays: List[Dict[str, Any]]) -> Dict[str, Optional[int]]:
    if not displays:
        return {}

    # Filter to only include displays in the main horizontal row
    main_row_displays = get_main_horizontal_row(displays)

    sorted_displays = sorted(main_row_displays, key=lambda d: d.get("frame", {}).get("x", 0))
    leftmost = sorted_displays[0].get("index")
    rightmost = sorted_displays[-1].get("index")
    middle_displays = sorted_displays[1:-1]

    explicit_far_left = explicit_display_override(
        displays, ["YABAI_FAR_LEFT_DISPLAY", "EXTERNAL_FAR_LEFT_DISPLAY"]
    )
    explicit_far_right = explicit_display_override(
        displays, ["YABAI_FAR_RIGHT_DISPLAY", "EXTERNAL_FAR_RIGHT_DISPLAY"]
    )

    mapping: Dict[str, Optional[int]] = {
        "far_left": explicit_far_left if explicit_far_left is not None else leftmost,
        "far_right": explicit_far_right if explicit_far_right is not None else rightmost,
    }

    if middle_displays:
        center_display = middle_displays[len(middle_displays) // 2]
        center_idx = center_display.get("index")
        mapping.update({"left": center_idx, "center": center_idx, "right": center_idx})
    else:
        # Handle 1-2 displays gracefully
        if len(sorted_displays) == 1:
            only = sorted_displays[0].get("index")
            mapping.update({"left": only, "center": only, "right": only})
        else:
            mapping.update({"left": leftmost, "center": rightmost, "right": rightmost})

    return mapping


def is_special_sysmon(win: Dict[str, Any]) -> bool:
    title = win.get("title", "")
    return "sysmon" in title.lower()


def is_special_ai(win: Dict[str, Any]) -> bool:
    app = win.get("app", "")
    title = win.get("title", "")
    low_app = app.lower()
    low_title = title.lower()

    # Only match specific cases:
    # 1. Ghostty windows with "claude" in the title
    if low_app == "ghostty" and "claude" in low_title:
        return True
    # 2. Claude.app
    if low_app == "claude":
        return True
    # 3. ChatGPT.app
    if low_app == "chatgpt":
        return True

    return False


def is_special_journal(win: Dict[str, Any]) -> bool:
    title = win.get("title", "")
    return "wiki_journal_today" in title.lower()


def rule_matches_window(rule: Dict[str, Any], win: Dict[str, Any]) -> bool:
    def match_regex(rule_value: Optional[str], value: str) -> bool:
        if not rule_value:
            return True
        try:
            return re.search(rule_value, value) is not None
        except re.error:
            return False

    def match_int(rule_value: Any, value: Any) -> bool:
        if rule_value is None or rule_value == "" or rule_value == 0 or rule_value == "0":
            return True
        try:
            return int(rule_value) == int(value)
        except Exception:
            return False

    return all(
        [
            match_regex(rule.get("app"), win.get("app", "")),
            match_regex(rule.get("title"), win.get("title", "")),
            match_regex(rule.get("role"), win.get("role", "")),
            match_regex(rule.get("subrole"), win.get("subrole", "")),
            match_int(rule.get("display"), win.get("display", 0) or 0),
            match_int(rule.get("space"), win.get("space", 0) or 0),
        ]
    )


def manage_is_off(value: Any) -> bool:
    if value is False or value == 0:
        return True
    if isinstance(value, str):
        return value.strip().lower() in {"off", "false", "0", "no"}
    return False


def is_management_disabled(win: Optional[Dict[str, Any]]) -> bool:
    if not win:
        return False

    win_id = win.get("id")
    app = win.get("app", "")

    # Only apply tiling to regular windows
    if not is_regular_window(win):
        log(f"Window {win_id} ({app}) is not a regular window, management disabled")
        return True

    # Defensive check: explicitly exclude apps that should never be managed
    # This prevents race conditions where yabai rules haven't been applied yet (e.g., window_created events)
    # Apps are extracted from yabai manage=off rules at startup
    if app in MANAGE_OFF_APPS:
        log(f"Window {win_id} ({app}) explicitly excluded from management (defensive check)")
        return True

    # Check if window is a panel/dialog/sheet that should remain floating
    if is_panel_or_dialog(win):
        return True

    # Check rules
    for rule in MANAGE_OFF_RULES:
        if rule_matches_window(rule, win):
            log(f"Window {win_id} ({app}) matched manage-off rule: {rule.get('app')}")
            return True

    # Check explicit should-manage property
    if "should-manage" in win:
        result = not bool(win.get("should-manage"))
        if result:
            log(f"Window {win_id} ({app}) has should-manage=False")
        return result

    # Fall back to state when intent cannot be inferred (e.g. rule output format drift).
    # This avoids accidentally managing windows that yabai already considers unmanaged.
    for key in ("managed", "is-managed"):
        if key in win and not bool(win.get(key)):
            log(f"Window {win_id} ({app}) has {key}=False, management disabled")
            return True

    log(f"Window {win_id} ({app}) is manageable (no disable rules matched)")
    return False


def ensure_managed(win_id: int, provider: YabaiDataProvider, executor: YabaiCommandExecutor) -> None:
    info = provider.query_window(win_id) or {}
    if is_management_disabled(info):
        return
    if info.get("floating") == 1:
        # toggle to managed so grid placement works
        executor.execute(["yabai", "-m", "window", str(win_id), "--toggle", "float"])


def build_eligible_windows_by_space(
    windows: List[Dict[str, Any]],
    provider: YabaiDataProvider,
    executor: YabaiCommandExecutor,
    include_journal: bool = False,
) -> Dict[Tuple[int, int], List[Dict[str, Any]]]:
    """
    Build a (display, space) -> windows index for windows eligible for tiling.

    This avoids repeatedly scanning all windows for each space across layout modes.
    """
    indexed: Dict[Tuple[int, int], List[Dict[str, Any]]] = {}

    for win in windows:
        display = win.get("display")
        space = win.get("space")
        if display is None or space is None:
            continue
        if win.get("minimized") == 1:
            continue
        if is_management_disabled(win):
            continue
        if not include_journal and is_special_journal(win):
            continue
        if win.get("floating") == 1:
            ensure_managed(win.get("id"), provider, executor)
        if win.get("is-visible") is False or win.get("is-hidden") is True:
            continue
        indexed.setdefault((display, space), []).append(win)

    return indexed


def apply_standard_tiling(
    spaces: List[Dict[str, Any]],
    windows: List[Dict[str, Any]],
    displays: List[Dict[str, Any]],
    provider: YabaiDataProvider,
    executor: YabaiCommandExecutor,
    exclude_displays: Optional[set] = None,
    windows_by_space: Optional[Dict[Tuple[int, int], List[Dict[str, Any]]]] = None,
) -> None:
    if exclude_displays is None:
        exclude_displays = set()

    for space in spaces:
        space_display = space.get("display")
        if space_display in exclude_displays:
            continue
        space_index = space.get("index")

        display_obj = get_display_by_index(displays, space_display) or {}
        display_w = display_obj.get("frame", {}).get("w", 0)
        display_h = display_obj.get("frame", {}).get("h", 0)

        if not display_w or not display_h:
            continue

        if windows_by_space is not None:
            space_windows = windows_by_space.get((space_display, space_index), [])
        else:
            # Fallback path used by tests and direct function calls.
            space_windows = build_eligible_windows_by_space(
                windows,
                provider,
                executor,
            ).get((space_display, space_index), [])

        if not space_windows:
            continue

        # Sort by window ID for stable ordering
        sorted_windows = sorted(space_windows, key=lambda w: w.get("id", 0))

        # Apply to full display width (minus widget padding on center display)
        # Widget padding is handled at space level, so use full width for grid
        bucket_width = display_w
        bucket_height = display_h

        # Determine tiling direction based on display aspect ratio
        horizontal = should_tile_horizontal(
            None,
            bucket_width,
            bucket_height,
            display_w,
        )

        log(f"Display {space_display} space {space_index}: {len(sorted_windows)} windows, "
            f"{bucket_width:.0f}x{bucket_height:.0f}px, "
            f"tiling {'horizontally' if horizontal else 'vertically'}")

        apply_bucket(
            [w.get("id") for w in sorted_windows],
            col=0,
            span=GRID_COLUMNS,
            executor=executor,
            horizontal=horizontal,
        )


def is_panel_or_dialog(win: Optional[Dict[str, Any]]) -> bool:
    """
    Check if a window is a panel, dialog, or sheet that should remain floating.

    These window types are tracked by yabai but intentionally left floating.
    The script should respect this decision and not force them to tile.

    Args:
        win: Window dictionary from yabai query

    Returns:
        True if the window should remain floating (is a panel/dialog/sheet)
    """
    if not win:
        return False

    win_id = win.get("id")

    # Check role first - AXSheet is a role, not a subrole
    role = win.get("role", "")
    if role == "AXSheet":
        log(f"Window {win_id} is a sheet (role=AXSheet), keeping floating")
        return True

    # Check subrole for dialog/panel types
    subrole = win.get("subrole", "")

    # List of subroles that indicate floating UI elements
    FLOATING_SUBROLES = {
        "AXDialog",              # Dialog windows
        "AXSystemDialog",        # System dialogs
        "AXFloatingWindow",      # Floating windows
        "AXSystemFloatingWindow" # System floating windows
    }

    if subrole in FLOATING_SUBROLES:
        log(f"Window {win_id} has floating subrole '{subrole}', keeping floating")
        return True

    # Additional check: window level
    # Windows at non-normal levels (level != 0) are permanently floating
    level = win.get("level")
    if level is not None and level != 0:
        log(f"Window {win_id} has non-normal level {level}, keeping floating")
        return True

    return False


def is_regular_window(win: Optional[Dict[str, Any]]) -> bool:
    """
    Check if a window is a regular, tilable window.

    Regular windows are standard application windows (AXWindow/AXStandardWindow).
    Tooltips, quick-open panels, and other transient UI should be excluded.
    """
    if not win:
        return False

    role = win.get("role", "")
    subrole = win.get("subrole", "")
    level = win.get("level")

    # Regular windows are standard AXWindow/AXStandardWindow at normal level
    if role == "AXWindow" and subrole == "AXStandardWindow" and (level is None or level == 0):
        return True

    return False


def determine_bucket_by_position(
    win: Dict[str, Any],
    display: Dict[str, Any],
    available_buckets: List[str]
) -> str:
    """
    Determine which bucket a window belongs to based on its position within the display.

    Args:
        win: Window dictionary with frame info
        display: Display dictionary with frame info
        available_buckets: List of bucket names available on this display (in order)

    Returns:
        The bucket name the window should be placed in
    """
    if not available_buckets:
        return "center"  # fallback

    if len(available_buckets) == 1:
        return available_buckets[0]

    # Get window and display frames
    win_frame = win.get("frame", {})
    disp_frame = display.get("frame", {})

    win_x = float(win_frame.get("x", 0) or 0)
    win_w = float(win_frame.get("w", 0) or 0)
    disp_x = float(disp_frame.get("x", 0) or 0)
    disp_w = float(disp_frame.get("w", 0) or 0)

    # Safety checks for invalid frames
    if disp_w <= 0 or win_w <= 0:
        log(f"Invalid frame data (disp_w={disp_w}, win_w={win_w}), defaulting to first bucket")
        return available_buckets[0]

    # Calculate window center relative to display
    win_center_x = win_x + (win_w / 2)
    relative_x = win_center_x - disp_x
    position_ratio = relative_x / disp_w

    # Divide display into equal regions based on number of buckets
    num_buckets = len(available_buckets)
    bucket_index = int(position_ratio * num_buckets)
    bucket_index = max(0, min(bucket_index, num_buckets - 1))

    log(f"Window at x={win_x:.0f} (center={win_center_x:.0f}), display x={disp_x:.0f} w={disp_w:.0f}, "
        f"ratio={position_ratio:.2f} -> bucket_index={bucket_index} ({available_buckets[bucket_index]})")

    return available_buckets[bucket_index]


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Update yabai tiling layout")
    parser.add_argument(
        "-v", "--verbose", action="store_true", help="Enable verbose logging output"
    )
    parser.add_argument(
        "-n", "--dry-run", action="store_true",
        help="Show commands that would be executed without executing them"
    )
    parser.add_argument(
        "--test-data", type=str, metavar="FILE",
        help="Load test data from JSON file instead of querying yabai"
    )
    parser.add_argument(
        "--save-snapshot", type=str, metavar="FILE",
        help="Save current yabai state to JSON file for later testing"
    )
    parser.add_argument(
        "--debounce", type=int, metavar="MS", default=0,
        help="Debounce delay in milliseconds; only the last call within the period runs"
    )
    return parser.parse_args()


def main() -> None:
    global VERBOSE
    args = parse_args()
    VERBOSE = args.verbose

    # Debounce: wait for activity to settle before proceeding
    if args.debounce > 0:
        time.sleep(args.debounce / 1000.0)

        if has_newer_script_invocation(os.path.basename(sys.argv[0]), os.getpid()):
            # A newer invocation superseded us
            sys.exit(0)

    # Prevent re-entrant updates triggered by our own window moves/resizes
    lock_fd: Optional[int] = None
    if not args.test_data and os.environ.get(LOCK_ENV_SKIP) != "1":
        lock_fd = acquire_lock(os.path.realpath(__file__))
        if lock_fd is None:
            log("Another update in progress; skipping")
            sys.exit(0)
        atexit.register(release_lock, lock_fd)

    # Initialize provider and executor based on args
    provider: YabaiDataProvider
    if args.test_data:
        # Load test data from JSON file
        log(f"Loading test data from {args.test_data}")
        try:
            with open(args.test_data, "r") as f:
                test_data = json.load(f)
            provider = MockYabaiProvider(test_data)
            log("Using MockYabaiProvider")
        except Exception as e:
            print(f"Error loading test data from {args.test_data}: {e}", file=sys.stderr)
            sys.exit(1)
    else:
        provider = RealYabaiProvider()
        log("Using RealYabaiProvider")

    # Command executor with dry-run support
    # Note: test-data implies dry-run to avoid executing commands with fake data
    dry_run = args.dry_run or bool(args.test_data)
    executor = YabaiCommandExecutor(dry_run=dry_run)
    if dry_run:
        log("Dry-run mode enabled - commands will be logged but not executed")

    event = (os.environ.get("YABAI_SIGNAL_EVENT") or "").strip().lower()
    log(f"Event: {event or '(none)'}")

    # Handle --save-snapshot: capture current state and exit
    if args.save_snapshot:
        log(f"Saving snapshot to {args.save_snapshot}")
        try:
            snapshot = {
                "displays": provider.query_displays() or [],
                "spaces": provider.query_spaces() or [],
                "windows": provider.query_windows() or [],
                "rules": provider.query_rules() or [],
            }
            with open(args.save_snapshot, "w") as f:
                json.dump(snapshot, f, indent=2)
            print(f"Snapshot saved to {args.save_snapshot}")
            sys.exit(0)
        except Exception as e:
            print(f"Error saving snapshot to {args.save_snapshot}: {e}", file=sys.stderr)
            sys.exit(1)

    global MANAGE_OFF_RULES, MANAGE_OFF_APPS
    MANAGE_OFF_RULES = [
        rule
        for rule in (provider.query_rules() or [])
        if manage_is_off(rule.get("manage"))
    ]
    log(f"Manage-off rules: {len(MANAGE_OFF_RULES)}")

    # Extract app names from rules for defensive checking (handles simple patterns like ^app$)
    MANAGE_OFF_APPS = set()
    for rule in MANAGE_OFF_RULES:
        app_pattern = rule.get("app", "")
        if app_pattern:
            # Strip common regex anchors to get literal app name
            app_name = app_pattern.strip("^$")
            if app_name and not any(c in app_name for c in r".*+?[]{}()\|"):
                # Only add if it's a simple literal (no complex regex)
                MANAGE_OFF_APPS.add(app_name)

    if VERBOSE:
        if MANAGE_OFF_RULES:
            for rule in MANAGE_OFF_RULES:
                log(f"  Rule: app={rule.get('app')}, manage={rule.get('manage')}")
        if MANAGE_OFF_APPS:
            log(f"  Defensive app exclusions: {sorted(MANAGE_OFF_APPS)}")

    displays = provider.query_displays()
    spaces = provider.query_spaces()
    windows = provider.query_windows()

    if not displays or not spaces or windows is None:
        log("Missing displays/spaces/windows data, exiting")
        sys.exit(0)

    log(f"Found {len(displays)} display(s), {len(spaces)} space(s), {len(windows)} window(s)")
    should_update_config = not event or event in CONFIG_EVENTS

    total_workspace_width = workspace_width(displays)
    widest_display_width = max(d.get("frame", {}).get("w", 0) for d in displays) if displays else 0
    use_five_buckets = (
        total_workspace_width >= WORKSPACE_WIDTH_THRESHOLD or
        widest_display_width >= WORKSPACE_WIDTH_THRESHOLD
    )
    log(f"Total workspace width: {total_workspace_width}px, widest display: {widest_display_width}px")

    # Find widest display over threshold for legacy 3-bucket ultrawide mode
    ultra_display = None
    widest = max(displays, key=lambda d: d.get("frame", {}).get("w", 0))
    if widest.get("frame", {}).get("w", 0) >= ULTRAWIDE_THRESHOLD:
        ultra_display = widest

    ultra_index = ultra_display.get("index") if ultra_display else None

    if use_five_buckets:
        if widest_display_width >= WORKSPACE_WIDTH_THRESHOLD:
            log(f"Layout mode: 5-bucket (widest display {widest_display_width}px >= {WORKSPACE_WIDTH_THRESHOLD}px)")
        else:
            log(f"Layout mode: 5-bucket (total workspace {total_workspace_width}px >= {WORKSPACE_WIDTH_THRESHOLD}px)")
    elif ultra_index is not None:
        log(f"Layout mode: ultrawide 3-bucket on display {ultra_index}")
    else:
        log(f"Layout mode: multi-display standard ({len(displays)} displays)")

    bucket_to_display = bucket_display_map(displays) if use_five_buckets else {}
    display_to_buckets: Dict[int, List[str]] = {}
    for bucket, disp in bucket_to_display.items():
        if disp is None:
            continue
        display_to_buckets.setdefault(disp, []).append(bucket)
    for disp, buckets in display_to_buckets.items():
        display_to_buckets[disp] = [b for b in BUCKET_ORDER if b in buckets]

    # Determine center-most display for widget padding
    # Priority: YABAI_WIDGET_DISPLAY env var > center bucket > center of main row
    widget_display_override = explicit_display_override(
        displays, ["YABAI_WIDGET_DISPLAY"]
    )
    if widget_display_override is not None:
        center_display_for_widgets = widget_display_override
    elif use_five_buckets and bucket_to_display:
        center_display_for_widgets = bucket_to_display.get("center")
    else:
        # Find center display in main horizontal row
        main_row = get_main_horizontal_row(displays)
        if main_row:
            sorted_row = sorted(main_row, key=lambda d: d.get("frame", {}).get("x", 0))
            center_display_for_widgets = sorted_row[len(sorted_row) // 2].get("index")
        else:
            center_display_for_widgets = None

    log(f"Widget padding will be applied to display {center_display_for_widgets}")

    # Space layouts/padding
    if should_update_config:
        for space in spaces:
            space_index = space.get("index")
            space_display = space.get("display")

            # Apply widget padding on center-most display
            # In bucket modes, padding is handled by bucket_layout (right_cutout_px)
            # In non-bucket modes, use space-level right_padding
            if use_five_buckets and space_display in display_to_buckets:
                # Bucket mode: no space padding, bucket layout handles widget area
                pad_right = 0
            elif not use_five_buckets and ultra_index is not None and space_display == ultra_index:
                # Ultrawide mode: no space padding, bucket layout handles widget area
                pad_right = 0
            elif space_display == center_display_for_widgets:
                # Standard mode: apply widget padding at space level
                pad_right = WIDGET_PADDING
            else:
                pad_right = 0

            # Use float layout for all managed spaces so grid commands aren't overridden
            # This includes space 1, since we now tile it
            layout = "float"

            current_layout = space.get("layout")
            current_pad_right = space.get("right_padding")
            needs_layout = current_layout != layout
            needs_padding = current_pad_right != pad_right or any(
                space.get(key) not in (0, "0") for key in ("top_padding", "bottom_padding", "left_padding")
            )
            if not (needs_layout or needs_padding):
                continue

            executor.execute(
                [
                    "yabai",
                    "-m",
                    "config",
                    "--space",
                    str(space_index),
                    "layout",
                    layout,
                    "top_padding",
                    "0",
                    "bottom_padding",
                    "0",
                    "left_padding",
                    "0",
                    "right_padding",
                    str(pad_right),
                ]
            )

        # apply all rules (expensive; only when displays change/wake)
        executor.execute(["yabai", "-m", "rule", "--apply"])

    # Special windows
    explicit_far_left = explicit_display_override(
        displays, ["YABAI_FAR_LEFT_DISPLAY", "EXTERNAL_FAR_LEFT_DISPLAY"]
    )
    explicit_far_right = explicit_display_override(
        displays, ["YABAI_FAR_RIGHT_DISPLAY", "EXTERNAL_FAR_RIGHT_DISPLAY"]
    )

    rightmost_display = (
        explicit_far_right
        if explicit_far_right is not None
        else sorted(displays, key=lambda d: d.get("frame", {}).get("x", 0))[-1].get("index")
    )
    leftmost_display = (
        explicit_far_left
        if explicit_far_left is not None
        else sorted(displays, key=lambda d: d.get("frame", {}).get("x", 0))[0].get("index")
    )
    num_displays = len(displays)

    sysmon_windows = [w for w in windows if is_special_sysmon(w)]
    ai_windows = [w for w in windows if is_special_ai(w)]
    journal_windows = [w for w in windows if is_special_journal(w)]
    sysmon_windows = [w for w in sysmon_windows if not is_management_disabled(w)]
    ai_windows = [w for w in ai_windows if not is_management_disabled(w)]
    journal_windows = [w for w in journal_windows if not is_management_disabled(w)]

    if sysmon_windows:
        log(f"Sysmon windows ({len(sysmon_windows)}): {[w.get('id') for w in sysmon_windows]}")
    if ai_windows:
        log(f"AI windows ({len(ai_windows)}): {[w.get('id') for w in ai_windows]}")
    if journal_windows:
        log(f"Journal windows ({len(journal_windows)}): {[w.get('id') for w in journal_windows]}")

    # Position journal windows in upper-right of primary display
    primary_display = None
    for d in displays:
        if d.get("index") == 1:  # Primary display is typically index 1
            primary_display = d
            break
    if not primary_display and displays:
        primary_display = displays[0]

    if journal_windows and primary_display:
        for win in journal_windows:
            win_id = win.get("id")
            position_journal_window(win_id, primary_display, provider, executor)

    # Auto-bucketing removed: windows stay where user places them
    # Position-based bucketing happens in the layout sections below

    # Refresh windows after special moves
    windows = provider.query_windows() or []
    windows_by_space = build_eligible_windows_by_space(windows, provider, executor)

    # 5-bucket workspace layout
    if use_five_buckets and display_to_buckets:
        widget_display_override = explicit_display_override(
            displays, ["YABAI_WIDGET_DISPLAY"]
        )
        widget_display_idx = (
            widget_display_override
            if widget_display_override is not None
            else bucket_to_display.get("center")
        )
        for space in spaces:
            space_display = space.get("display")
            space_index = space.get("index")
            buckets_for_display = display_to_buckets.get(space_display, [])
            if not buckets_for_display:
                continue

            display_obj = get_display_by_index(displays, space_display) or {}
            display_w = display_obj.get("frame", {}).get("w", 0)

            buckets: Dict[str, List[Dict[str, Any]]] = {name: [] for name in buckets_for_display}
            space_windows = windows_by_space.get((space_display, space_index), [])
            for win in space_windows:

                # Determine bucket based on window position
                bucket = determine_bucket_by_position(win, display_obj, buckets_for_display)
                if bucket not in buckets:
                    continue
                buckets[bucket].append(win)

            # Always allocate space for all buckets, even if empty
            present_buckets = buckets_for_display

            # Apply widget padding cutout on the widget display.
            right_cutout = WIDGET_PADDING if space_display == widget_display_idx else 0

            layout = bucket_layout(present_buckets, display_w, center_bucket=True, right_cutout_px=right_cutout)
            if not layout:
                continue

            # Calculate display height for aspect ratio checks
            display_h = display_obj.get("frame", {}).get("h", 0)

            for bucket_name, wins in buckets.items():
                if not wins or bucket_name not in layout:
                    continue

                # Calculate bucket dimensions
                bucket_span = layout[bucket_name]["span"]
                bucket_width = (bucket_span / GRID_COLUMNS) * display_w
                bucket_height = display_h

                horizontal = should_tile_horizontal(
                    bucket_name,
                    bucket_width,
                    bucket_height,
                    display_w,
                )
                log(f"Bucket '{bucket_name}': {bucket_width:.0f}x{bucket_height:.0f}px, "
                    f"tiling {'horizontally' if horizontal else 'vertically'}")

                sorted_wins = sorted(wins, key=lambda w: w.get("id", 0))
                apply_bucket(
                    [w.get("id") for w in sorted_wins],
                    layout[bucket_name]["col"],
                    layout[bucket_name]["span"],
                    executor,
                    horizontal=horizontal,
                )

    # 25/50/25 tiling for legacy ultrawide
    if not use_five_buckets and ultra_index is not None:
        ultra_frame = ultra_display.get("frame", {})
        ultra_w = ultra_frame.get("w", 1)
        widget_display_override = explicit_display_override(
            displays, ["YABAI_WIDGET_DISPLAY"]
        )

        ultra_space_ids = [s.get("index") for s in spaces if s.get("display") == ultra_index]

        for space_id in ultra_space_ids:
            left_bucket: List[Dict[str, Any]] = []
            center_bucket: List[Dict[str, Any]] = []
            right_bucket: List[Dict[str, Any]] = []
            space_windows = windows_by_space.get((ultra_index, space_id), [])

            if not space_windows:
                continue

            # Bucket by window position (left/center/right thirds)
            ultrawide_buckets = ["left", "center", "right"]
            for win in space_windows:
                bucket = determine_bucket_by_position(win, ultra_display, ultrawide_buckets)
                if bucket == "left":
                    left_bucket.append(win)
                elif bucket == "right":
                    right_bucket.append(win)
                else:
                    center_bucket.append(win)

            # Sort side buckets by window ID
            left_sorted = sorted(left_bucket, key=lambda w: w.get("id", 0))
            right_sorted = sorted(right_bucket, key=lambda w: w.get("id", 0))

            # Always allocate space for all three buckets
            present_buckets = ["left", "center", "right"]

            # Apply widget padding cutout on the ultrawide display
            # Check if there's an override for widget display
            # Apply padding to ultrawide display (or override if set and matches)
            if widget_display_override is not None and widget_display_override == ultra_index:
                right_cutout = WIDGET_PADDING
            elif widget_display_override is None:
                right_cutout = WIDGET_PADDING
            else:
                right_cutout = 0

            layout = bucket_layout(present_buckets, ultra_w, center_bucket=True, right_cutout_px=right_cutout)
            if not layout:
                continue

            # Calculate display height for aspect ratio checks
            ultra_h = ultra_frame.get("h", 0)

            if left_bucket and "left" in layout:
                bucket_span = layout["left"]["span"]
                bucket_width = (bucket_span / GRID_COLUMNS) * ultra_w
                horizontal = should_tile_horizontal(
                    "left",
                    bucket_width,
                    ultra_h,
                    ultra_w,
                )
                log(f"Ultrawide bucket 'left': {bucket_width:.0f}x{ultra_h:.0f}px, "
                    f"tiling {'horizontally' if horizontal else 'vertically'}")
                apply_bucket(
                    [w.get("id") for w in left_sorted],
                    layout["left"]["col"],
                    layout["left"]["span"],
                    executor,
                    horizontal=horizontal,
                )
            if center_bucket and "center" in layout:
                center_sorted = sorted(center_bucket, key=lambda w: w.get("id", 0))
                bucket_span = layout["center"]["span"]
                bucket_width = (bucket_span / GRID_COLUMNS) * ultra_w
                horizontal = should_tile_horizontal(
                    "center",
                    bucket_width,
                    ultra_h,
                    ultra_w,
                )
                log(f"Ultrawide bucket 'center': {bucket_width:.0f}x{ultra_h:.0f}px, "
                    f"tiling {'horizontally' if horizontal else 'vertically'}")
                apply_bucket(
                    [w.get("id") for w in center_sorted],
                    layout["center"]["col"],
                    layout["center"]["span"],
                    executor,
                    horizontal=horizontal,
                )
            if right_bucket and "right" in layout:
                bucket_span = layout["right"]["span"]
                bucket_width = (bucket_span / GRID_COLUMNS) * ultra_w
                horizontal = should_tile_horizontal(
                    "right",
                    bucket_width,
                    ultra_h,
                    ultra_w,
                )
                log(f"Ultrawide bucket 'right': {bucket_width:.0f}x{ultra_h:.0f}px, "
                    f"tiling {'horizontally' if horizontal else 'vertically'}")
                apply_bucket(
                    [w.get("id") for w in right_sorted],
                    layout["right"]["col"],
                    layout["right"]["span"],
                    executor,
                    horizontal=horizontal,
                )

    # Standard display mode: apply tiling to all displays not handled by bucket/ultrawide modes
    if not use_five_buckets and ultra_index is None:
        log("Standard mode: applying tiling to all displays")
        apply_standard_tiling(
            spaces,
            windows,
            displays,
            provider,
            executor,
            exclude_displays=set(),
            windows_by_space=windows_by_space,
        )

    # In ultrawide mode, apply standard tiling to all non-ultrawide displays
    if not use_five_buckets and ultra_index is not None:
        log("Ultrawide mode: applying standard tiling to non-ultrawide displays")
        apply_standard_tiling(
            spaces,
            windows,
            displays,
            provider,
            executor,
            exclude_displays={ultra_index},
            windows_by_space=windows_by_space,
        )


if __name__ == "__main__":
    main()
