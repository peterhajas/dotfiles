#!/usr/bin/env python3
"""
Bridge Codex notify events into Claude's Notification hooks.
"""

import fnmatch
import json
import os
import shlex
import subprocess
import time
from typing import Any, Dict, Optional

LOG_FILE = "/tmp/codex-notify-bridge.log"
CLAUDE_SETTINGS = os.path.expanduser("~/.claude/settings.json")


def log(message: str) -> None:
    timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
    with open(LOG_FILE, "a", encoding="utf-8") as f:
        f.write(f"[{timestamp}] {message}\n")


def load_claude_settings() -> Dict[str, Any]:
    with open(CLAUDE_SETTINGS, "r", encoding="utf-8") as f:
        return json.load(f)


def resolve_command(command: str) -> list[str]:
    expanded = os.path.expandvars(os.path.expanduser(command))
    return shlex.split(expanded)


def matcher_matches(matcher: str, notification_type: str) -> bool:
    if not matcher or matcher == "*":
        return True
    return fnmatch.fnmatch(notification_type, matcher)


def run_hook(command: str, payload: str, timeout_ms: Optional[int]) -> Optional[Dict[str, Any]]:
    args = resolve_command(command)
    if not args:
        return None

    timeout_s = None
    if isinstance(timeout_ms, (int, float)) and timeout_ms > 0:
        timeout_s = timeout_ms / 1000.0

    try:
        result = subprocess.run(
            args,
            input=payload,
            text=True,
            capture_output=True,
            timeout=timeout_s,
            env=os.environ.copy(),
        )
    except Exception as exc:
        log(f"Hook failed: {command} ({exc})")
        return None

    stdout = result.stdout.strip()
    if not stdout:
        return None

    try:
        return json.loads(stdout)
    except json.JSONDecodeError:
        return None


def main() -> None:
    raw_input = sys.stdin.read()
    if not raw_input.strip():
        return

    try:
        data = json.loads(raw_input)
    except json.JSONDecodeError:
        log("Failed to parse notify input")
        return

    # Translate Codex notify payload into Claude Notification
    notification_type = (
        data.get("type")
        or data.get("notification_type")
        or data.get("notificationType")
        or "idle_prompt"
    )

    payload = {
        "hook_event_name": "Notification",
        "notification_type": notification_type,
        "message": data.get("message") or data.get("title") or "",
        "timestamp": data.get("timestamp") or int(time.time()),
        "cwd": data.get("cwd") or data.get("workdir") or os.getcwd(),
        "session_id": data.get("session_id") or data.get("sessionId") or "",
    }

    try:
        settings = load_claude_settings()
    except Exception as exc:
        log(f"Failed to load Claude settings: {exc}")
        return

    hook_groups = settings.get("hooks", {}).get("Notification", [])
    if not hook_groups:
        return

    payload_json = json.dumps(payload, separators=(",", ":"))

    for group in hook_groups:
        matcher = group.get("matcher", "*")
        if not matcher_matches(matcher, notification_type):
            continue
        for hook in group.get("hooks", []):
            if hook.get("type") != "command":
                continue
            run_hook(hook.get("command", ""), payload_json, hook.get("timeout"))


if __name__ == "__main__":
    import sys
    main()
